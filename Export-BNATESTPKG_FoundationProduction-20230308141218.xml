<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26" zv="IRIS for UNIX (Ubuntu Server LTS for x86-64 Containers) 2022.1.1 (Build 374U)" ts="2023-03-08 14:14:45">
<Class name="BNATESTPKG.FoundationProduction">
<ProcedureBlock>0</ProcedureBlock>
<Super>Ens.Production</Super>
<TimeChanged>66535,49167.432047432</TimeChanged>
<TimeCreated>66476,31998.343784723</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="BNATESTPKG.FoundationProduction" TestingEnabled="true" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>1</ActorPoolSize>
  <Item Name="HS.FHIR.DTL.Util.HC.SDA3.FHIR.Process" Category="" ClassName="HS.FHIR.DTL.Util.HC.SDA3.FHIR.Process" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="FHIREndpoint">/csp/healthshare/bnatest/fhir/r4</Setting>
    <Setting Target="Host" Name="FHIRMetadataSet">HL7v40 / FHIR R4 Core Specification</Setting>
    <Setting Target="Host" Name="TargetConfigName">HS.FHIRServer.Interop.Operation</Setting>
  </Item>
  <Item Name="HS.FHIRServer.Interop.Operation" Category="" ClassName="HS.FHIRServer.Interop.Operation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="BPL.patienttofhir" Category="" ClassName="BPL.patienttofhir" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="user.patientlist" Category="" ClassName="user.patientlist" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="BPLBNA.BPLCSVBNA" Category="" ClassName="BPLBNA.BPLCSVBNA" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
  <Item Name="EnsLib.RecordMap.Service.ComplexBatchFileService" Category="" ClassName="EnsLib.RecordMap.Service.ComplexBatchFileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="TargetConfigNames">BPLBNA.ajoutdanssql</Setting>
    <Setting Target="Adapter" Name="FilePath">/dur/wafik/input/</Setting>
    <Setting Target="Adapter" Name="FileSpec">*.txt</Setting>
    <Setting Target="Host" Name="ComplexMap">Patientrecord.PatientComplexeRecord</Setting>
  </Item>
  <Item Name="input" Category="" ClassName="EnsLib.RecordMap.Service.ComplexBatchFileService" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="ComplexMap">Patientrecord.PatientComplexeRecord</Setting>
    <Setting Target="Adapter" Name="FilePath">/dur/wafik/input/</Setting>
    <Setting Target="Host" Name="TargetConfigNames">BPLBNA.BPLCSVBNA</Setting>
  </Item>
  <Item Name="EnsLib.RecordMap.Service.FileService" Category="" ClassName="EnsLib.RecordMap.Service.FileService" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="RecordMap">Patientrecord.CentreAdRue1</Setting>
    <Setting Target="Host" Name="TargetConfigNames">BPLBNA.BPLCSVBNA</Setting>
    <Setting Target="Adapter" Name="FilePath">/dur/wafik/input/</Setting>
  </Item>
  <Item Name="BPLBNA.ajoutdanssql" Category="" ClassName="BPLBNA.ajoutdanssql" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="BNAsql.ajouttableActes">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66528,55945.290715531</TimeChanged>
<TimeCreated>66528,55308.220794717</TimeCreated>
<DependsOn>Patientrecord.PatientComplexeRecord.Batch,Bna.Actes</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Patientrecord.PatientComplexeRecord.Batch' targetClass='Bna.Actes' create='new' language='objectscript' >
<code>
<![CDATA[   $$$LOGINFO("inside dtl")]]]]><![CDATA[></code>
<assign value='source.DclDateActe.NewField2' property='target.ActeDateConsultation' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="BNAsql.ajouttablePatientPravite">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66528,55962.605156663</TimeChanged>
<TimeCreated>66528,55382.58545408</TimeCreated>
<DependsOn>Patientrecord.PatientComplexeRecord.Batch,Bna.PatientsPrivate</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Patientrecord.PatientComplexeRecord.Batch' targetClass='Bna.PatientsPrivate' create='new' language='objectscript' >
<assign value='source.PatientIdPrecedent.NewField2' property='target.PatientAld' action='set' />
<assign value='source.PatientProfession.NewField2' property='target.PatientProfession' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="BNAsql.insertintotableIntermidiare">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66541,50204.588055352</TimeChanged>
<TimeCreated>66540,55177.160186338</TimeCreated>
<DependsOn>Patientrecord.PatientComplexeRecord.Batch,Bna.tableSQLintermidiare</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Patientrecord.PatientComplexeRecord.Batch' targetClass='Bna.tableSQLintermidiare' create='new' language='objectscript' >
<code>
<![CDATA[   $$$LOGINFO("scdscsdcsdcsdcsdcds")]]]]><![CDATA[></code>
<assign value='source.CentreAdRue1.NewField2' property='CentreAdRue1' action='set' />
<assign value='source.CentreAdRue2.NewField2' property='CentreAdRue2' action='set' />
<assign value='source.CentreAdCp.NewField2' property='CentreAdCp' action='set' />
<assign value='source.CentreAdVille.NewField2' property='CentreAdVille' action='set' />
<assign value='source.Application.NewField2' property='Application' action='set' />
<assign value='source.CentreHdj.NewField2' property='CentreHdj' action='set' />
<assign value='source.CentreInclusion.NewField2' property='CentreInclusion' action='set' />
<assign value='source.CentreLabel.NewField2' property='CentreLabel' action='set' />
<assign value='source.CentreLabelAnnee.NewField2' property='CentreLabelAnnee' action='set' />
<assign value='source.CentreMail.NewField2' property='CentreMail' action='set' />
<assign value='source.CentreMultisite.NewField2' property='CentreMultisite' action='set' />
<assign value='source.CentreNom.NewField2' property='CentreNom' action='set' />
<assign value='source.CentreNomReseau.NewField2' property='CentreNomReseau' action='set' />
<assign value='source.CentreNum.NewField2' property='CentreNum' action='set' />
<assign value='source.CentreNumAdeli.NewField2' property='CentreNumAdeli' action='set' />
<assign value='source.CentreNumFiness.NewField2' property='CentreNumFiness' action='set' />
<assign value='source.CentreNumRmes.NewField2' property='CentreNumRmes' action='set' />
<assign value='source.CentreNumRpps.NewField2' property='CentreNumRpps' action='set' />
<assign value='source.CentreOuvConsultation.NewField2' property='CentreOuvConsultation' action='set' />
<assign value='source.CentrePersoARC.NewField2' property='CentrePersoARC' action='set' />
<assign value='source.CentrePersoASocial.NewField2' property='CentrePersoASocial' action='set' />
<assign value='source.CentrePersoAutre.NewField2' property='CentrePersoAutre' action='set' />
<assign value='source.CentrePersoDescriptionAutre.NewField2' property='CentrePersoDescriptionAutre' action='set' />
<assign value='source.CentrePersoGeriatre.NewField2' property='CentrePersoGeriatre' action='set' />
<assign value='source.CentrePersoIDE.NewField2' property='CentrePersoIDE' action='set' />
<assign value='source.CentrePersoKine.NewField2' property='CentrePersoKine' action='set' />
<assign value='source.CentrePersoNeurologue.NewField2' property='CentrePersoNeurologue' action='set' />
<assign value='source.CentrePersoOrthophoniste.NewField2' property='CentrePersoOrthophoniste' action='set' />
<assign value='source.CentrePersoPsychiatre.NewField2' property='CentrePersoPsychiatre' action='set' />
<assign value='source.CentrePersoPsychologue.NewField2' property='CentrePersoPsychologue' action='set' />
<assign value='source.CentrePersoSecretaire.NewField2' property='CentrePersoSecretaire' action='set' />
<assign value='source.CentrePersoTEC.NewField2' property='CentrePersoTEC' action='set' />
<assign value='source.CentreReseau.NewField2' property='CentreReseau' action='set' />
<assign value='source.CentreResponsable.NewField2' property='CentreResponsable' action='set' />
<assign value='source.CentreType.NewField2' property='CentreType' action='set' />
<assign value='source.ClActiviteConsultMemoire.NewField2' property='ClActiviteConsultMemoire' action='set' />
<assign value='source.ClActiviteReseau.NewField2' property='ClActiviteReseau' action='set' />
<assign value='source.ClCollabCmCmrr.NewField2' property='ClCollabCmCmrr' action='set' />
<assign value='source.ClCollabNeuroPsy.NewField2' property='ClCollabNeuroPsy' action='set' />
<assign value='source.ClNbFormAn.NewField2' property='ClNbFormAn' action='set' />
<assign value='source.ClPratiqueETP.NewField2' property='ClPratiqueETP' action='set' />
<assign value='source.ClTypeSpecialiste.NewField2' property='ClTypeSpecialiste' action='set' />
<assign value='source.CmrrActiviteAnimation.NewField2' property='CmrrActiviteAnimation' action='set' />
<assign value='source.CmrrActiviteEthique.NewField2' property='CmrrActiviteEthique' action='set' />
<assign value='source.CmrrActiviteRecherche.NewField2' property='CmrrActiviteRecherche' action='set' />
<assign value='source.CmrrCmActiviteSoutien.NewField2' property='CmrrCmActiviteSoutien' action='set' />
<assign value='source.CmrrCmActiviteStimul.NewField2' property='CmrrCmActiviteStimul' action='set' />
<assign value='source.CmrrFormationsUniv.NewField2' property='CmrrFormationsUniv' action='set' />
<assign value='source.CmrrPublications.NewField2' property='CmrrPublications' action='set' />
<assign value='source.DclALD.NewField2' property='DclALD' action='set' />
<assign value='source.DclAPA.NewField2' property='DclAPA' action='set' />
<assign value='source.DclAnneePremierDiag.NewField2' property='DclAnneePremierDiag' action='set' />
<assign value='source.DclCmrrRecours.NewField2' property='DclCmrrRecours' action='set' />
<assign value='source.DclCmrrRecoursDiagDiff.NewField2' property='DclCmrrRecoursDiagDiff' action='set' />
<assign value='source.DclCmrrRecoursPTech.NewField2' property='DclCmrrRecoursPTech' action='set' />
<assign value='source.DclCmrrRecoursSpExpert.NewField2' property='DclCmrrRecoursSpExpert' action='set' />
<assign value='source.DclCmrrRecoursSuivi.NewField2' property='DclCmrrRecoursSuivi' action='set' />
<assign value='source.DclDateActe.NewField2' property='DclDateActe' action='set' />
<assign value='source.DclDateDeces.NewField2' property='DclDateDeces' action='set' />
<assign value='source.DclDateEntreeInstitution.NewField2' property='DclDateEntreeInstitution' action='set' />
<assign value='source.DclDateFinSuivi.NewField2' property='DclDateFinSuivi' action='set' />
<assign value='source.DclDiagnostic.NewField2' property='DclDiagnostic' action='set' />
<assign value='source.DclDiagnosticN31.NewField2' property='DclDiagnosticN31' action='set' />
<assign value='source.DclDiagnosticN32.NewField2' property='DclDiagnosticN32' action='set' />
<assign value='source.DclDiagnosticN33.NewField2' property='DclDiagnosticN33' action='set' />
<assign value='source.DclEffetIndesirable.NewField2' property='DclEffetIndesirable' action='set' />
<assign value='source.DclEtatDemence.NewField2' property='DclEtatDemence' action='set' />
<assign value='source.DclFinSuivi.NewField2' property='DclFinSuivi' action='set' />
<assign value='source.DclIADLConsequence.NewField2' property='DclIADLConsequence' action='set' />
<assign value='source.DclIADLDetection.NewField2' property='DclIADLDetection' action='set' />
<assign value='source.DclIPSRAccueilJour.NewField2' property='DclIPSRAccueilJour' action='set' />
<assign value='source.DclIPSRAucun.NewField2' property='DclIPSRAucun' action='set' />
<assign value='source.DclIPSRAutre.NewField2' property='DclIPSRAutre' action='set' />
<assign value='source.DclIPSRClic.NewField2' property='DclIPSRClic' action='set' />
<assign value='source.DclIPSRErgotherapeute.NewField2' property='DclIPSRErgotherapeute' action='set' />
<assign value='source.DclIPSREsad.NewField2' property='DclIPSREsad' action='set' />
<assign value='source.DclIPSRGardeMalade.NewField2' property='DclIPSRGardeMalade' action='set' />
<assign value='source.DclIPSRGroupe.NewField2' property='DclIPSRGroupe' action='set' />
<assign value='source.DclIPSRHdj.NewField2' property='DclIPSRHdj' action='set' />
<assign value='source.DclIPSRKinesitherapeute.NewField2' property='DclIPSRKinesitherapeute' action='set' />
<assign value='source.DclIPSRMaia.NewField2' property='DclIPSRMaia' action='set' />
<assign value='source.DclIPSROrthophoniste.NewField2' property='DclIPSROrthophoniste' action='set' />
<assign value='source.DclIPSRPAERPA.NewField2' property='DclIPSRPAERPA' action='set' />
<assign value='source.DclIPSRPsychologue.NewField2' property='DclIPSRPsychologue' action='set' />
<assign value='source.DclIPSRRepits.NewField2' property='DclIPSRRepits' action='set' />
<assign value='source.DclIPSRSiad.NewField2' property='DclIPSRSiad' action='set' />
<assign value='source.DclIPSRUcc.NewField2' property='DclIPSRUcc' action='set' />
<assign value='source.DclMMSE.NewField2' property='DclMMSE' action='set' />
<assign value='source.DclMesureProtection.NewField2' property='DclMesureProtection' action='set' />
<assign value='source.DclModeDeVie.NewField2' property='DclModeDeVie' action='set' />
<assign value='source.DclPCAucun.NewField2' property='DclPCAucun' action='set' />
<assign value='source.DclPCBioMarqueurs.NewField2' property='DclPCBioMarqueurs' action='set' />
<assign value='source.DclPCIRM.NewField2' property='DclPCIRM' action='set' />
<assign value='source.DclPCPET.NewField2' property='DclPCPET' action='set' />
<assign value='source.DclPCSPECT.NewField2' property='DclPCSPECT' action='set' />
<assign value='source.DclPCScanner.NewField2' property='DclPCScanner' action='set' />
<assign value='source.DclPECAidant.NewField2' property='DclPECAidant' action='set' />
<assign value='source.DclPR.NewField2' property='DclPR' action='set' />
<assign value='source.DclPRType.NewField2' property='DclPRType' action='set' />
<assign value='source.DclPRVisite.NewField2' property='DclPRVisite' action='set' />
<assign value='source.DclRechAcceptPlacebo.NewField2' property='DclRechAcceptPlacebo' action='set' />
<assign value='source.DclRechAutonom.NewField2' property='DclRechAutonom' action='set' />
<assign value='source.DclRechContreIndic.NewField2' property='DclRechContreIndic' action='set' />
<assign value='source.DclRechPresDispo.NewField2' property='DclRechPresDispo' action='set' />
<assign value='source.DclTPAntagonisteNMDA.NewField2' property='DclTPAntagonisteNMDA' action='set' />
<assign value='source.DclTPAntagonisteNMDAAvantPEC.NewField2' property='DclTPAntagonisteNMDAAvantPEC' action='set' />
<assign value='source.DclTPAntagonisteNMDADebut.NewField2' property='DclTPAntagonisteNMDADebut' action='set' />
<assign value='source.DclTPAntagonisteNMDADebutPar.NewField2' property='DclTPAntagonisteNMDADebutPar' action='set' />
<assign value='source.DclTPAntagonisteNMDAFin.NewField2' property='DclTPAntagonisteNMDAFin' action='set' />
<assign value='source.DclTPAntagonisteNMDAFinPar.NewField2' property='DclTPAntagonisteNMDAFinPar' action='set' />
<assign value='source.DclTPAntiEpileptiques.NewField2' property='DclTPAntiEpileptiques' action='set' />
<assign value='source.DclTPAntiEpileptiquesAvantPEC.NewField2' property='DclTPAntiEpileptiquesAvantPEC' action='set' />
<assign value='source.DclTPAntiEpileptiquesDebut.NewField2' property='DclTPAntiEpileptiquesDebut' action='set' />
<assign value='source.DclTPAntiEpileptiquesDebutPar.NewField2' property='DclTPAntiEpileptiquesDebutPar' action='set' />
<assign value='source.DclTPAntiEpileptiquesFin.NewField2' property='DclTPAntiEpileptiquesFin' action='set' />
<assign value='source.DclTPAntiEpileptiquesFinPar.NewField2' property='DclTPAntiEpileptiquesFinPar' action='set' />
<assign value='source.DclTPAntiParkinsoniens.NewField2' property='DclTPAntiParkinsoniens' action='set' />
<assign value='source.DclTPAntiParkinsoniensAvantPEC.NewField2' property='DclTPAntiParkinsoniensAvantPEC' action='set' />
<assign value='source.DclTPAntiParkinsoniensDebut.NewField2' property='DclTPAntiParkinsoniensDebut' action='set' />
<assign value='source.DclTPAntiParkinsoniensDebutPar.NewField2' property='DclTPAntiParkinsoniensDebutPar' action='set' />
<assign value='source.DclTPAntiParkinsoniensFin.NewField2' property='DclTPAntiParkinsoniensFin' action='set' />
<assign value='source.DclTPAntiParkinsoniensFinPar.NewField2' property='DclTPAntiParkinsoniensFinPar' action='set' />
<assign value='source.DclTPAntidepresseurs.NewField2' property='DclTPAntidepresseurs' action='set' />
<assign value='source.DclTPAntidepresseursAvantPEC.NewField2' property='DclTPAntidepresseursAvantPEC' action='set' />
<assign value='source.DclTPAntidepresseursDebut.NewField2' property='DclTPAntidepresseursDebut' action='set' />
<assign value='source.DclTPAntidepresseursDebutPar.NewField2' property='DclTPAntidepresseursDebutPar' action='set' />
<assign value='source.DclTPAntidepresseursFin.NewField2' property='DclTPAntidepresseursFin' action='set' />
<assign value='source.DclTPAntidepresseursFinPar.NewField2' property='DclTPAntidepresseursFinPar' action='set' />
<assign value='source.DclTPAnxiolitiques.NewField2' property='DclTPAnxiolitiques' action='set' />
<assign value='source.DclTPAnxiolitiquesAvantPEC.NewField2' property='DclTPAnxiolitiquesAvantPEC' action='set' />
<assign value='source.DclTPAnxiolitiquesDebut.NewField2' property='DclTPAnxiolitiquesDebut' action='set' />
<assign value='source.DclTPAnxiolitiquesDebutPar.NewField2' property='DclTPAnxiolitiquesDebutPar' action='set' />
<assign value='source.DclTPAnxiolitiquesFin.NewField2' property='DclTPAnxiolitiquesFin' action='set' />
<assign value='source.DclTPAnxiolitiquesFinPar.NewField2' property='DclTPAnxiolitiquesFinPar' action='set' />
<assign value='source.DclTPAucun.NewField2' property='DclTPAucun' action='set' />
<assign value='source.DclTPAucunAvantPEC.NewField2' property='DclTPAucunAvantPEC' action='set' />
<assign value='source.DclTPAucunDansListe.NewField2' property='DclTPAucunDansListe' action='set' />
<assign value='source.DclTPAucunDansListeAvantPEC.NewField2' property='DclTPAucunDansListeAvantPEC' action='set' />
<assign value='source.DclTPAucunDansListeDebut.NewField2' property='DclTPAucunDansListeDebut' action='set' />
<assign value='source.DclTPAucunDansListeDebutPar.NewField2' property='DclTPAucunDansListeDebutPar' action='set' />
<assign value='source.DclTPAucunDansListeFin.NewField2' property='DclTPAucunDansListeFin' action='set' />
<assign value='source.DclTPAucunDansListeFinPar.NewField2' property='DclTPAucunDansListeFinPar' action='set' />
<assign value='source.DclTPAucunDebut.NewField2' property='DclTPAucunDebut' action='set' />
<assign value='source.DclTPAucunDebutPar.NewField2' property='DclTPAucunDebutPar' action='set' />
<assign value='source.DclTPAucunFin.NewField2' property='DclTPAucunFin' action='set' />
<assign value='source.DclTPAucunFinPar.NewField2' property='DclTPAucunFinPar' action='set' />
<assign value='source.DclTPAutres.NewField2' property='DclTPAutres' action='set' />
<assign value='source.DclTPAutresAvantPEC.NewField2' property='DclTPAutresAvantPEC' action='set' />
<assign value='source.DclTPAutresDebut.NewField2' property='DclTPAutresDebut' action='set' />
<assign value='source.DclTPAutresDebutPar.NewField2' property='DclTPAutresDebutPar' action='set' />
<assign value='source.DclTPAutresFin.NewField2' property='DclTPAutresFin' action='set' />
<assign value='source.DclTPAutresFinPar.NewField2' property='DclTPAutresFinPar' action='set' />
<assign value='source.DclTPHypnotiques.NewField2' property='DclTPHypnotiques' action='set' />
<assign value='source.DclTPHypnotiquesAvantPEC.NewField2' property='DclTPHypnotiquesAvantPEC' action='set' />
<assign value='source.DclTPHypnotiquesDebut.NewField2' property='DclTPHypnotiquesDebut' action='set' />
<assign value='source.DclTPHypnotiquesDebutPar.NewField2' property='DclTPHypnotiquesDebutPar' action='set' />
<assign value='source.DclTPHypnotiquesFin.NewField2' property='DclTPHypnotiquesFin' action='set' />
<assign value='source.DclTPHypnotiquesFinPar.NewField2' property='DclTPHypnotiquesFinPar' action='set' />
<assign value='source.DclTPInhibAcetyl.NewField2' property='DclTPInhibAcetyl' action='set' />
<assign value='source.DclTPInhibAcetylAvantPEC.NewField2' property='DclTPInhibAcetylAvantPEC' action='set' />
<assign value='source.DclTPInhibAcetylDebut.NewField2' property='DclTPInhibAcetylDebut' action='set' />
<assign value='source.DclTPInhibAcetylDebutPar.NewField2' property='DclTPInhibAcetylDebutPar' action='set' />
<assign value='source.DclTPInhibAcetylFin.NewField2' property='DclTPInhibAcetylFin' action='set' />
<assign value='source.DclTPInhibAcetylFinPar.NewField2' property='DclTPInhibAcetylFinPar' action='set' />
<assign value='source.DclTPNeuroleptiques.NewField2' property='DclTPNeuroleptiques' action='set' />
<assign value='source.DclTPNeuroleptiquesAvantPEC.NewField2' property='DclTPNeuroleptiquesAvantPEC' action='set' />
<assign value='source.DclTPNeuroleptiquesDebut.NewField2' property='DclTPNeuroleptiquesDebut' action='set' />
<assign value='source.DclTPNeuroleptiquesDebutPar.NewField2' property='DclTPNeuroleptiquesDebutPar' action='set' />
<assign value='source.DclTPNeuroleptiquesFin.NewField2' property='DclTPNeuroleptiquesFin' action='set' />
<assign value='source.DclTPNeuroleptiquesFinPar.NewField2' property='DclTPNeuroleptiquesFinPar' action='set' />
<assign value='source.DclTPNootropes.NewField2' property='DclTPNootropes' action='set' />
<assign value='source.DclTPNootropesAvantPEC.NewField2' property='DclTPNootropesAvantPEC' action='set' />
<assign value='source.DclTPNootropesDebut.NewField2' property='DclTPNootropesDebut' action='set' />
<assign value='source.DclTPNootropesDebutPar.NewField2' property='DclTPNootropesDebutPar' action='set' />
<assign value='source.DclTPNootropesFin.NewField2' property='DclTPNootropesFin' action='set' />
<assign value='source.DclTPNootropesFinPar.NewField2' property='DclTPNootropesFinPar' action='set' />
<assign value='source.DclTPThymoRegulateurs.NewField2' property='DclTPThymoRegulateurs' action='set' />
<assign value='source.DclTPThymoRegulateursAvantPEC.NewField2' property='DclTPThymoRegulateursAvantPEC' action='set' />
<assign value='source.DclTPThymoRegulateursDebut.NewField2' property='DclTPThymoRegulateursDebut' action='set' />
<assign value='source.DclTPThymoRegulateursDebutPar.NewField2' property='DclTPThymoRegulateursDebutPar' action='set' />
<assign value='source.DclTPThymoRegulateursFin.NewField2' property='DclTPThymoRegulateursFin' action='set' />
<assign value='source.DclTPThymoRegulateursFinPar.NewField2' property='DclTPThymoRegulateursFinPar' action='set' />
<assign value='source.DclTypeActe.NewField2' property='DclTypeActe' action='set' />
<assign value='source.PatientAccompagnant.NewField2' property='PatientAccompagnant' action='set' />
<assign value='source.PatientAnneeNaissance.NewField2' property='PatientAnneeNaissance' action='set' />
<assign value='source.PatientId.NewField2' property='PatientId' action='set' />
<assign value='source.PatientIdPrecedent.NewField2' property='PatientIdPrecedent' action='set' />
<assign value='source.PatientNiveauEtudes.NewField2' property='PatientNiveauEtudes' action='set' />
<assign value='source.PatientProfession.NewField2' property='PatientProfession' action='set' />
<assign value='source.PatientSexe.NewField2' property='PatientSexe' action='set' />
<assign value='source.PatientSituationGeo.NewField2' property='PatientSituationGeo' action='set' />
<assign value='source.RetourMail.NewField2' property='RetourMail' action='set' />
<assign value='source.atientEnvoyePar.NewField2' property='atientEnvoyePar' action='set' />
<assign value='source.enregistrement10.NewField2' property='enregistrement10' action='set' disabled='1' />
<sql disabled='1' >
<![CDATA[ SELECT CentreNum into :x FROM Bna.Centrestest
 where :centrenum = CentreNum]]]]><![CDATA[></sql>
<sql disabled='1' >
<![CDATA[ SELECT ID into :id1 FROM Bna.Centrestest
 where :centrenum = CentreNum]]]]><![CDATA[></sql>
<code disabled='1' >
<![CDATA[   $$$LOGINFO("x : "_x)]]]]><![CDATA[></code>
<assign value='x' property='xx' action='set' disabled='1' />
<if condition='x = centrenum' disabled='1' >
<true>
<code>
<![CDATA[  $$$LOGINFO("existe => update")]]]]><![CDATA[></code>
<sql>
<annotation>  update Bna.Centrestest
  set
  CentreAdCp = :centreadcp
  and
  CentreAdRue1 = :centreadrue1
  and
  CentreAdRue2 = :centreadrue2
  and
  CentreAdVille = :centreadville 
  and
  CentreMail = :centremail
  and
  CentreNom = :centrenom 
  and
  CentreResponsable = :centreresponsable 

  where
  CentreNum like &quot;%:centrenum%&quot; 

</annotation>
<![CDATA[  update Bna.Centrestest 
 ( CentreAdCp, CentreAdRue1, CentreAdRue2, CentreAdVille, CentreMail, CentreNom, CentreResponsable) 
 values 
 ( :centreadcp , :centreadrue1 , :centreadrue2, :centreadville , :centremail, :centrenom , :centreresponsable ) 
 where ID = :id1]]]]><![CDATA[></sql>
</true>
<false>
<sql>
<![CDATA[    insert into Bna.Centrestest
     ( CentreAdCp, CentreAdRue1, CentreAdRue2, CentreAdVille, CentreMail, CentreNom, CentreNum, CentreResponsable)
    values
    ( :centreadcp , :centreadrue1 , :centreadrue2, :centreadville , :centremail , :centrenom , :centrenum , :centreresponsable )]]]]><![CDATA[></sql>
</false>
</if>
<sql>
<![CDATA[    insert Bna.tableSQLintermidiare
     ( Application, CentreAdCp, CentreAdRue1, CentreAdRue2, CentreAdVille, CentreHdj, CentreInclusion, CentreLabel, CentreLabelAnnee, CentreMail, CentreMultisite, CentreNom, CentreNomReseau, CentreNum, CentreNumAdeli, CentreNumFiness, CentreNumRmes, CentreNumRpps, CentreOuvConsultation, CentrePersoARC, CentrePersoASocial, CentrePersoAutre, CentrePersoDescriptionAutre, CentrePersoGeriatre, CentrePersoIDE, CentrePersoKine, CentrePersoNeurologue, CentrePersoOrthophoniste, CentrePersoPsychiatre, CentrePersoPsychologue, CentrePersoSecretaire, CentrePersoTEC, CentreReseau, CentreResponsable, CentreType, ClActiviteConsultMemoire, ClActiviteReseau, ClCollabCmCmrr, ClCollabNeuroPsy, ClNbFormAn, ClPratiqueETP, ClTypeSpecialiste, CmrrActiviteAnimation, CmrrActiviteEthique, CmrrActiviteRecherche, CmrrCmActiviteSoutien, CmrrCmActiviteStimul, CmrrFormationsUniv, CmrrPublications, DclALD, DclAPA, DclAnneePremierDiag, DclCmrrRecours, DclCmrrRecoursDiagDiff, DclCmrrRecoursPTech, DclCmrrRecoursSpExpert, DclCmrrRecoursSuivi, DclDateActe, DclDateDeces, DclDateEntreeInstitution, DclDateFinSuivi, DclDiagnostic, DclDiagnosticN31, DclDiagnosticN32, DclDiagnosticN33, DclEffetIndesirable, DclEtatDemence, DclFinSuivi, DclIADLConsequence, DclIADLDetection, DclIPSRAccueilJour, DclIPSRAucun, DclIPSRAutre, DclIPSRClic, DclIPSRErgotherapeute, DclIPSREsad, DclIPSRGardeMalade, DclIPSRGroupe, DclIPSRHdj, DclIPSRKinesitherapeute, DclIPSRMaia, DclIPSROrthophoniste, DclIPSRPAERPA, DclIPSRPsychologue, DclIPSRRepits, DclIPSRSiad, DclIPSRUcc, DclMMSE, DclMesureProtection, DclModeDeVie, DclPCAucun, DclPCBioMarqueurs, DclPCIRM, DclPCPET, DclPCSPECT, DclPCScanner, DclPECAidant, DclPR, DclPRType, DclPRVisite, DclRechAcceptPlacebo, DclRechAutonom, DclRechContreIndic, DclRechPresDispo, DclTPAntagonisteNMDA, DclTPAntagonisteNMDAAvantPEC, DclTPAntagonisteNMDADebut, DclTPAntagonisteNMDADebutPar, DclTPAntagonisteNMDAFin, DclTPAntagonisteNMDAFinPar, DclTPAntiEpileptiques, DclTPAntiEpileptiquesAvantPEC, DclTPAntiEpileptiquesDebut, DclTPAntiEpileptiquesDebutPar, DclTPAntiEpileptiquesFin, DclTPAntiEpileptiquesFinPar, DclTPAntiParkinsoniens, DclTPAntiParkinsoniensAvantPEC, DclTPAntiParkinsoniensDebut, DclTPAntiParkinsoniensDebutPar, DclTPAntiParkinsoniensFin, DclTPAntiParkinsoniensFinPar, DclTPAntidepresseurs, DclTPAntidepresseursAvantPEC, DclTPAntidepresseursDebut, DclTPAntidepresseursDebutPar, DclTPAntidepresseursFin, DclTPAntidepresseursFinPar, DclTPAnxiolitiques, DclTPAnxiolitiquesAvantPEC, DclTPAnxiolitiquesDebut, DclTPAnxiolitiquesDebutPar, DclTPAnxiolitiquesFin, DclTPAnxiolitiquesFinPar, DclTPAucun, DclTPAucunAvantPEC, DclTPAucunDansListe, DclTPAucunDansListeAvantPEC, DclTPAucunDansListeDebut, DclTPAucunDansListeDebutPar, DclTPAucunDansListeFin, DclTPAucunDansListeFinPar, DclTPAucunDebut, DclTPAucunDebutPar, DclTPAucunFin, DclTPAucunFinPar, DclTPAutres, DclTPAutresAvantPEC, DclTPAutresDebut, DclTPAutresDebutPar, DclTPAutresFin, DclTPAutresFinPar, DclTPHypnotiques, DclTPHypnotiquesAvantPEC, DclTPHypnotiquesDebut, DclTPHypnotiquesDebutPar, DclTPHypnotiquesFin, DclTPHypnotiquesFinPar, DclTPInhibAcetyl, DclTPInhibAcetylAvantPEC, DclTPInhibAcetylDebut, DclTPInhibAcetylDebutPar, DclTPInhibAcetylFin, DclTPInhibAcetylFinPar, DclTPNeuroleptiques, DclTPNeuroleptiquesAvantPEC, DclTPNeuroleptiquesDebut, DclTPNeuroleptiquesDebutPar, DclTPNeuroleptiquesFin, DclTPNeuroleptiquesFinPar, DclTPNootropes, DclTPNootropesAvantPEC, DclTPNootropesDebut, DclTPNootropesDebutPar, DclTPNootropesFin, DclTPNootropesFinPar, DclTPThymoRegulateurs, DclTPThymoRegulateursAvantPEC, DclTPThymoRegulateursDebut, DclTPThymoRegulateursDebutPar, DclTPThymoRegulateursFin, DclTPThymoRegulateursFinPar, DclTypeActe, PatientAccompagnant, PatientAnneeNaissance, PatientId, PatientIdPrecedent, PatientNiveauEtudes, PatientProfession, PatientSexe, PatientSituationGeo, RetourMail, atientEnvoyePar)
    values
( :Application  , :CentreADCp  , :CentreADRue1  , :CentreADRue2  , :CentreADVille  , :CentreHdj , :CentreInclusion , :CentreLabel , :CentreLabelAnnee , :CentreMail , :CentreMultisite , :CentreNom , :CentreNomReseau , :CentreNum , :CentreNumAdeli , :CentreNumFiness , :CentreNumRmes , :CentreNumRpps , :CentreOuvConsultation , :CentrePersoARC , :CentrePersoASocial , :CentrePersoAutre , :CentrePersoDescriptionAutre , :CentrePersoGeriatre , :CentrePersoIDE , :CentrePersoKine , :CentrePersoNeurologue , :CentrePersoOrthophoniste , :CentrePersoPsychiatre , :CentrePersoPsychologue , :CentrePersoSecretaire , :CentrePersoTEC , :CentreReseau , :CentreResponsable , :CentreType , :ClActiviteConsultMemoire , :ClActiviteReseau , :ClCollabCmCmrr , :ClCollabNeuroPsy , :ClNbFormAn , :ClPratiqueETP , :ClTypeSpecialiste , :CmrrActiviteAnimation , :CmrrActiviteEthique , :CmrrActiviteRecherche , :CmrrCmActiviteSoutien , :CmrrCmActiviteStimul , :CmrrFormationsUniv , :CmrrPublications , :DclALD , :DclAPa , :DclAnneePremierDiag , :DclCmrrRecours , :DclCmrrRecoursDiagDiff , :DclCmrrRecoursPTech , :DclCmrrRecoursSpExpert , :DclCmrrRecoursSuivi , :DclDateActe , :DclDateDeces , :DclDateEntreeInstitution , :DclDateFinSuivi , :DclDiagnostic , :DclDiagnosticN31 , :DclDiagnosticN32 , :DclDiagnosticN33 , :DclEffetInDesirable , :DclEtatDemence , :DclFinSuivi , :DclIADLConsequence , :DclIADLDetection , :DclIPSRAccueilJour , :DclIPSRAucun , :DclIPSRAutre , :DclIPSRClic , :DclIPSRErgotherapeute , :DclIPSREsAD , :DclIPSRGarDeMalaDe , :DclIPSRGroupe , :DclIPSRHDj , :DclIPSRKinesitherapeute , :DclIPSRMaia , :DclIPSROrthophoniste , :DclIPSRPaERPa , :DclIPSRPsychologue , :DclIPSRRepits , :DclIPSRSiaD , :DclIPSRUcc , :DclMMSE , :DclMesureProtection , :DclMoDeDeVie , :DclPCAucun , :DclPCBioMarqueurs , :DclPCIRM , :DclPCPET , :DclPCSPECT , :DclPCScanner , :DclPECAiDant , :DclPR , :DclPRType , :DclPRVisite , :DclRechAcceptPlacebo , :DclRechAutonom , :DclRechContreInDic , :DclRechPresDispo , :DclTPantagonisteNMDA , :DclTPantagonisteNMDAAvantPEC , :DclTPantagonisteNMDADebut , :DclTPantagonisteNMDADebutPar , :DclTPantagonisteNMDAFin , :DclTPantagonisteNMDAFinPar , :DclTPantiEpileptiques , :DclTPantiEpileptiquesAvantPEC , :DclTPantiEpileptiquesDebut , :DclTPantiEpileptiquesDebutPar , :DclTPantiEpileptiquesFin , :DclTPantiEpileptiquesFinPar , :DclTPantiParkinsoniens , :DclTPantiParkinsoniensAvantPEC , :DclTPantiParkinsoniensDebut , :DclTPantiParkinsoniensDebutPar , :DclTPantiParkinsoniensFin , :DclTPantiParkinsoniensFinPar , :DclTPantiDepresseurs , :DclTPantiDepresseursAvantPEC , :DclTPantiDepresseursDebut , :DclTPantiDepresseursDebuTPar , :DclTPantiDepresseursFin , :DclTPantiDepresseursFinPar , :DclTPanxiolitiques , :DclTPanxiolitiquesAvantPEC , :DclTPanxiolitiquesDebut , :DclTPanxiolitiquesDebuTPar , :DclTPanxiolitiquesFin , :DclTPanxiolitiquesFinPar , :DclTPaucun , :DclTPaucunAvantPEC , :DclTPaucunDansListe , :DclTPaucunDansListeAvantPEC , :DclTPaucunDansListeDebut , :DclTPaucunDansListeDebuTPar , :DclTPaucunDansListeFin , :DclTPaucunDansListeFinPar , :DclTPaucunDebut , :DclTPaucunDebuTPar , :DclTPaucunFin , :DclTPaucunFinPar , :DclTPautres , :DclTPautresAvantPEC , :DclTPautresDebut , :DclTPautresDebuTPar , :DclTPautresFin , :DclTPautresFinPar , :DclTPHypnotiques , :DclTPHypnotiquesAvantPEC , :DclTPHypnotiquesDebut , :DclTPHypnotiquesDebuTPar , :DclTPHypnotiquesFin , :DclTPHypnotiquesFinPar , :DclTPInhibAcetyl , :DclTPInhibAcetylAvantPEC , :DclTPInhibAcetylDebut , :DclTPInhibAcetylDebuTPar , :DclTPInhibAcetylFin , :DclTPInhibAcetylFinPar , :DclTPNeuroleptiques , :DclTPNeuroleptiquesAvantPEC , :DclTPNeuroleptiquesDebut , :DclTPNeuroleptiquesDebuTPar , :DclTPNeuroleptiquesFin , :DclTPNeuroleptiquesFinPar , :DclTPNootropes , :DclTPNootropesAvantPEC , :DclTPNootropesDebut , :DclTPNootropesDebuTPar , :DclTPNootropesFin , :DclTPNootropesFinPar , :DclTPThymoRegulateurs , :DclTPThymoRegulateursAvantPEC , :DclTPThymoRegulateursDebut , :DclTPThymoRegulateursDebutPar , :DclTPThymoRegulateursFin , :DclTPThymoRegulateursFinPar , :DclTypeActe , :PatientAccomPagnant , :PatientAnneeNaissance , :PatientID , :PatientIDPreceDent , :PatientNiveauEtuDes , :PatientProfession , :PatientSexe , :PatientSituationGeo , :RetourMail , :atientEnvoyePar )]]]]><![CDATA[></sql>
</transform>
]]></Data>
</XData>
</Class>


<Class name="BNAsql.testinsertdanstabledetest2">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66529,47078.880346975</TimeChanged>
<TimeCreated>66529,47058.127283975</TimeCreated>
<DependsOn>Bna.testtableinsert</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Bna.testtableinsert' targetClass='Bna.testtableinsert' create='new' language='objectscript' >
<assign value='source' property='target' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="BNAtest.TBNAFHIRtestpractionner">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66535,48889.518986431</TimeChanged>
<TimeCreated>66535,48691.064843161</TimeCreated>
<DependsOn>Patientrecord.PatientComplexeRecord.Batch,HS.SDA3.Container</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='Patientrecord.PatientComplexeRecord.Batch' targetClass='HS.SDA3.Container' create='new' language='objectscript' >
<assign value='124555' property='target.Encounters.(1).AttendingClinicians.(1).Code' action='set' />
<assign value='"ffff"' property='target.Encounters.(1).AttendingClinicians.(1).Name.FamilyName' action='set' />
<assign value='"dcd"' property='target.Encounters.(1).AttendingClinicians.(1).Name.GivenName' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Class name="BPL.patienttofhir">
<Description>
</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>66478,38084.288979453</TimeChanged>
<TimeCreated>66478,34079.138951097</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Bna.ListesItems' response='Ens.Response' height='2000' width='2000' >
<context>
<property name='Tstream' type='Ens.StreamContainer' instantiate='0' />
<property name='xxl2' type='EnsLib.EDI.XML.Document' instantiate='0' />
<property name='BStream' type='HS.Message.XMLMessage' instantiate='0' />
</context>
<sequence xend='200' yend='650' >
<code xpos='200' ypos='250' >
<![CDATA[  $$$LOGINFO("wafik")
]]]]><![CDATA[>
</code>
<transform class='DTL.patienttofhirdtl' source='request' target='context.Tstream' xpos='200' ypos='350' />
<code xpos='200' ypos='450' >
<![CDATA[ set tSDA3Object = context.Tstream
     Set tQuickStream = ##class(HS.SDA3.QuickStream).%New()

    $$$ThrowOnError(tSDA3Object.XMLExportToStream(.tQuickStream))

    $$$LOGINFO("tQuickStream"_tQuickStream.Read())


       set pResponsewafik = ##class(HS.Message.XMLMessage).%New()
       Do pResponsewafik.AdditionalInfo.SetAt(tQuickStream.%Id(),"QuickStreamId")
           Do pResponsewafik.AdditionalInfo.SetAt(tSDA3Object.Patient.MPIID,"PatientResourceId")
        //wafik ajout
         set context.xxl2 = ##class(EnsLib.EDI.XML.Document).%New(tQuickStream)

         //set tSC = ..SendRequestSync("RoutingEnginetest1",xxl2)

    //type 2

    set xx = ##class(Ens.StreamContainer).%New()
    set xx.Stream = tQuickStream.Read()
    //set xx.Type = "FC"]]]]><![CDATA[>
</code>
<call name='gbgf' target='HS.FHIR.DTL.Util.HC.SDA3.FHIR.Process' async='1' xpos='200' ypos='550' >
<request type='Ens.StreamContainer' >
<assign property="callrequest" value="pResponsewafik" action="set" />
</request>
<response type='Ens.Response' />
</call>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
</Storage>
</Class>


<Class name="BPLBNA.BPLCSVBNA">
<Description>
</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>66535,48915.799432851</TimeChanged>
<TimeCreated>66409,69081.577481</TimeCreated>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
</Storage>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Patientrecord.PatientComplexeRecord.Batch' response='Ens.Response' height='2000' width='2000' >
<context>
<property name='Tstream' type='Ens.StreamContainer' instantiate='0' />
<property name='xxl2' type='EnsLib.EDI.XML.Document' instantiate='0' />
<property name='BStream' type='HS.Message.XMLMessage' instantiate='0' />
<property name='aaa' type='Patientrecord.PatientComplexeRecord.Batch' instantiate='0' />
</context>
<sequence xend='200' yend='650' >
<code xpos='200' ypos='250' >
<![CDATA[  $$$LOGINFO("wafik")]]]]><![CDATA[>
</code>
<transform class='BNAtest.TBNAFHIRtestpractionner' source='request' target='context.Tstream' xpos='200' ypos='350' />
<code xpos='200' ypos='450' >
<![CDATA[ set tSDA3Object = context.Tstream
     Set tQuickStream = ##class(HS.SDA3.QuickStream).%New()

    $$$ThrowOnError(tSDA3Object.XMLExportToStream(.tQuickStream))

    $$$LOGINFO("tQuickStream"_tQuickStream.Read())


       set pResponsewafik = ##class(HS.Message.XMLMessage).%New()
       Do pResponsewafik.AdditionalInfo.SetAt(tQuickStream.%Id(),"QuickStreamId")
           Do pResponsewafik.AdditionalInfo.SetAt(tSDA3Object.Patient.MPIID,"PatientResourceId")
        //wafik ajout
         set context.xxl2 = ##class(EnsLib.EDI.XML.Document).%New(tQuickStream)

         //set tSC = ..SendRequestSync("RoutingEnginetest1",xxl2)

    //type 2

    set xx = ##class(Ens.StreamContainer).%New()
    set xx.Stream = tQuickStream.Read()
    //set xx.Type = "FC"]]]]><![CDATA[>
</code>
<call name='gbgf' target='HS.FHIR.DTL.Util.HC.SDA3.FHIR.Process' async='1' xpos='200' ypos='550' >
<request type='Ens.StreamContainer' >
<assign property="callrequest" value="pResponsewafik" action="set" />
</request>
<response type='Ens.Response' />
</call>
</sequence>
</process>
]]></Data>
</XData>
</Class>


<Class name="BPLBNA.ajoutdanssql">
<Description>
</Description>
<Super>Ens.BusinessProcessBPL</Super>
<TimeChanged>66540,55304.78047374</TimeChanged>
<TimeCreated>66528,55116.338492794</TimeCreated>

<XData name="BPL">
<Description>
BPL Definition</Description>
<XMLNamespace>http://www.intersystems.com/bpl</XMLNamespace>
<Data><![CDATA[
<process language='objectscript' request='Patientrecord.PatientComplexeRecord.Batch' response='Ens.Response' height='2000' width='2000' >
<context>
<property name='Tstream' type='Ens.StreamContainer' instantiate='0' />
<property name='xxl2' type='EnsLib.EDI.XML.Document' instantiate='0' />
<property name='BStream' type='HS.Message.XMLMessage' instantiate='0' />
<property name='aaa' type='Patientrecord.PatientComplexeRecord.Batch' instantiate='0' />
<property name='tta' type='Bna.testtableinsert' instantiate='0' />
</context>
<sequence xend='200' yend='850' >
<code xpos='200' ypos='250' >
<![CDATA[  $$$LOGINFO("wafik")]]]]><![CDATA[>
</code>
<transform name='table centres intermidiaire' class='BNAsql.insertintotableIntermidiare' source='request' target='context.tta' xpos='200' ypos='350' />
<transform class='BNAsql.testinsertdanstabledetest2' source='context.tta' target='context.tta' xpos='200' ypos='450' />
<transform name='table actes' class='BNAsql.ajouttableActes' source='request' target='context.Tstream' xpos='200' ypos='550' />
<transform name='table patientPrivate' class='BNAsql.ajouttablePatientPravite' source='request' target='context.Tstream' xpos='200' ypos='650' />
<code xpos='200' ypos='750' >
<![CDATA[  $$$LOGINFO("finnn")]]]]><![CDATA[>
</code>
</sequence>
</process>
]]></Data>
</XData>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
</Storage>
</Class>


<Class name="Bna.Actes">
<Super>%Persistent</Super>
<TimeChanged>66476,38922.139971728</TimeChanged>
<TimeCreated>66459,58798.266876</TimeCreated>
<DependsOn>Centres,Patients,ListesItems</DependsOn>

<Property name="ActeApplicationSasie">
<Description>
Application utilisée pour la saisie</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="ActeApplicationSasieIndex">
<Properties>ActeApplicationSasie</Properties>
</Index>

<Property name="ActeCentre">
<Description>
Centre du patient au moment de l'acte</Description>
<Type>Bna.Centres</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesCentre</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeCentreIndex">
<Properties>ActeCentre</Properties>
</Index>

<Property name="ActePatient">
<Description>
Identifiant interne du patient</Description>
<Type>Bna.Patients</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesPatients</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActePatientIndex">
<Properties>ActePatient</Properties>
</Index>

<Property name="ActeDateConsultation">
<Description>
Date de l'acte</Description>
<Type>%Date</Type>
<Required>1</Required>
</Property>

<Property name="ActeTypeConsultation">
<Description>
LI - Type d'acte</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesTypeConsultation</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeTypeConsultationIndex">
<Properties>ActeTypeConsultation</Properties>
</Index>

<Property name="ActeDiagnosticStade">
<Description>
LI - Diagnostic de Niveau 1 : Stade</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesDiagnosticStade</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeDiagnosticStadeIndex">
<Properties>ActeDiagnosticStade</Properties>
</Index>

<Property name="ActeDiagnosticSyndrome">
<Description>
LI - Diagnostic de Niveau 2 : Syndrome</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesDiagnosticSyndrome</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeDiagnosticSyndromeIndex">
<Properties>ActeDiagnosticSyndrome</Properties>
</Index>

<Property name="ActeDiagnosticEtiologie1">
<Description>
LI - Diagnostic de Niveau 3 : Etiologie (1ere Valeur)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesDiagnosticEtiologie1</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeDiagnosticEtiologie1Index">
<Properties>ActeDiagnosticEtiologie1</Properties>
</Index>

<Property name="ActeDiagnosticEtiologie2">
<Description>
LI - Diagnostic de Niveau 3 : Etiologie (2ème Valeur)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesDiagnosticEtiologie2</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeDiagnosticEtiologie2Index">
<Properties>ActeDiagnosticEtiologie2</Properties>
</Index>

<Property name="ActeDiagnosticEtiologie3">
<Description>
LI - Diagnostic de Niveau 3 : Etiologie (3ème Valeur)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesDiagnosticEtiologie3</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeDiagnosticEtiologie3Index">
<Properties>ActeDiagnosticEtiologie3</Properties>
</Index>

<Property name="ActeAncienDiagnostic">
<Description>
Indique un acte réalisé avec l'ancien système de Diagnostics</Description>
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Index name="ActeAncienDiagnosticIndex">
<Properties>ActeAncienDiagnostic</Properties>
</Index>

<Property name="ActeObjetConsultation">
<Description>
LI - Objet de la consultation</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActeObjetConsultation</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeObjetConsultationIndex">
<Properties>ActeObjetConsultation</Properties>
</Index>

<Property name="ActeModaliteConsultation">
<Description>
LI - Modalité de l'acte (présentiel, téléconsultation)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesModaliteConsultation</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ActeModaliteConsultationIndex">
<Properties>ActeModaliteConsultation</Properties>
</Index>

<Property name="ActeCmrrRecours">
<Description>
Acte réalisé dans le cadre de la mission de recours (CMRR uniquement)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeCmrrRecoursIndex">
<Properties>ActeCmrrRecours</Properties>
</Index>

<Property name="ActeCmrrRecoursCause">
<Description>
LI - Cause de la mission de recours</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesCmrrRecoursCause</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeCmrrRecoursCauseIndex">
<Properties>ActeCmrrRecoursCause</Properties>
</Index>

<Property name="ActeRecherche">
<Description>
L'acte est réalisé dans le cadre d'un Protocole de Recherche</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Property name="ActeRechercheProtocole">
<Description>
LI - Type du protocole de recherche</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesRechercheProtocole</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeRechercheProtocoleIndex">
<Properties>ActeRechercheProtocole</Properties>
</Index>

<Property name="ActeRechercheVisiste">
<Description>
LI - Protocole de visite (screening, incluision, suivi)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesRechercheVisite</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeRechercheVisisteIndex">
<Properties>ActeRechercheVisiste</Properties>
</Index>

<Property name="ActeRecherchePatientAccompagnant">
<Description>
Présence et disposition d'un accompagnant pour la recherche</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeRecherchePatientAccompagnantIndex">
<Properties>ActeRecherchePatientAccompagnant</Properties>
</Index>

<Property name="ActeRecherchePatientAutonomie">
<Description>
Autonomie nécessaire pour déplacements lors des visites</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeRecherchePatientAutonomieIndex">
<Properties>ActeRecherchePatientAutonomie</Properties>
</Index>

<Property name="ActeRecherchePatientContreIndication">
<Description>
Pas de contre-indication pour la recherche</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeRecherchePatientContreIndicationIndex">
<Properties>ActeRecherchePatientContreIndication</Properties>
</Index>

<Property name="ActeRecherchePatientPlacebo">
<Description>
Acceptation placébo</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeRecherchePatientPlaceboIndex">
<Properties>ActeRecherchePatientPlacebo</Properties>
</Index>

<Property name="ActeExamenAucun">
<Description>
Aucun examen consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenAucunIndex">
<Properties>ActeExamenAucun</Properties>
</Index>

<Property name="ActeExamenScanner">
<Description>
Examen scanner consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenScannerIndex">
<Properties>ActeExamenScanner</Properties>
</Index>

<Property name="ActeExamenPET">
<Description>
Examen PET consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenPETIndex">
<Properties>ActeExamenPET</Properties>
</Index>

<Property name="ActeExamenSPECT">
<Description>
Examen SPECT consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenSPECTIndex">
<Properties>ActeExamenSPECT</Properties>
</Index>

<Property name="ActeExamenIRM">
<Description>
Examen IRM consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenIRMIndex">
<Properties>ActeExamenIRM</Properties>
</Index>

<Property name="ActeExamenBiomarqueurs">
<Description>
Examen biomarqueurs consulté lors de l'acte</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeExamenBiomarqueursIndex">
<Properties>ActeExamenBiomarqueurs</Properties>
</Index>

<Property name="ActeScoreMMSE">
<Description>
Score Mini Mental Test (sur 30)</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="30"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Index name="ActeScoreMMSEIndex">
<Properties>ActeScoreMMSE</Properties>
</Index>

<Property name="ActeScoreIADL">
<Description>
Score IADL Détection (sur 4)</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="4"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Index name="ActeScoreIADLIndex">
<Properties>ActeScoreIADL</Properties>
</Index>

<Property name="ActeScoreMOCA">
<Description>
Score MOCA (sur 30)</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="30"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Index name="ActeScoreMOCAIndex">
<Properties>ActeScoreMOCA</Properties>
</Index>

<Property name="ActePraxie">
<Description>
Praxie</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Property name="ActeTpAucun">
<Description>
Aucun traitement pharmacologique</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeTpAucunIndex">
<Properties>ActeTpAucun</Properties>
</Index>

<Property name="ActeTpAucunDansListe">
<Description>
Aucun tratement pharmacologique de la liste</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeTpAucunDansListeIndex">
<Properties>ActeTpAucunDansListe</Properties>
</Index>

<Property name="ActeTpEffetIndesirable">
<Description>
LI - Effet indésirable au(x) traitement(s) pharmacologique(s)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ActesTpEffetIndesirable</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeTpEffetIndesirableIndex">
<Properties>ActeTpEffetIndesirable</Properties>
</Index>

<Property name="ActePcnpAucune">
<Description>
Aucune prise en charge non pharmacologique</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpAucuneIndex">
<Properties>ActePcnpAucune</Properties>
</Index>

<Property name="ActePcnpOrthophoniste">
<Description>
Prise en charge par un orthophoniste</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpOrthophonisteIndex">
<Properties>ActePcnpOrthophoniste</Properties>
</Index>

<Property name="ActePcnpPsychologue">
<Description>
Prise en charge par un psychologue</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpPsychologueIndex">
<Properties>ActePcnpPsychologue</Properties>
</Index>

<Property name="ActePcnpKinesitherapeute">
<Description>
Prise en charge par un kinésithérapeute</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpKinesitherapeuteIndex">
<Properties>ActePcnpKinesitherapeute</Properties>
</Index>

<Property name="ActePcnpErgotherapeute">
<Description>
Prise en charge par un ergothérapeute</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpErgotherapeuteIndex">
<Properties>ActePcnpErgotherapeute</Properties>
</Index>

<Property name="ActePcnpGroupe">
<Description>
Prise en charge par un groupe d'intervenants</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpGroupeIndex">
<Properties>ActePcnpGroupe</Properties>
</Index>

<Property name="ActePcnpAccueilJour">
<Description>
Prise en charge par un accueil de jour</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpAccueilJourIndex">
<Properties>ActePcnpAccueilJour</Properties>
</Index>

<Property name="ActePcnpCoordonateurDAC">
<Description>
Prise en charge par un DAC</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpCoordonateurDACIndex">
<Properties>ActePcnpCoordonateurDAC</Properties>
</Index>

<Property name="ActePcnpRepits">
<Description>
Prise en charge par une plateforme de répits</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpRepitsIndex">
<Properties>ActePcnpRepits</Properties>
</Index>

<Property name="ActePcnpSIAD">
<Description>
Prise en charge par un SIAD</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpSIADIndex">
<Properties>ActePcnpSIAD</Properties>
</Index>

<Property name="ActePcnpESAD">
<Description>
Prise en charge par un ESAD</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpESADIndex">
<Properties>ActePcnpESAD</Properties>
</Index>

<Property name="ActePcnpHDJ">
<Description>
Prise en charge par un Hôpital de jour</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpHDJIndex">
<Properties>ActePcnpHDJ</Properties>
</Index>

<Property name="ActePcnpUCC">
<Description>
Prise en charge par une UCC</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpUCCIndex">
<Properties>ActePcnpUCC</Properties>
</Index>

<Property name="ActePcnpAutre">
<Description>
Autre prise en charge non pharmacologique</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActePcnpAutreIndex">
<Properties>ActePcnpAutre</Properties>
</Index>

<Property name="ActeTsCreation">
<Description>
Timestamp création</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Property name="ActeTsDerniereModification">
<Description>
Timestamp dernière modification</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Property name="ActeValide">
<Description>
Indique que l'acte est valide (complet) ou en cours de saisie</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Index name="ActeValideIndex">
<Properties>ActeValide</Properties>
</Index>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="TraceActionsActe">
<Type>Bna.TraceActions</Type>
<Cardinality>many</Cardinality>
<Inverse>TraceActe</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TraitementsActesActe">
<Type>Bna.TraitementsActes</Type>
<Cardinality>many</Cardinality>
<Inverse>Acte</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.ActesD</DataLocation>
<DefaultData>ActesDefaultData</DefaultData>
<IdLocation>^Bna.ActesD</IdLocation>
<IndexLocation>^Bna.ActesI</IndexLocation>
<StreamLocation>^Bna.ActesS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="ActesDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ActeCentre</Value>
</Value>
<Value name="3">
<Value>ActePatient</Value>
</Value>
<Value name="4">
<Value>ActeDateConsultation</Value>
</Value>
<Value name="5">
<Value>ActeTypeConsultation</Value>
</Value>
<Value name="6">
<Value>ActeDiagnosticStade</Value>
</Value>
<Value name="7">
<Value>ActeDiagnosticSyndrome</Value>
</Value>
<Value name="8">
<Value>ActeDiagnosticEtiologie1</Value>
</Value>
<Value name="9">
<Value>ActeDiagnosticEtiologie2</Value>
</Value>
<Value name="10">
<Value>ActeDiagnosticEtiologie3</Value>
</Value>
<Value name="11">
<Value>ActeAncienDiagnostic</Value>
</Value>
<Value name="12">
<Value>ActeObjetConsultation</Value>
</Value>
<Value name="13">
<Value>ActeModaliteConsultation</Value>
</Value>
<Value name="14">
<Value>ActeCmrrRecours</Value>
</Value>
<Value name="15">
<Value>ActeCmrrRecoursDiagDiff</Value>
</Value>
<Value name="16">
<Value>ActeCmrrRecoursPTech</Value>
</Value>
<Value name="17">
<Value>ActeCmrrRecoursSpExpert</Value>
</Value>
<Value name="18">
<Value>ActeCmrrRecoursSuivi</Value>
</Value>
<Value name="19">
<Value>ActeRecherche</Value>
</Value>
<Value name="20">
<Value>ActeRechercheProtocole</Value>
</Value>
<Value name="21">
<Value>ActeRechercheVisiste</Value>
</Value>
<Value name="22">
<Value>ActeRecherchePatientAccompagnant</Value>
</Value>
<Value name="23">
<Value>ActeRecherchePatientAutonomie</Value>
</Value>
<Value name="24">
<Value>ActeRecherchePatientContreIndication</Value>
</Value>
<Value name="25">
<Value>ActeRecherchePatientPlacebo</Value>
</Value>
<Value name="26">
<Value>ActeExamenAucun</Value>
</Value>
<Value name="27">
<Value>ActeExamenScanner</Value>
</Value>
<Value name="28">
<Value>ActeExamenPET</Value>
</Value>
<Value name="29">
<Value>ActeExamenSPECT</Value>
</Value>
<Value name="30">
<Value>ActeExamenIRM</Value>
</Value>
<Value name="31">
<Value>ActeExamenBiomarqueurs</Value>
</Value>
<Value name="32">
<Value>ActeScoreMMSE</Value>
</Value>
<Value name="33">
<Value>ActeScoreIADL</Value>
</Value>
<Value name="34">
<Value>ActeScoreMOCA</Value>
</Value>
<Value name="35">
<Value>ActePraxie</Value>
</Value>
<Value name="36">
<Value>ActeTpAucun</Value>
</Value>
<Value name="37">
<Value>ActeTpAucunDansListe</Value>
</Value>
<Value name="38">
<Value>ActeTpEffetIndesirable</Value>
</Value>
<Value name="39">
<Value>ActePcnpAucune</Value>
</Value>
<Value name="40">
<Value>ActePcnpOrthophoniste</Value>
</Value>
<Value name="41">
<Value>ActePcnpPsychologue</Value>
</Value>
<Value name="42">
<Value>ActePcnpKinesitherapeute</Value>
</Value>
<Value name="43">
<Value>ActePcnpErgotherapeute</Value>
</Value>
<Value name="44">
<Value>ActePcnpGroupe</Value>
</Value>
<Value name="45">
<Value>ActePcnpAccueilJour</Value>
</Value>
<Value name="46">
<Value>ActePcnpCoordonateurDAC</Value>
</Value>
<Value name="47">
<Value>ActePcnpRepits</Value>
</Value>
<Value name="48">
<Value>ActePcnpSIAD</Value>
</Value>
<Value name="49">
<Value>ActePcnpESAD</Value>
</Value>
<Value name="50">
<Value>ActePcnpHDJ</Value>
</Value>
<Value name="51">
<Value>ActePcnpUCC</Value>
</Value>
<Value name="52">
<Value>ActePcnpAutre</Value>
</Value>
<Value name="53">
<Value>ActeTsCreation</Value>
</Value>
<Value name="54">
<Value>ActeTsDerniereModification</Value>
</Value>
<Value name="55">
<Value>ActeValide</Value>
</Value>
<Value name="56">
<Value>ActeCmrrRecoursCause</Value>
</Value>
<Value name="57">
<Value>ActeApplicationSasie</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.Centres">
<Super>%Persistent</Super>
<TimeChanged>66476,38933.402040436</TimeChanged>
<TimeCreated>66457,42913.254829</TimeCreated>
<DependsOn>ListesItems</DependsOn>

<Property name="CentreParent">
<Description>
Centre de ratachement (si hiérarchie de centres)</Description>
<Type>Bna.Centres</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresEnfants</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreParentIndex">
<Properties>CentreParent</Properties>
</Index>

<Property name="CentresEnfants">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreParent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentreNum">
<Description><![CDATA[
Identifiant externe du centre. <nom de l'aplication><n° du centre dans l'application>. Pour le DMA n° dans l'application = <département><n° séquentiel> Ex : DMA06001]]></Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="CentreNumIndex">
<Properties>CentreNum</Properties>
</Index>

<Property name="CentreApplication">
<Description>
Application émettrice</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="CentreApplicationIndex">
<Properties>CentreApplication</Properties>
</Index>

<Property name="CentreNom">
<Description>
Nom du Centre. Ex : CMRR de Nice</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="CentreAdRue1">
<Description>
Adresse du centre (n° et rue)</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="CentreAdRue2">
<Description>
Adresse du centre (complément d'adresse)</Description>
<Type>%String</Type>
</Property>

<Property name="CentreAdCp">
<Description>
Adresse du centre (code postal)</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="5"/>
</Property>

<Property name="CentreAdVille">
<Description>
Adresse du centre (ville)</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="CentreDepartement">
<Description>
Département</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresDepartement</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreDepartementIndex">
<Properties>CentreDepartement</Properties>
</Index>

<Property name="CentreRegion">
<Description>
Région</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresRegion</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreRegionIndex">
<Properties>CentreRegion</Properties>
</Index>

<Property name="CentreMail">
<Description>
Adresse e-mail</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="CentreType">
<Description>
Type du centre</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresType</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreTypeIndex">
<Properties>CentreType</Properties>
</Index>

<Property name="CentreResponsable">
<Description>
Nom du responsable du centre</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="120"/>
</Property>

<Property name="CentreTsCreation">
<Description>
Timestamp création</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Property name="CentreTsDerniereModification">
<Description>
Timestamp dernière modification</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="CentresAnnuelsCentre">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>Centre</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsCentre">
<Type>Bna.Patients</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientCentre</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesCentre">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeCentre</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TraceActionsCentre">
<Type>Bna.TraceActions</Type>
<Cardinality>many</Cardinality>
<Inverse>TraceCentre</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.CentresD</DataLocation>
<DefaultData>CentresDefaultData</DefaultData>
<IdLocation>^Bna.CentresD</IdLocation>
<IndexLocation>^Bna.CentresI</IndexLocation>
<StreamLocation>^Bna.CentresS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="CentresDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreParent</Value>
</Value>
<Value name="3">
<Value>CentreNum</Value>
</Value>
<Value name="4">
<Value>CentreApplication</Value>
</Value>
<Value name="5">
<Value>CentreNom</Value>
</Value>
<Value name="6">
<Value>CentreAdRue1</Value>
</Value>
<Value name="7">
<Value>CentreAdRue2</Value>
</Value>
<Value name="8">
<Value>CentreAdCp</Value>
</Value>
<Value name="9">
<Value>CentreAdVille</Value>
</Value>
<Value name="10">
<Value>CentreDepartement</Value>
</Value>
<Value name="11">
<Value>CentreRegion</Value>
</Value>
<Value name="12">
<Value>CentreMail</Value>
</Value>
<Value name="13">
<Value>CentreType</Value>
</Value>
<Value name="14">
<Value>CentreResponsable</Value>
</Value>
<Value name="15">
<Value>CentreTsCreation</Value>
</Value>
<Value name="16">
<Value>CentreTsDerniereModification</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.CentresAnnuels">
<Super>%Persistent</Super>
<TimeChanged>66512,47718.429581031</TimeChanged>
<TimeCreated>66458,61838.072112</TimeCreated>
<DependsOn>ListesItems</DependsOn>

<Property name="Centre">
<Description>
Centre lié</Description>
<Type>Bna.Centres</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsCentre</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreIndex">
<Properties>Centre</Properties>
</Index>

<Property name="Annee">
<Description>
Année des données du centre</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Index name="AnneeIndex">
<Properties>Centre,Annee</Properties>
<Unique>1</Unique>
</Index>

<Property name="CentreLabel">
<Description>
LI - Indique si le centre est labelisé</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsLabel</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreLabelIndex">
<Properties>CentreLabel</Properties>
</Index>

<Property name="CentreLabelAnnee">
<Description>
Année de labelisation du Centre</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Property name="CentreReseau">
<Description>
LI - Indique si le centre fait partie du réseau</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsReseau</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreReseauIndex">
<Properties>CentreReseau</Properties>
</Index>

<Property name="CentreNomReseau">
<Description>
Nom du réseau (obligatoire si CentreReseau = Oui)</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="80"/>
</Property>

<Property name="CentreInclusion">
<Description>
LI - Inclusion du centre à une structure</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsInclusion</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreInclusionIndex">
<Properties>CentreInclusion</Properties>
</Index>

<Property name="CentreMultisite">
<Description>
LI - Indique si le centre est multisite</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsMultisite</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreMultisiteIndex">
<Properties>CentreMultisite</Properties>
</Index>

<Property name="CentreHdj">
<Description>
LI - Indique si le centre comporte un Hôpital de jour</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsHdj</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="CentreHdjIndex">
<Properties>CentreHdj</Properties>
</Index>

<Property name="CentreOuvConsultation">
<Description>
Nombre de demi-journée d'ouverture du centre en consukltation (0 à 10)</Description>
<Type>%SmallInt</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="CentrePersoGeriatre">
<Description><![CDATA[
ETP Gériatre (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoNeurologue">
<Description><![CDATA[
ETP Neurologue (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoPsychiatre">
<Description><![CDATA[
ETP Psychiatre (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoPsychologue">
<Description><![CDATA[
ETP Psychologue (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoOrthophoniste">
<Description><![CDATA[
ETP Orthophoniste (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoKinesitherapeute">
<Description><![CDATA[
ETP Kinésithérapeute (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoAssistantSocial">
<Description><![CDATA[
ETP Assistant social (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoSecretaire">
<Description><![CDATA[
ETP Secrétaire (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoIDE">
<Description><![CDATA[
ETP Infirmier (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoARC">
<Description><![CDATA[
ETP ARC (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoTEC">
<Description><![CDATA[
ETP TEC (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoAutre">
<Description><![CDATA[
ETP Autre (<10)]]></Description>
<Type>%Decimal</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
<Parameter name="SCALE" value="2"/>
</Property>

<Property name="CentrePersoDescriptionAutre">
<Description>
Description autre personnel</Description>
<Type>%String</Type>
</Property>

<Property name="CentreNumRmes">
<Description>
N° RMES du centre si applicable</Description>
<Type>%String</Type>
</Property>

<Property name="CentreNumFiness">
<Description>
N° FINESS du centre si applicable</Description>
<Type>%String</Type>
</Property>

<Property name="CentreNumAdeli">
<Description>
N° Adeli du centre si applicable</Description>
<Type>%String</Type>
</Property>

<Property name="CentreNumRpps">
<Description>
N° RPPS du centre si applicable</Description>
<Type>%String</Type>
</Property>

<Property name="CentreCmrrActiviteAnimation">
<Description>
CMRR - Activité d'Animation (Nombre de journées consacrées par an</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="CentreCmrrActiviteEthique">
<Description>
CMRR - Activité Éthique (Nombre de journées consacrées par an</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="CentreCmrrActiviteFormation">
<Description>
CMRR - Activité de formation (Nombre de journées consacrées par an.</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="CentreCmrrActiviteRecherche">
<Description>
CMRR - Activité de Recherche (Nombre de journées consacrées par an</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="99"/>
</Property>

<Property name="CentreCmrrFormationsUniv">
<Description>
CMRR - Nombre de journées de formation universitaire réalisées au cours de l'année.</Description>
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="999"/>
</Property>

<Property name="CentreCmrrPublications">
<Description>
CMRR - Nombre de publications réalisées au cours de l'année.</Description>
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="999"/>
</Property>

<Property name="CentreCmrrCmActiviteSoutien">
<Description>
LI - Pour CMRR et CM : Activité Soutien </Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsActiviteSoutien</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreCmrrCmActiviteSoutienIndex">
<Properties>CentreCmrrCmActiviteSoutien</Properties>
</Index>

<Property name="CentreCmrrCmActiviteStimul">
<Description>
LI - Pour CMRR et CM : Activité Stumulation</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsActivitéStimulation</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreCmrrCmActiviteStimulIndex">
<Properties>CentreCmrrCmActiviteStimul</Properties>
</Index>

<Property name="CentreClTypeSpecialiste">
<Description>
LI - Pour CL - Type de spécialiste</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsTypeSpecialiste</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreClTypeSpecialisteIndex">
<Properties>CentreClTypeSpecialiste</Properties>
</Index>

<Property name="CentreClCollabNeuroPsy">
<Description>
LI - Pour CL - Indique si le CL collabore avec un neuropsychologue</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentreAnnuelsCollabNeuroPsy</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreClCollabNeuroPsyIndex">
<Properties>CentreClCollabNeuroPsy</Properties>
</Index>

<Property name="CentreClPratiqueNeuroETP">
<Description>
Pour CL - Nombre de demi-jpournée consacré à la pratique neurologique</Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="10"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Property name="CentreClActiviteConsultMemoire">
<Description>
Pour CL - LI - Activité clinique au sein d'une consultation mémoire</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsActiviteConsultMemoire</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreClActiviteConsultMemoireIndex">
<Properties>CentreClActiviteConsultMemoire</Properties>
</Index>

<Property name="CentreClCollabCmCmrr">
<Description>
Pour CL - LI - Collaboration avec une CM ou un CMRR</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsCollabCmCmrr</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreClCollabCmCmrrIndex">
<Properties>CentreClCollabCmCmrr</Properties>
</Index>

<Property name="CentreClActiviteReseau">
<Description>
Pour CL - LI - Activité dans un réseau</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>CentresAnnuelsActivieReseau</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="CentreClActiviteReseauIndex">
<Properties>CentreClActiviteReseau</Properties>
</Index>

<Property name="CentreClNbFormationAnnnee">
<Description><![CDATA[
Pour CL - LI - Nombre de formation par an (< 1000)]]></Description>
<Type>%SmallInt</Type>
<Parameter name="MAXVAL" value="999"/>
</Property>

<Property name="CentreTsCreation">
<Description>
Timestamp création</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Property name="CentreTsDerniereModification">
<Description>
Timestamp dernière modification</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.CentresAnnuelsD</DataLocation>
<DefaultData>CentresAnnuelsDefaultData</DefaultData>
<IdLocation>^Bna.CentresAnnuelsD</IdLocation>
<IndexLocation>^Bna.CentresAnnuelsI</IndexLocation>
<StreamLocation>^Bna.CentresAnnuelsS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="CentresAnnuelsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Centre</Value>
</Value>
<Value name="3">
<Value>Annee</Value>
</Value>
<Value name="4">
<Value>CentreLabel</Value>
</Value>
<Value name="5">
<Value>CentreLabelAnnee</Value>
</Value>
<Value name="6">
<Value>CentreReseau</Value>
</Value>
<Value name="7">
<Value>CentreNomReseau</Value>
</Value>
<Value name="8">
<Value>CentreInclusion</Value>
</Value>
<Value name="9">
<Value>CentreMultisite</Value>
</Value>
<Value name="10">
<Value>CentreHdj</Value>
</Value>
<Value name="11">
<Value>CentreOuvConsultation</Value>
</Value>
<Value name="12">
<Value>CentrePersoGeriatre</Value>
</Value>
<Value name="13">
<Value>CentrePersoNeurologue</Value>
</Value>
<Value name="14">
<Value>CentrePersoPsychiatre</Value>
</Value>
<Value name="15">
<Value>CentrePersoPsychologue</Value>
</Value>
<Value name="16">
<Value>CentrePersoOrthophoniste</Value>
</Value>
<Value name="17">
<Value>CentrePersoKinesitherapeute</Value>
</Value>
<Value name="18">
<Value>CentrePersoAssistantSocial</Value>
</Value>
<Value name="19">
<Value>CentrePersoSecretaire</Value>
</Value>
<Value name="20">
<Value>CentrePersoIDE</Value>
</Value>
<Value name="21">
<Value>CentrePersoARC</Value>
</Value>
<Value name="22">
<Value>CentrePersoTEC</Value>
</Value>
<Value name="23">
<Value>CentrePersoAutre</Value>
</Value>
<Value name="24">
<Value>CentrePersoDescriptionAutre</Value>
</Value>
<Value name="25">
<Value>CentreNumRmes</Value>
</Value>
<Value name="26">
<Value>CentreNumFiness</Value>
</Value>
<Value name="27">
<Value>CentreNumAdeli</Value>
</Value>
<Value name="28">
<Value>CentreNumRpps</Value>
</Value>
<Value name="29">
<Value>CentreCmrrActiviteAnimation</Value>
</Value>
<Value name="30">
<Value>CentreCmrrActiviteEthique</Value>
</Value>
<Value name="31">
<Value>CentreCmrrActiviteFormation</Value>
</Value>
<Value name="32">
<Value>CentreCmrrActiviteRecherche</Value>
</Value>
<Value name="33">
<Value>CentreCmrrFormationsUniv</Value>
</Value>
<Value name="34">
<Value>CentreCmrrPublications</Value>
</Value>
<Value name="35">
<Value>CentreCmrrCmActiviteSoutien</Value>
</Value>
<Value name="36">
<Value>CentreCmrrCmActiviteStimul</Value>
</Value>
<Value name="37">
<Value>CentreClTypeSpecialiste</Value>
</Value>
<Value name="38">
<Value>CentreClCollabNeuroPsy</Value>
</Value>
<Value name="39">
<Value>CentreClPratiqueNeuroETP</Value>
</Value>
<Value name="40">
<Value>CentreClActiviteConsultMemoire</Value>
</Value>
<Value name="41">
<Value>CentreClCollabCmCmrr</Value>
</Value>
<Value name="42">
<Value>CentreClActiviteReseau</Value>
</Value>
<Value name="43">
<Value>CentreClNbFormationAnnnee</Value>
</Value>
<Value name="44">
<Value>CentreTsCreation</Value>
</Value>
<Value name="45">
<Value>CentreTsDerniereModification</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.Listes">
<Super>%Persistent,Bna.Utils</Super>
<TimeChanged>66476,39216.493903331</TimeChanged>
<TimeCreated>66456,59664.657518</TimeCreated>

<Property name="ListeNom">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Index name="ListeNomIndex">
<Properties>ListeNom</Properties>
<Unique>1</Unique>
</Index>

<Property name="ListeNomCourt">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="ListeNomCourtIndex">
<Properties>ListeNomCourt</Properties>
<Unique>1</Unique>
</Index>

<Property name="ListeTip">
<Description>
Texte affiché</Description>
<Type>%Text</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="Items">
<Type>Bna.ListesItems</Type>
<Cardinality>many</Cardinality>
<Inverse>Liste</Inverse>
<Relationship>1</Relationship>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Initialisations

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Parameter name="props">
<Default>ListeNom,ListeNomCourt,ListeTip</Default>
</Parameter>

<Method name="Init">
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "Initialisation des listes", !

	/// Suppression pour intégrité référentielle
	&sql(update Bna.ListesItems set ItemParent=null)
	&sql(truncate table Bna.ListesItems)
	
	/// Suppression données
	&sql(truncate table Bna.Listes)
	
	Do ..AddObject(..#props, details, "Région", "CentreRegion", "Liste pour item CentreRegion (région du centre)")
	Do ..AddObject(..#props, details, "Département", "CentreDepartement", "Liste pour item CentreDepartement (département du centre")
	Do ..AddObject(..#props, details, "Type de centre", "CentreType", "Liste pour item CentreType (type du centre)")
	Do ..AddObject(..#props, details, "Label", "CentreLabel", "Liste pour item CentreLabel (Le centre est labelisé)")
	Do ..AddObject(..#props, details, "Reseau", "CentreReseau", "Liste pour item CentreReseau (centre appartenant à un réseau")
	Do ..AddObject(..#props, details, "Inclusion", "CentreInclusion", "Liste pour item CentreInclusion (inclusion du centre à une structure)")
	Do ..AddObject(..#props, details, "Multisite", "CentreMultisite", "Liste pour item CentreMultisite (Le centre dispose de plusieurs sites)")
	Do ..AddObject(..#props, details, "Hôpital de jour", "CentreHdj", "Liste pour item CentreHdj (le centre comporte un hôpital de jour)")
	Do ..AddObject(..#props, details, "Activité de soutien", "CentreCmrrCmActiviteSoutien", "Liste pour item CentreCmrrCmActiviteSoutien (il existe une activité de soutien aux aidants pour le centre)")
	Do ..AddObject(..#props, details, "Activité de simulation", "CentreCmrrCmActiviteStimul", "Liste pour item CentreCmrrCmActiviteStimul (il existe une activité de stimulation pour le centre)")
	Do ..AddObject(..#props, details, "Type de spécialiste", "CentreClTypeSpecialiste", "Liste pour item CentreClTypeSpecialiste (type du spécialiste libéral)")
	Do ..AddObject(..#props, details, "Collaboration neuro-psychiatre", "CentreClCollabNeuroPsy", "Liste pour item CentreClCollabNeuroPsy (Le spécialiste collabore avec un neuro-psychiatre)")
	Do ..AddObject(..#props, details, "Activité dans CM", "CentreClActiviteConsultMemoire", "Liste pour item CentreClActiviteConsultMemoire (Activité clinique au sein d'une consultation mémoire)")
	Do ..AddObject(..#props, details, "collaboration CM/CMRR", "CentreClCollabCmCmrr", "Liste pour item CentreClCollabCmCmrr (Collaboration avec une CM ou un CMRR)")
	Do ..AddObject(..#props, details, "Activité dans reseau", "CentreClActiviteReseau", "Liste pour item CentreClActiviteReseau (Activité dans un réseau)")

	Do ..AddObject(..#props, details, "Accompagnant", "PatientAccompagnant", "Liste pour item PatientAccompagnant (Accompagnant)")
	Do ..AddObject(..#props, details, "Niveau d'études", "PatientNiveauEtudes", "Liste pour item PatientNiveauEtudes (Niveau d'études)")
	Do ..AddObject(..#props, details, "Langue maternelle", "PatientLangueMaternelle", "Liste pour item PatientLangueMaternelle (Langue maternelle)")
	Do ..AddObject(..#props, details, "Profession", "PatientProfession", "Liste pour item PatientProfession (Profession)")
	Do ..AddObject(..#props, details, "Type de prescripteur", "PatientEnvoyePar", "Liste pour item PatientEnvoyePar (Type de prescripteur)")
	Do ..AddObject(..#props, details, "Situation géographique", "PatientSituationGeographique", "Liste pour item PatientSituationGeographique (Situation géographique)")
	Do ..AddObject(..#props, details, "Mode de vie", "PatientModeDeVie", "Liste pour item PatientModeDeVie (Mode de vie)")
	Do ..AddObject(..#props, details, "Mesure de protection", "PatientMesureProtection", "Liste pour item PatientMesureProtection (Mesure de protection)")
	Do ..AddObject(..#props, details, "Allocation Personnalisée d'autonomie", "PatientApa", "Liste pour item PatientApa (Allocation Personnalisée d'autonomie)")
	Do ..AddObject(..#props, details, "Affection de Longue Durée", "PatientAld", "Liste pour item PatientAld (Affection de Longue Durée)")
	Do ..AddObject(..#props, details, "Type de fin de suivi", "PatientFinSuivi", "Liste pour item PatientFinSuivi (Type de fin de suivi)")
	Do ..AddObject(..#props, details, "Soutien psychologique pour l'accompagnant", "PatientSoutienPsyAccompagnant", "Liste pour item PatientSoutienPsyAccompagnant (Soutien psychologique pour l'accompagnant)")

	Do ..AddObject(..#props, details, "Type d'acte", "ActeTypeConsultation", "Liste pour item ActeTypeConsultation (Type d'acte)")
	Do ..AddObject(..#props, details, "Diagnostic de Niveau 1 : Etat Démence (ancien système de diagnostics)", "ActeAncienDiagnosticStade", "Liste pour item ActeAncienDiagnosticStade (Diagnostic de Niveau 1 : Etat Démence (ancien système de diagnostics))")
	Do ..AddObject(..#props, details, "Diagnostic de Niveau 1 : Stade", "ActeDiagnosticStade", "Liste pour item ActeDiagnosticStade (Diagnostic de Niveau 1 : Stade)")
	Do ..AddObject(..#props, details, "Diagnostic de Niveau 2 : diagnostic (ancien système de diagnostics)", "ActeAncienDiagnosticSyndrome", "Liste pour item ActeAncienDiagnosticSyndrome (Diagnostic de Niveau 2 : Diagnostic (ancien système de diagnostics))")
	Do ..AddObject(..#props, details, "Diagnostic de Niveau 2 : Syndrome", "ActeDiagnosticSyndrome", "Liste pour item ActeDiagnosticSyndrome (Diagnostic de Niveau 2 : Syndrome)")
	Do ..AddObject(..#props, details, "Diagnostic de Niveau 3 : Etiologie", "ActeDiagnosticEtiologie", "Liste pour item ActeDiagnosticEtiologie (Diagnostic de Niveau 3 : Etiologie)")
	Do ..AddObject(..#props, details, "Objet de la consultation", "ActeObjetConsultation", "Liste pour item ActeObjetConsultation (Objet de la consultation)")
	Do ..AddObject(..#props, details, "Modalité de l'acte", "ActeModaliteConsultation", "Liste pour item ActeModaliteConsultation (Modalité de l'acte (présentiel, téléconsultation))")
	Do ..AddObject(..#props, details, "Type du protocole de recherche", "ActeRechercheProtocole", "Liste pour item ActeRechercheProtocole (Type du protocole de recherche)")
	Do ..AddObject(..#props, details, "Protocole de visite", "ActeRechercheVisite", "Liste pour item ActeRechercheVisite (Protocole de visite (screening, inclusion, suivi))")
	Do ..AddObject(..#props, details, "Cause de la mission de recours", "ActeCmrrRecoursCause", "Liste pour item ActeCmrrRecoursCause (Cause de la mission de recours)")
	Do ..AddObject(..#props, details, "Effet indésirable grave", "ActeTpEffetIndesirable", "Liste pour item ActeTpEffetIndesirable (Effet indésirable grave au(x) traitement(s) pharmacologique(s))")
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.ListesD</DataLocation>
<DefaultData>ListesDefaultData</DefaultData>
<IdLocation>^Bna.ListesD</IdLocation>
<IndexLocation>^Bna.ListesI</IndexLocation>
<StreamLocation>^Bna.ListesS</StreamLocation>
<ExtentSize>39</ExtentSize>
<Data name="ListesDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ListeNom</Value>
</Value>
<Value name="3">
<Value>ListeNomCourt</Value>
</Value>
<Value name="4">
<Value>ListeTip</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>2</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,16,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000"),$lb(21,21,21,21,21,21,21,21,21,21,21,21,21,21,21),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320))</Histogram>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb("1","3","6","9","12","15","18","21","24","27","29","31","33","35","37","39"),$lb(0,0,0,0,1,1,0,1,1,1,0,1,1,1,1),$lb(822083584,822083584,855638016,855638016,905969664,905969664,956301312,956301312,825360384,838860800,889192448,889192448,939524096,825753600,842072064,822083584,872415232,872415232,922746880,922746880,956301312,842596352,858849280,822083584,855638016,855638016,889192448,889192448,922746880,922746880,956301312,859373568))</Histogram>
</Property>
<Property name="ListeNom">
<Selectivity>1</Selectivity>
<AverageFieldSize>24.03</AverageFieldSize>
</Property>
<Property name="ListeNomCourt">
<Selectivity>1</Selectivity>
<AverageFieldSize>21.51</AverageFieldSize>
</Property>
<Property name="ListeTip">
<Selectivity>2.5641%</Selectivity>
<AverageFieldSize>72.44</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" LISTE POUR ITEM ACTEANCIENDIAGNOSTICSTADE (DIAGNOSTIC DE NIVEAU 1 : ETAT DÉMENCE (ANCIEN SYSTÈME DE DIAGNOSTICS))"," LISTE POUR ITEM ACTECMRRRECOURSCAUSE (CAUSE DE LA MISSION DE RECOURS)"," LISTE POUR ITEM ACTEDIAGNOSTICSYNDROME (DIAGNOSTIC DE NIVEAU 2 : SYNDROME)"," LISTE POUR ITEM ACTERECHERCHEPROTOCOLE (TYPE DU PROTOCOLE DE RECHERCHE)"," LISTE POUR ITEM ACTETYPECONSULTATION (TYPE D'ACTE)"," LISTE POUR ITEM CENTRECLCOLLABCMCMRR (COLLABORATION AVEC UNE CM OU UN CMRR)"," LISTE POUR ITEM CENTRECMRRCMACTIVITESOUTIEN (IL EXISTE UNE ACTIVITÉ DE SOUTIEN AUX AIDANTS POUR LE CENTRE)"," LISTE POUR ITEM CENTREHDJ (LE CENTRE COMPORTE UN HÔPITAL DE JOUR)"," LISTE POUR ITEM CENTREMULTISITE (LE CENTRE DISPOSE DE PLUSIEURS SITES)"," LISTE POUR ITEM CENTRETYPE (TYPE DU CENTRE)"," LISTE POUR ITEM PATIENTALD (AFFECTION DE LONGUE DURÉE)"," LISTE POUR ITEM PATIENTENVOYEPAR (TYPE DE PRESCRIPTEUR)"," LISTE POUR ITEM PATIENTLANGUEMATERNELLE (LANGUE MATERNELLE)"," LISTE POUR ITEM PATIENTMODEDEVIE (MODE DE VIE)"," LISTE POUR ITEM PATIENTPROFESSION (PROFESSION)"," LISTE POUR ITEM PATIENTSOUTIENPSYACCOMPAGNANT (SOUTIEN PSYCHOLOGIQUE POUR L'ACCOMPAGNANT)"),$lb(21,21,21,21,17,24,23,23,23,17,24,24,24,24,24),$lb(541870419,1095648073,1129140818,1129140818,1145651527,1145651527,1380270920,1380270920,1415139397,1094931525,1128615508,1279479628,1297240643,1129140818,1212434976,1212434976,1297435732,1297435732,1415139397,1128615508,1346458697,1095517216,1162761807,1162761807,1279348295,1279348295,1297040453,1297040453,1347571526,1347571526,1397708116,541870419))</Histogram>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="ListeNomCourtIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="ListeNomIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Bna.ListesItems">
<Super>%Persistent,Bna.Utils</Super>
<TimeChanged>66476,39238.00085421</TimeChanged>
<TimeCreated>66456,61273.810429</TimeCreated>

<Property name="Liste">
<Description>
Liste</Description>
<Type>Bna.Listes</Type>
<Cardinality>one</Cardinality>
<Inverse>Items</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="ListeIndex">
<Properties>Liste</Properties>
</Index>

<Property name="ItemParent">
<Description>
Parent (pour les arborescences d'ites)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>ItemEnfants</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ItemParentIndex">
<Properties>ItemParent</Properties>
</Index>

<Property name="ItemNom">
<Description>
Nom de l'item (sera affiché dans les listes du front</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Index name="ItemNomIndex">
<Properties>Liste,ItemNom</Properties>
</Index>

<Property name="ItemNomCourt">
<Description>
Nom court de l'item (pour récupération des codages BNA v1</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="ItemNomCourtIndex">
<Properties>Liste,ItemNomCourt</Properties>
</Index>

<Property name="ItemTip">
<Description>
Texte d'aide affiché lors de la saisie</Description>
<Type>%Text</Type>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="ItemOrdre">
<Description>
Ordre de l'item dans sa liste</Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<Property name="ItemEnfants">
<Description>
----------------------------------------------------------------------------------------------
Propriétés inverses
----------------------------------------------------------------------------------------------</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>many</Cardinality>
<Inverse>ItemParent</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresDepartement">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreDepartement</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresRegion">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreRegion</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresType">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreType</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresLabel">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreLabel</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresReseau">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreReseau</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresInclusion">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreInclusion</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresMultisite">
<Type>Bna.Centres</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreMultisite</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsLabel">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreLabel</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsReseau">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreReseau</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsInclusion">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreInclusion</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsMultisite">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreMultisite</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsHdj">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreHdj</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsActiviteSoutien">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreCmrrCmActiviteSoutien</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsActivitéStimulation">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreCmrrCmActiviteStimul</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsTypeSpecialiste">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreClTypeSpecialiste</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentreAnnuelsCollabNeuroPsy">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreClCollabNeuroPsy</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsActiviteConsultMemoire">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreClActiviteConsultMemoire</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsCollabCmCmrr">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreClCollabCmCmrr</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="CentresAnnuelsActivieReseau">
<Type>Bna.CentresAnnuels</Type>
<Cardinality>many</Cardinality>
<Inverse>CentreClActiviteReseau</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivatePatientSexe">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientSexe</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateAccompagnant">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientAccompagnant</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateSoutienPsyAccompagnant">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientSoutienPsyAccompagnant</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateNiveauEtudes">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientNiveauEtudes</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateLangueMaternelle">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientLangueMaternelle</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateProfession">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientProfession</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateEnvoyePar">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientEnvoyePar</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateSituationGeographique">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientSituationGeographique</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateMode">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientModeDeVie</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateMesureProtection">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientMesureProtection</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateApa">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientApa</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateAld">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientAld</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="PatientsPrivateFinSuivi">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>PatientFinSuivi</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TraitementsActesPrecripteur">
<Type>Bna.TraitementsActes</Type>
<Cardinality>many</Cardinality>
<Inverse>TratementActePrescripteur</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesTypeConsultation">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeTypeConsultation</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesDiagnosticStade">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeDiagnosticStade</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesDiagnosticSyndrome">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeDiagnosticSyndrome</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesDiagnosticEtiologie1">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeDiagnosticEtiologie1</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesDiagnosticEtiologie2">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeDiagnosticEtiologie2</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesDiagnosticEtiologie3">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeDiagnosticEtiologie3</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActeObjetConsultation">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeObjetConsultation</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesModaliteConsultation">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeModaliteConsultation</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesCmrrRecoursCause">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeCmrrRecoursCause</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesRechercheProtocole">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeRechercheProtocole</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesRechercheVisite">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeRechercheVisiste</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesTpEffetIndesirable">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActeTpEffetIndesirable</Inverse>
<Relationship>1</Relationship>
</Property>

<Parameter name="props">
<Description>
----------------------------------------------------------------------------------------------
Initialisations (méthode pour toutes les listes)
----------------------------------------------------------------------------------------------</Description>
<Default>Liste,ItemNom,ItemNomCourt,ItemTip,ItemOrdre</Default>
</Parameter>

<Parameter name="propsWithParent">
<Default>Liste,ItemParent,ItemNom,ItemNomCourt,ItemTip,ItemOrdre</Default>
</Parameter>

<Method name="Init">
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "Initialisation des items des listes", !
	/// Vidage de la table
	&sql(update Bna.ListesItems set ItemParent=null)
	&sql(truncate table Bna.ListesItems)
	
	Do ..InitCentreRegion(details)
	Do ..InitCentreDepartement(details)
	Do ..InitCentreType(details)
	Do ..InitCentreLabel(details)
	Do ..InitCentreReseau(details)
	Do ..InitCentreInclusion(details)
	Do ..InitCentreMultisite(details)
	Do ..InitCentreHdj(details)
	Do ..InitCentreCmrrCmActiviteSoutien(details)
	DO ..InitCentreCmrrCmActiviteStimul(details)
	Do ..InitCentreClTypeSpecialiste(details)
	Do ..InitCentreClCollabNeuroPsy(details)
	Do ..InitCentreClActiviteConsultMemoire(details)
	Do ..InitCentreClCollabCmCmrr(details)
	Do ..InitCentreClActiviteReseau(details)
	
	Do ..InitPatientAccompagnant(details)
	Do ..InitPatientNiveauEtudes(details)
	Do ..InitPatientLangueMaternelle(details)
	Do ..InitPatientProfession(details)
	Do ..InitPatientEnvoyePar(details)
	Do ..InitPatientSituationGeographique(details)
	Do ..InitPatientModeDeVie(details)
	Do ..InitPatientMesureProtection(details)
	Do ..InitPatientApa(details)
	Do ..InitPatientAld(details)
	Do ..InitPatientFinSuivi(details)
	Do ..InitPatientSoutienPsyAccompagnant(details)

	Do ..InitActeTypeConsultation(details)
	Do ..InitActeAncienDiagnosticStade(details)
	Do ..InitActeDiagnosticStade(details)
	Do ..InitActeAncienDiagnosticSyndrome(details)
	Do ..InitActeDiagnosticSyndrome(details)
	Do ..InitActeDiagnosticEtiologie(details)
	Do ..InitActeObjetConsultation(details)
	Do ..InitActeModaliteConsultation(details)
	Do ..InitActeRechercheProtocole(details)
	Do ..InitActeRechercheVisite(details)
	Do ..InitActeCmrrRecoursCause(details)
	Do ..InitActeTpEffetIndesirable(details)
]]></Implementation>
</Method>

<Method name="InitCentreRegion">
<Description>
Liste des régions</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  CentreRegion", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreRegion')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Auvergne-Rhône-Alpes", "auvergne-rhone-alpes", "Région Auvergne-Rhône-Alpes (01, 03, 07, 15, 26, 38, 42, 43, 63, 69, 73, 74)", 0)
	Do ..AddObject(..#props, details, liste, "Bourgogne-Franche-Comté", "bourgogne-franche-comte", "Région Bourgogne-France-Comté (21, 25, 39, 58, 70, 71, 89, 90 )", 0)
	Do ..AddObject(..#props, details, liste, "Bretagne", "bretagne", "Région Bretagne (22, 29, 35, 56)", 0)
	Do ..AddObject(..#props, details, liste, "Centre-Val de Loire", "centre-val-de-loire", "Région Centre-Val de Loire (18, 28, 36, 37, 41, 45)", 0)
	Do ..AddObject(..#props, details, liste, "Corse", "corse", "Région Corse (2A, 2B)", 0)
	Do ..AddObject(..#props, details, liste, "Grand Est", "grand-est", "Région Grand Est (08, 10, 51, 52, 54, 55, 57, 67, 68, 88)", 0)
	Do ..AddObject(..#props, details, liste, "Hauts-de-France", "hauts-de-france", "Région Hauts-de-France (02, 59, 60, 62, 80)", 0)
	Do ..AddObject(..#props, details, liste, "Île-de-France", "ile-de-france", "Région Île-de-France (75, 77, 78, 91, 92, 93, 94, 95)", 0)
	Do ..AddObject(..#props, details, liste, "Normandie", "normandie", "Région Normandie (14, 27, 50, 61, 76)", 0)
	Do ..AddObject(..#props, details, liste, "Nouvelle-Aquitaine", "nouvelle-aquitaine", "Région Nouvelle-Aquitaine (16, 17, 19, 23, 24, 33, 40, 47, 64, 79, 86, 87)", 0)
	Do ..AddObject(..#props, details, liste, "Occitanie", "occitanie", "Région Occitanie (09, 11, 12, 30, 31, 32, 34, 46, 48, 65, 66, 81, 82)", 0)
	Do ..AddObject(..#props, details, liste, "Pays de la Loire", "pays-de-la-loire", "Région Pays de la Loire (44, 49, 53, 72, 85)", 0)
	Do ..AddObject(..#props, details, liste, "Provence-Alpes-Côte d'Azur", "provence-alpes-côte-d-azur", "Région Provence-Alpes-Côte d'Azur (04, 05, 06, 13, 83, 84)", 0)

	Do ..AddObject(..#props, details, liste, "Guadeloupe", "guadeloupe", "Région Guadeloupe (971)", 0)
	Do ..AddObject(..#props, details, liste, "Martinique", "martinique", "Région Martinique (972)", 0)
	Do ..AddObject(..#props, details, liste, "Guyane", "guyane", "Région Guyane (973)", 0)
	Do ..AddObject(..#props, details, liste, "La Réunion", "la-reunion", "Région La réunion: (974)", 0)
	Do ..AddObject(..#props, details, liste, "Mayotte", "mayotte", "Région Mayotte : (976)", 0)
	Do ..AddObject(..#props, details, liste, "Territoires Outre-Mer", "territoires-outre-mer", "Région Autres Outre-Mer : (975, 986, 987, 988 )", 0)
]]></Implementation>
</Method>

<Method name="InitCentreDepartement">
<Description>
Liste des départements</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	///--------------------------------------------------------------
    ///--------------------------------------------------------------
	w "  Départements", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreDepartement')
    Set liste=##class(Bna.Listes).%OpenId(listeId)
	
	/// Région Auvergne-Rhone-Alpes
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='auvergne-rhone-alpes')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "01-Ain", "01", "Département de l'Ain", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "03-Allier", "03", "Département de l'Allier", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "07-Ardèche", "07", "Département de l'Ardèche", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "15-Cantal", "15", "Département du Cantal", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "26-Drôme", "26", "Département de la Drôme", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "38-Isère", "38", "Département de l'Isère", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "42-Loire", "42", "Département de la Loire", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "43-Haute-Loire", "43", "Département de la Haute-Loire", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "63-Puy-de-Dôme", "63", "Département du Puy-de-Dôme ", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "69-Rhone", "69", "Département du Rhone", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "73-Savoie", "73", "Département de la Savoie", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "74-Haute-Savoie", "74", "Département de la Haute-Savoie", 0 )

	/// Région Bourgogne-Franche-Comté
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='bourgogne-franche-comte')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "21-Côte-d'Or", "21", "Département de la Côte-d'Or", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "25-Doubs", "25", "Département du Doubs", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "39-Jura", "39", "Département du Jura", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "58-Nièvre", "58", "Département de la Nièvre", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "70-Haute-Saône", "70", "Département de la Haute-Saône", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "71-Saône-et-Loire", "71", "Département de la Saône-et-Loire", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "89-Yonne", "89", "Département de l'Yonne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "90-Territoire de Belfort", "90", "Département du Territoire de Belfort", 0 )

	/// Région Bretagne
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='bretagne')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "22-Côtes-d'Armor", "22", "Département des Côtes-d'Armor", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "29-Finistère", "29", "Département du Finistère", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "35-Ille-et-Vilaine", "35", "Département de l'Ille-et-Vilaine", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "56-Morbihan", "56", "Département du Morbihan", 0 )

	/// Région Centre-Val de Loire
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='centre-val-de-loire')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "18-Cher", "18", "Département du Cher", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "28-Eure-et-Loir", "28", "Département de l'Eure-et-Loir", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "36-Indre", "36", "Département de l'Indre", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "37-Indre-et-Loire", "37", "Département de l'Indre-et-Loire", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "41-Loir-et-Cher", "41", "Département du Loir-et-Cher", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "45-Loiret", "45", "Département du Loiret", 0 )

	/// Région Corse
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='corse')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "2A-Corse-du-Sud", "2A", "Département de la Corse-du-Sud", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "2B-Corse-du-Nord", "2B", "Département de la Corse-du-Nord", 0 )
	
	/// Région Grand Est
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='grand-est')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "08-Ardennes", "08", "Département des Ardennes", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "10-Aube", "10", "Département de l'Aube", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "51-Marne", "51", "Département de la Marne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "52-Haute-Marne", "52", "Département de la Haute-Marne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "54-Meurthe-et-Moselle", "54", "Département de la Meurthe-et-Moselle", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "55-Meuse", "55", "Département de la Meuse", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "57-Moselle", "57", "Département de la Moselle", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "67-Bas-Rhin", "67", "Département du Bas-Rhin", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "68-Haut-Rhin", "68", "Département du Haut-Rhin", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "88-Vosges", "88", "Département des Vosges", 0 )

	/// Région Hauts-de-France
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='hauts-de-france')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "02-Aisne", "02", "Département de l'Aisne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "59-Nord", "59", "Département du Nord", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "60-Oise", "60", "Département de l'Oise", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "62-Pas-de-Calais", "62", "Département du Pas-de-Calais", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "80-Somme", "80", "Département de la Somme", 0 )

	/// Région Île-de-France
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='ile-de-france')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "75-Paris", "75", "Département de Paris", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "77-Seine-et-Marne", "77", "Département de la Seine-et-Marne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "78-Yvelines", "78", "Département des Yvelines", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "91-Essonne", "91", "Département de l'Essonne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "92-Hauts-de-Seine", "92", "Département des Hauts-de-Seine", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "93-Seine-Saint-Denis", "93", "Département de la Seine-Saint-Denis", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "94-Val-de-Marne", "94", "Département du Val-de-Marne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "95-Val-d'Oise", "95", "Département du Val-d'Oise", 0 )

	/// Région Normandie
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='normandie')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "14-Calvados", "14", "Département du Calvados", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "27-Eure", "27", "Département de l'Eure", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "50-Manche", "50", "Département de la Manche", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "61-Orne", "61", "Département de l'Orne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "76-Seine-Maritime", "76", "Département de la Seine-Maritime", 0 )

	/// Région Nouvelle-Aquitaine
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='nouvelle-aquitaine')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "16-Charente", "16", "Département de la Charente", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "17-Charente-Maritime", "17", "Département de la Charente-Maritime", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "19-Corrèze", "19", "Département de la Corrèze", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "23-Creuse", "23", "Département de la Creuse", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "24-Dordogne", "24", "Département de la Dordogne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "33-Gironde", "33", "Département de la Gironde", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "40-Landes", "40", "Département des Landes", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "47-Lot-et-Garonne", "47", "Département du Lot-et-Garonne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "64-Pyrénées-Atlantiques", "64", "Département des Pyrénées-Atlantiques", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "79-Deux-Sèvres", "79", "Département des Deux-Sèvres", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "86-Vienne", "86", "Département de la Vienne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "87-Haute-Vienne", "87", "Département de la Haute-Vienne", 0 )

	/// Région Occitanie
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='occitanie')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "09-Ariège", "09", "Département de l'Ariège", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "11-Aude", "11", "Département de l'Aude", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "12-Aveyron", "12", "Département de l'Aveyron", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "30-Gard", "30", "Département du Gard", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "31-Haute-Garonne", "31", "Département de la Haute-Garonne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "32-Gers", "32", "Département du Gers", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "34-Hérault", "34", "Département de l'Hérault", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "46-Lot", "46", "Département du Lot", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "48-Lozère", "48", "Département de la Lozère", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "65-Hautes-Pyrénées", "65", "Département des Hautes-Pyrénées", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "66-Pyrénées-Orientales", "66", "Département des Pyrénées-Orientales", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "81-Tarn", "81", "Département du Tarn", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "82-Tarn-et-Garonne", "82", "Département du Tarn-et-Garonne", 0 )

	/// Région Pays de la Loire
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='pays-de-la-loire')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "44-Loire-Atlantique", "44", "Département de la Loire-Atlantique", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "49-Maine-et-Loire", "49", "Département du Maine-et-Loire", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "53-Mayenne", "53", "Département de la Mayenne", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "72-Sarthe", "72", "Département de la Sarthe", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "85-Vendée", "85", "Département de la Vendée", 0 )

	/// Région Provence-Alpes-Côte d'Azur
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='provence-alpes-côte-d-azur')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "04-Alpes-de-Haute-Provence", "04", "Département des Alpes-de-Haute-Provence", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "05-Hautes-Alpes", "05", "Département des Hautes-Alpes", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "06-Alpes-Maritimes", "06", "Département des Alpes-Maritimes", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "13-Bouche-du-Rhône", "13", "Département des Bouche-du-Rhône", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "83-Var", "83", "Département du Var", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "84-Vaucluse", "84", "Département du Vaucluse", 0 )

	/// Région Guadeloupe
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='guadeloupe')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "Guadeloupe", "971", "Département de la Guadeloupe", 0 )

	/// Région Martinique
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='martinique')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "Martinique", "972", "Département de la Martinique", 0 )

	/// Région Guyane
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='guyane')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "Guyane", "973", "Département de la Guyane", 0 )

	/// Région La Réunion
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='la-reunion')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "La Réunion", "974", "Département de la Réunion", 0 )

	/// Région Mayotte
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='mayotte')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "Mayotte", "973", "Département de Mayotte", 0 )

	/// Région Territoires Outre-Mer
    &sql(select ID, ItemNom into :regionId, :regionNom from Bna.ListesItems where ItemNomCourt='territoires-outre-mer')
    Set region=##class(Bna.ListesItems).%OpenId(regionId)
	if (details) w "    Pour ",regionNom,!

	Do ..AddObject(..#propsWithParent, details, liste, region, "975-Saint-Pierre-et-Miquelon", "975", "Territoire de Saint-Pierre-et-Miquelon", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "986-Wallis-et-Futuna", "986", "Territoire de Wallis-et-Futuna", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "987-Polynésie Française", "987", "Territoire de Polynésie Française", 0 )
	Do ..AddObject(..#propsWithParent, details, liste, region, "988-Nouvelle-Calédonie", "988", "Territoire de Nouvelle-Calédonie", 0 )
]]></Implementation>
</Method>

<Method name="InitCentreType">
<Description>
Liste des types de centre</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Types de centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreType')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Centre Mémoire de Ressources et Recherche", "CMRR", "Centre Mémoire de Ressources et Recherche", 10)
	Do ..AddObject(..#props, details, liste, "Centre Mémoire", "CM", "Centre Mémoire", 20)
	Do ..AddObject(..#props, details, liste, "Unité Cognitivo-Comportementale", "UCC", "Unité Cognitivo-Comportementale", 30)
	Do ..AddObject(..#props, details, liste, "Cabinet Libéral", "CL", "Cabinet Libéral", 40)
]]></Implementation>
</Method>

<Method name="InitCentreLabel">
<Description>
Liste pour item CentreLabel</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Label pour centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreLabel')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Centre Non Labelisé", "N", "Centre Non Labelisé", 10)
	Do ..AddObject(..#props, details, liste, "Centre Labelisé", "O", "Centre Labelisé", 20)
]]></Implementation>
</Method>

<Method name="InitCentreReseau">
<Description>
Liste pour item CentreReseau</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Reseau pour centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreReseau')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Centre n'appartenant pas à un Réseau", "N", "Centre n'appartenant pas à un Réseau", 10)
	Do ..AddObject(..#props, details, liste, "Centre appartenant à un Réseau", "O", "Centre appartenant à un Réseau", 20)
]]></Implementation>
</Method>

<Method name="InitCentreInclusion">
<Description>
Liste pour item CentreInclusion</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Inclusion pour centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreInclusion')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Centre Inclus dans un CHU", "CHU", "Centre Inclus dans un CHU", 10)
	Do ..AddObject(..#props, details, liste, "Centre Inclus dans un CH", "CH", "Centre Inclus dans un CH", 20)
	Do ..AddObject(..#props, details, liste, "Centre Inclus dans un CHS", "CHS", "Centre Inclus dans un CHS", 30)
	Do ..AddObject(..#props, details, liste, "Centre Inclus dans un Hôpital Local", "HL", "Centre Inclus dans un Hôpital Local", 40)
	Do ..AddObject(..#props, details, liste, "Centre Inclus dans un PSPH", "PSPH", "Centre Inclus dans un PSPH", 50)
	Do ..AddObject(..#props, details, liste, "Centre Inclus dans une Structure Privée", "PRIV", "Centre Inclus dans une Structure Privée", 60)
]]></Implementation>
</Method>

<Method name="InitCentreMultisite">
<Description>
Liste pour item CentreMultisite</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Inclusion pour centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreMultisite')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Centre Mono-site", "N", "Centre Mono-site", 10)
	Do ..AddObject(..#props, details, liste, "Centre Multi-sites", "O", "Centre Multi-sites", 20)
]]></Implementation>
</Method>

<Method name="InitCentreHdj">
<Description>
Liste pour item CentreHdj</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Hôpital de jour pour centre", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreHdj')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Pas d'HDJ", "1", "Pas d'HDJ", 10)
	Do ..AddObject(..#props, details, liste, "HDJ dans l'établissement", "2", "HDJ dans l'établissement", 20)
	Do ..AddObject(..#props, details, liste, "HDJ dans un autre établissement", "3", "HDJ dans un autre établissement", 30)
]]></Implementation>
</Method>

<Method name="InitCentreCmrrCmActiviteSoutien">
<Description>
Liste pour item CentreCmrrCmActiviteSoutien</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Activité de soutien pour centre (CMRR et CM)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreCmrrCmActiviteSoutien')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Pas d'activité de soutien", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Activité de soutien", 20)
]]></Implementation>
</Method>

<Method name="InitCentreCmrrCmActiviteStimul">
<Description>
Liste pour item CentreCmrrCmActiviteStimul</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Activité de stimulation pour centre (CMRR et CM)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreCmrrCmActiviteStimul')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Pas d'activité de stimulation", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Activité de stimulation", 20)
]]></Implementation>
</Method>

<Method name="InitCentreClTypeSpecialiste">
<Description>
Liste pour item CentreClTypeSpecialiste</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Type de spécialiste pour centre (CL)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreClTypeSpecialiste')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Cabinet Isolé", "ISOLE", "Cabinet Isolé", 10)
	Do ..AddObject(..#props, details, liste, "Cabinet dans un Groupe", "GROUPE", "Cabinet dans un Groupe", 20)
	Do ..AddObject(..#props, details, liste, "Cabinet dans un Établissement", "ETAB", "Cabinet dans un Établissement", 30)
]]></Implementation>
</Method>

<Method name="InitCentreClCollabNeuroPsy">
<Description>
Liste pour item CentreClCollabNeuroPsy</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Collaboration avec neuro-psychiatre pour centre (CL)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreClCollabNeuroPsy')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
]]></Implementation>
</Method>

<Method name="InitCentreClActiviteConsultMemoire">
<Description>
Liste pour item CentreClActiviteConsultMemoire</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Activité clinique au sein d'une consultation mémoire pour centre (CL)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreClActiviteConsultMemoire')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
]]></Implementation>
</Method>

<Method name="InitCentreClCollabCmCmrr">
<Description>
Liste pour item CentreClCollabCmCmrr</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Collaboration avec un CM ou un CMRR pour centre (CL)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreClCollabCmCmrr')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
]]></Implementation>
</Method>

<Method name="InitCentreClActiviteReseau">
<Description>
Liste pour item CentreClActiviteReseau</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Activité dans un réseau pour centre (CL)", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='CentreClActiviteReseau')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
]]></Implementation>
</Method>

<Method name="InitPatientAccompagnant">
<Description>
Liste pour item PatientAccompagnant</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Accompagnant pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientAccompagnant')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Sans Informations", "SI", "Sans Informations", 10)
	Do ..AddObject(..#props, details, liste, "Aucun", "AUCUN", "Aucun", 20)
	Do ..AddObject(..#props, details, liste, "Conjoint", "CONJOINT", "Conjoint", 30)
	Do ..AddObject(..#props, details, liste, "Enfant", "ENFANT", "Enfant", 40)
	Do ..AddObject(..#props, details, liste, "Bel enfant", "BELENFANT", "Bel enfant", 50)
	Do ..AddObject(..#props, details, liste, "Petit enfant", "PTENFANT", "Petit enfant", 60)
	Do ..AddObject(..#props, details, liste, "Neveu ou nièce", "NEVEU", "Neveu ou nièce", 70)
	Do ..AddObject(..#props, details, liste, "Frère ou soeur", "FRERE", "Frère ou soeur", 80)
	Do ..AddObject(..#props, details, liste, "Curateur", "CURATEUR", "Curateur", 90)
	Do ..AddObject(..#props, details, liste, "Autre", "AUTRES", "Autre", 100)
]]></Implementation>
</Method>

<Method name="InitPatientNiveauEtudes">
<Description>
Liste pour item PatientNiveauEtudes</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Niveau d'études pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientNiveauEtudes')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non connu", "NR", "Non connu", 10)
	Do ..AddObject(..#props, details, liste, "Aucune Scolarisation", "AUCUNE", "Aucune Scolarisation", 20)
	Do ..AddObject(..#props, details, liste, "Etudes Primaires (certificat d'études)", "PRI", "Etudes Primaires (certificat d'études)", 30)
	Do ..AddObject(..#props, details, liste, "Secondaire (Collège, CAP, Brevet)", "SEC1", "Secondaire (Collège, CAP, Brevet)", 40)
	Do ..AddObject(..#props, details, liste, "Secondaire (Lycée, BAC, BEP)", "SEC2", "Secondaire (Lycée, BAC, BEP)", 50)
	Do ..AddObject(..#props, details, liste, "Supérieur", "SUP", "Supérieur", 60)
]]></Implementation>
</Method>

<Method name="InitPatientLangueMaternelle">
<Description>
Liste pour item PatientLangueMaternelle</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Langue Maternelle pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientLangueMaternelle')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Français", "FRANCAIS", "Français", 10)
	Do ..AddObject(..#props, details, liste, "Allemand", "ALLEMAND", "Allemand", 20)
	Do ..AddObject(..#props, details, liste, "Anglais", "ANGLAIS", "Anglais", 30)
	Do ..AddObject(..#props, details, liste, "Arabe", "ARABE", "Arabe", 40)
	Do ..AddObject(..#props, details, liste, "Espagnol", "ESPAGNOL", "Espagnol", 50)
	Do ..AddObject(..#props, details, liste, "Grec", "GREC", "Grec", 60)
	Do ..AddObject(..#props, details, liste, "Italien", "ITALIEN", "Italien", 70)
	Do ..AddObject(..#props, details, liste, "Neerlandais", "NEERLANDAIS", "Neerlandais", 80)
]]></Implementation>
</Method>

<Method name="InitPatientProfession">
<Description>
Liste pour item PatientProfession</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Profession pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientProfession')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Sans Informations", "SI", "Sans Informations", 10)
	Do ..AddObject(..#props, details, liste, "Agriculteur", "AGRI", "Agriculteur", 20)
	Do ..AddObject(..#props, details, liste, "Artisan", "ARTISAN", "Artisan", 30)
	Do ..AddObject(..#props, details, liste, "Cadres et prof. intellectuelles supérieures", "CADRE", "Cadres et prof. intellectuelles supérieures", 40)
	Do ..AddObject(..#props, details, liste, "Commerçant ou chef d'entreprise", "COMMERCANT", "Commerçant ou chef d'entreprise", 50)
	Do ..AddObject(..#props, details, liste, "Employé", "EMPLOYE", "Employé", 60)
	Do ..AddObject(..#props, details, liste, "Femmes au foyer", "FOYER", "Femmes au foyer", 70)
	Do ..AddObject(..#props, details, liste, "Ouvrier", "OUVRIER", "Ouvrier", 80)
	Do ..AddObject(..#props, details, liste, "Professions intermédiaires", "INTER", "Professions intermédiaires", 90)
	Do ..AddObject(..#props, details, liste, "Autres", "AUTRES", "Autres", 100)
]]></Implementation>
</Method>

<Method name="InitPatientEnvoyePar">
<Description>
Liste pour item PatientEnvoyePar</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Envoyé par pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientEnvoyePar')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Clic", "CLIC", "Clic", 10)
	Do ..AddObject(..#props, details, liste, "Centre Mémoire", "CM", "Centre Mémoire", 20)
	Do ..AddObject(..#props, details, liste, "Centre Mémoire de Ressources et Recherche", "CMRR", "Centre Mémoire de Ressources et Recherche", 30)
	Do ..AddObject(..#props, details, liste, "MAIA, PTA, ...", "MAIA", "DIspositif d'appui à la coordination des parcours de santé (MAIA, PTA, Autres)", 40)
	Do ..AddObject(..#props, details, liste, "Direct", "DIRECT", "Direct", 50)
	Do ..AddObject(..#props, details, liste, "EHPAD", "MR", "EHPAD - Maison de retraite", 60)
	Do ..AddObject(..#props, details, liste, "Garde Malade", "GM", "Garde Malade", 70)
	Do ..AddObject(..#props, details, liste, "Gériatre", "GER", "Gériatre", 80)
	Do ..AddObject(..#props, details, liste, "Medecin généraliste", "MEDGEN", "Medecin généraliste", 90)
	Do ..AddObject(..#props, details, liste, "Neurologue", "NEURO", "Neurologue", 100)
	Do ..AddObject(..#props, details, liste, "Psychiatre", "PSY", "Psychiatre", 110)
	Do ..AddObject(..#props, details, liste, "Service d'hospitalisation", "HOSPI", "Service d'hospitalisation (dont USLD)", 120)
	Do ..AddObject(..#props, details, liste, "Services Sociaux", "SS", "Services Sociaux (caisse de retraite, CCAS)", 130)
	Do ..AddObject(..#props, details, liste, "Urgences médicales", "URG", "Urgences médicales", 140)
	Do ..AddObject(..#props, details, liste, "Autre Spécialiste", "SPE", "Autre Spécialiste", 150)
]]></Implementation>
</Method>

<Method name="InitPatientSituationGeographique">
<Description>
Liste pour item PatientSituationGeographique</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Situation géographique pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientSituationGeographique')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Dans la ville du CMRR ou CM", "VILLE", "Dans la ville du CMRR ou CM (à moins de 50km)", 10)
	Do ..AddObject(..#props, details, liste, "A plus de 50km du CMRR ou CM", "+50", "A plus de 50km du CMRR ou CM", 20)
	Do ..AddObject(..#props, details, liste, "Dans une autre région", "EXTREG", "Dans une autre région", 30)
	Do ..AddObject(..#props, details, liste, "Dans un autre pays", "EXTPAYS", "Dans un autre pays", 40)
]]></Implementation>
</Method>

<Method name="InitPatientModeDeVie">
<Description>
Liste pour item PatientModeDeVie</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Mode de vie pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientModeDeVie')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "A domicile, avec conjoint", "DOMCONJ", "A domicile, avec conjoint", 10)
	Do ..AddObject(..#props, details, liste, "A domicile, dans sa famille", "DOMFAM", "A domicile, dans safamille", 20)
	Do ..AddObject(..#props, details, liste, "A domicile, sans autres indications", "DOMSAI", "A domicile, sans autres indications", 30)
	Do ..AddObject(..#props, details, liste, "A domicile, seul, avec famille à coté", "DOMSEULAFA", "A domicile, seul, avec famille à coté", 40)
	Do ..AddObject(..#props, details, liste, "A domicile, seul, sans famille à coté", "DOMSEULSFA", "A domicile, seul, sans famille à coté", 50)
	Do ..AddObject(..#props, details, liste, "Dans une famille d'accueil", "FAMACC", "Dans une famille d'accueil", 60)
	Do ..AddObject(..#props, details, liste, "En EHPAD", "EHPAD", "En EHPAD", 70)
	Do ..AddObject(..#props, details, liste, "En USLD", "USLD", "En USLD", 80)
	Do ..AddObject(..#props, details, liste, "En Hospitalisation (court séjour, SSR)", "HOSPI", "En Hospitalisation (court séjour, SSR)", 90)
	Do ..AddObject(..#props, details, liste, "En hospitalisation (établissement psychiatrique)", "HPSY", "En hospitalisation (établissement psychiatrique)", 100)
	Do ..AddObject(..#props, details, liste, "Résidence autonomie", "RESAUTO", "Résidence autonomie", 110)
	Do ..AddObject(..#props, details, liste, "Autre", "AUTRE", "Autre", 120)
]]></Implementation>
</Method>

<Method name="InitPatientMesureProtection">
<Description>
Liste pour item PatientMesureProtection</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Mesure de protection pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientMesureProtection')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Curatelle", "CURATELLE", "Curatelle", 10)
	Do ..AddObject(..#props, details, liste, "Tutelle", "TUTELLE", "Tutelle", 20)
	Do ..AddObject(..#props, details, liste, "Sans Information", "SI", "Sans Information", 30)
	Do ..AddObject(..#props, details, liste, "Aucune", "AUCUNE", "Aucune", 40)
]]></Implementation>
</Method>

<Method name="InitPatientApa">
<Description>
Liste pour item PatientApa</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Allocation Personnalisée d'Autonomie pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientApa')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 10)
	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 20)
	Do ..AddObject(..#props, details, liste, "Sans Information", "SI", "Sans Information", 30)
]]></Implementation>
</Method>

<Method name="InitPatientAld">
<Description>
Liste pour item PatientAld</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Affection de Longue Durée pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientAld')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 10)
	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 20)
	Do ..AddObject(..#props, details, liste, "Sans Information", "SI", "Sans Information", 30)
]]></Implementation>
</Method>

<Method name="InitPatientFinSuivi">
<Description>
Liste pour item PatientFinSuivi</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Fin de suivi pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientFinSuivi')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Suivi en cours", "ENCOURS", "Suivi en cours", 10)
	Do ..AddObject(..#props, details, liste, "Choix du patient", "CHOIX", "Choix du patient", 20)
	Do ..AddObject(..#props, details, liste, "Décès", "DECES", "Décès", 30)
	Do ..AddObject(..#props, details, liste, "Déménagement", "DEM", "Déménagement", 40)
	Do ..AddObject(..#props, details, liste, "Entrée en institution", "INSTIT", "Entrée en institution", 50)
	Do ..AddObject(..#props, details, liste, "Suivi par médecin traitant", "MED", "Suivi par médecin traitant", 60)
	Do ..AddObject(..#props, details, liste, "Suivi par un autre centre", "CENTRE", "Suivi par un autre centre", 70)
	Do ..AddObject(..#props, details, liste, "Sans Information", "SI", "Sans Information", 80)
]]></Implementation>
</Method>

<Method name="InitPatientSoutienPsyAccompagnant">
<Description>
Liste pour item PatientSoutienPsyAccompagnant</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "  Soutien psychologique pour l'accompagnant pour patient", !
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='PatientSoutienPsyAccompagnant')
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
]]></Implementation>
</Method>

<Method name="InitActeTypeConsultation">
<Description>
Liste pour item ActeTypeConsultation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeTypeConsultation')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Consultation unique", "CONS", "Consultation unique", 10)
	Do ..AddObject(..#props, details, liste, "Consultation multidisciplinaire", "CONSMULTI", "Consultation multidisciplinaire", 20)
	Do ..AddObject(..#props, details, liste, "Consultation avec annonce diagnostic", "CONSANN", "Consultation avec annonce diagnostic", 30)
	Do ..AddObject(..#props, details, liste, "Intervention infirmière", "IINF", "Intervention infirmière", 40)
	Do ..AddObject(..#props, details, liste, "Intervention assistance sociale", "IASS", "Intervention assistance sociale", 50)
	Do ..AddObject(..#props, details, liste, "Intervention psychologue", "IPSY", "Intervention psychologue", 60)
	Do ..AddObject(..#props, details, liste, "Intervention orthophoniste", "IORTHO", "Intervention orthophoniste", 70)
	Do ..AddObject(..#props, details, liste, "Bilan neuropsychologique", "CONSBIL", "Bilan neuropsychologique", 80)
	Do ..AddObject(..#props, details, liste, "Bilan neuropsychologique demandé par libéral", "CONSBILLIB", "Bilan neuropsychologique demandé par spacialiste libéral de ville", 90)
	Do ..AddObject(..#props, details, liste, "Groupe de Patients", "GP", "Groupe de Patients", 100)
	Do ..AddObject(..#props, details, liste, "Groupe de Familles", "GF", "Groupe de Familles", 110)
	Do ..AddObject(..#props, details, liste, "Hôpital de jour - Bilan", "HDJ", "Hôpital de jour - Bilan", 120)
	Do ..AddObject(..#props, details, liste, "Hôpital de jour - SSR", "HDJSSR", "Hôpital de jour - SSR", 150)
]]></Implementation>
</Method>

<Method name="InitActeAncienDiagnosticStade">
<Description>
Liste pour item ActeAncienDiagnosticStade</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeAncienDiagnosticStade')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Dément", "DEMENT", "Dément", 10)
	Do ..AddObject(..#props, details, liste, "Troubles Cognitifs Sans Démence", "COGNITIF", "Troubles Cognitifs Sans Démence", 20)
	Do ..AddObject(..#props, details, liste, "Autres Cas", "AUTRE", "Autres Cas", 30)
	Do ..AddObject(..#props, details, liste, "Absence de troubles", "ABSTROU", "Absence de troubles", 40)
]]></Implementation>
</Method>

<Method name="InitActeDiagnosticStade">
<Description>
Liste pour item ActeDiagnosticStade</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeDiagnosticStade')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Trouble cognitif mineur (DSM V)", "TRCOGMIN", "Trouble cognitif mineur (DSM V)", 10)
	Do ..AddObject(..#props, details, liste, "Trouble cognitif majeur (DSM V)", "TRCOGMAJ", "Trouble cognitif majeur (DSM V)", 20)
	Do ..AddObject(..#props, details, liste, "Plainte cognitive isolée", "PLCOGISO", "Plainte cognitive isolée", 30)
	Do ..AddObject(..#props, details, liste, "Autre cas", "AUTTRMEN", "Autre cas", 40)
	Do ..AddObject(..#props, details, liste, "Non applicable", "NOAPPLIC", "Non applicable", 50)
]]></Implementation>
</Method>

<Method name="InitActeAncienDiagnosticSyndrome">
<Description>
Liste pour item ActeAncienDiagnosticSyndrome</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeAncienDiagnosticSyndrome')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Plainte mnésique", "R413", "Plainte mnésique", 10)
	Do ..AddObject(..#props, details, liste, "MCI amnésique", "F06.7A", "MCI amnésique", 20)
	Do ..AddObject(..#props, details, liste, "MCI autres", "F06.7B", "MCI autres", 30)
	Do ..AddObject(..#props, details, liste, "Maladie d'Alzheimer", "F00.1", "Maladie d'Alzheimer", 40)
	Do ..AddObject(..#props, details, liste, "Démence vasculaire", "F01.9", "Démence vasculaire", 50)
	Do ..AddObject(..#props, details, liste, "Autre démence vasculaire", "F01.8", "Autre démence vasculaire", 60)
	Do ..AddObject(..#props, details, liste, "Maladie d'Alzheimer avec lésion(s) vasculaire(s) contributive(s)", "F00.2", "Maladie d'Alzheimer avec lésion(s) vasculaire(s) contributive(s)", 70)
	Do ..AddObject(..#props, details, liste, "Démence de la maladie de Parkinson", "F02.3", "Démence de la maladie de Parkinson", 80)
	Do ..AddObject(..#props, details, liste, "Démence à corps de Lewy", "F02.34", "Démence à corps de Lewy", 90)
	Do ..AddObject(..#props, details, liste, "Démence fronto-temporale (DFT-vf)", "F02.0", "Démence fronto-temporale (DFT-vf)", 100)
	Do ..AddObject(..#props, details, liste, "Démence sémantique (et autres DFT-vt)", "G31.B", "Démence sémantique (et autres DFT-vt)", 110)
	Do ..AddObject(..#props, details, liste, "Aphasie progressive primaire", "G31.A", "Aphasie progressive primaire", 120)
	Do ..AddObject(..#props, details, liste, "Atrophie corticale postérieure", "G31.C", "Atrophie corticale postérieure", 130)
	Do ..AddObject(..#props, details, liste, "Paralysie supra-nucléaire progressive", "G23.1", "Paralysie supra-nucléaire progressive", 140)
	Do ..AddObject(..#props, details, liste, "Dégénérescence cortico-basale", "G23.8", "Dégénérescence cortico-basale", 150)
	Do ..AddObject(..#props, details, liste, "Maladie de Huntington", "F02.2", "Maladie de Huntington", 160)
	Do ..AddObject(..#props, details, liste, "Maladie de Creutzfeld Jakob", "F02.1", "Maladie de Creutzfeld Jakob", 170)
	Do ..AddObject(..#props, details, liste, "Hydrocéphalie à pression normale", "G91.2", "Hydrocéphalie à pression normale", 180)
	Do ..AddObject(..#props, details, liste, "Encéphalite limbique", "G04.9", "Encéphalite limbique", 190)
	Do ..AddObject(..#props, details, liste, "Démence du VIH", "F02.4", "Démence du VIH", 200)
	Do ..AddObject(..#props, details, liste, "Démences non classées ailleurs", "F0.3", "Démences non classées ailleurs", 210)
	Do ..AddObject(..#props, details, liste, "Troubles anxieux", "F41.9", "Troubles anxieux", 220)
	Do ..AddObject(..#props, details, liste, "Trouble dépressif isolé", "F32.9", "Trouble dépressif isolé", 230)
	Do ..AddObject(..#props, details, liste, "Trouble dépressif récurrent", "F33.9", "Trouble dépressif récurrent", 240)
	Do ..AddObject(..#props, details, liste, "Trouble anxieux / dépressif", "F41.2", "Trouble anxieux / dépressif", 250)
	Do ..AddObject(..#props, details, liste, "Troubles psychotiques", "F29", "Troubles psychotiques", 260)
	Do ..AddObject(..#props, details, liste, "État de stress post-traumatique", "F43.1", "État de stress post-traumatique", 270)
	Do ..AddObject(..#props, details, liste, "Autres troubles psychiatriques", "F44.9", "Autres troubles psychiatriques", 280)
	Do ..AddObject(..#props, details, liste, "Autres troubles neurologiques", "F09", "Autres troubles neurologiques", 290)
	Do ..AddObject(..#props, details, liste, "Lésion vasculaire (AVC)", "F01.81", "Lésion vasculaire (AVC)", 300)
	Do ..AddObject(..#props, details, liste, "Traumatisme crânien", "S06.9", "Traumatisme crânien", 310)
	Do ..AddObject(..#props, details, liste, "Épilepsie", "G40", "Épilepsie", 320)
	Do ..AddObject(..#props, details, liste, "SEP", "G35", "SEP", 330)
	Do ..AddObject(..#props, details, liste, "Maladie de Parkinson", "G20", "Maladie de Parkinson", 340)
	Do ..AddObject(..#props, details, liste, "Trouble organique cérébral directement lié à une pathologie", "F02.8", "Trouble organique cérébral directement lié à une pathologie", 350)
	Do ..AddObject(..#props, details, liste, "Trouble organique cérébral directement lié à l'utilisation d'alcool ou autres toxiques", "F10.6", "Trouble organique cérébral directement lié à l'utilisation d'alcool ou autres toxiques", 360)
	Do ..AddObject(..#props, details, liste, "Iatrogénie", "F13", "Iatrogénie", 370)
	Do ..AddObject(..#props, details, liste, "Diagnostic en attente", "R418", "Diagnostic en attente", 380)
	Do ..AddObject(..#props, details, liste, "Trouble bipolaire", "F31", "Trouble bipolaire", 390)
]]></Implementation>
</Method>

<Method name="InitActeDiagnosticSyndrome">
<Description>
Liste pour item ActeDiagnosticSyndrome</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeDiagnosticSyndrome')
	w "  ",listeNom ," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Dominante cognitive / Amnésique", "DS1", "Dominante cognitive / Amnésique", 10)
	Do ..AddObject(..#props, details, liste, "Dominante cognitive / Non amnésique – trouble du langage", "DS2", "Dominante cognitive / Non amnésique – trouble du langage", 20)
	Do ..AddObject(..#props, details, liste, "Dominante cognitive / Non amnésique – trouble visuel", "DS3", "Dominante cognitive / Non amnésique – trouble visuel", 30)
	Do ..AddObject(..#props, details, liste, "Syndrome dysexécutif cognitif ou/et comportemental prédominant", "DS4", "Syndrome dysexécutif cognitif ou/et comportemental prédominant", 40)
	Do ..AddObject(..#props, details, liste, "Autre présentation clinique dominante", "DS5", "Autre présentation clinique dominante", 50)
	Do ..AddObject(..#props, details, liste, "Présentation diffuse", "DS6", "Présentation diffuse", 60)
	Do ..AddObject(..#props, details, liste, "En attente", "DS7", "En attente", 70)
	Do ..AddObject(..#props, details, liste, "Non applicable", "DS8", "Non applicable", 80)
	Do ..AddObject(..#props, details, liste, "Troubles attentionnels", "DS9", "Troubles attentionnels", 90)
]]></Implementation>
</Method>

<Method name="InitActeDiagnosticEtiologie">
<Description>
Liste pour item ActeDiagnosticEtiologie</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeDiagnosticEtiologie')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non applicable", "DE43", "Non applicable", 10)
	Do ..AddObject(..#props, details, liste, "Diagnostic en attente", "DE42", "Diagnostic en attente", 20)
	Do ..AddObject(..#props, details, liste, "Angiopathie amyloide", "DE15", "Angiopathie amyloide", 30)
	Do ..AddObject(..#props, details, liste, "Atrophie multisystématisée", "DE11", "Atrophie multisystématisée", 40)
	Do ..AddObject(..#props, details, liste, "Autre trouble d’origine organique", "DE34", "Autre trouble d’origine organique", 50)
	Do ..AddObject(..#props, details, liste, "Autres troubles mentaux", "DE41", "Autres troubles mentaux", 60)
	Do ..AddObject(..#props, details, liste, "Commotion cérébrale", "DE24", "Commotion cérébrale", 70)
	Do ..AddObject(..#props, details, liste, "Dégénérescence cortico-basale", "DE9", "Dégénérescence cortico-basale", 80)
	Do ..AddObject(..#props, details, liste, "Dégénérescence Lobaire Fronto-Temporale", "DE7", "Dégénérescence Lobaire Fronto-Temporale", 90)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie anoxique", "DE29", "Encéphalopathie anoxique", 100)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie auto-immunes", "DE32", "Encéphalopathie auto-immunes", 110)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie carentielle non éthylique", "DE30", "Encéphalopathie carentielle non éthylique", 120)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie chronique post traumatique", "DE22", "Encéphalopathie chronique post traumatique", 130)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie d’origine infectieuse", "DE27", "Encéphalopathie d’origine infectieuse", 140)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie d’origine métabolique", "DE26", "Encéphalopathie d’origine métabolique", 150)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie éthylique", "DE28", "Encéphalopathie éthylique", 160)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie post radique", "DE44", "Encéphalopathie post radique", 170)
	Do ..AddObject(..#props, details, liste, "Encéphalopathie toxique", "DE31", "Encéphalopathie toxique", 180)
	Do ..AddObject(..#props, details, liste, "Epilepsie", "DE21", "Epilepsie", 190)
	Do ..AddObject(..#props, details, liste, "Hématome sous-dural chronique", "DE47", "Hématome sous-dural chronique", 200)
	Do ..AddObject(..#props, details, liste, "Hydrocéphalie chronique", "DE19", "Hydrocéphalie chronique", 210)
	Do ..AddObject(..#props, details, liste, "Iatrogénie", "DE46", "Iatrogénie", 220)
	Do ..AddObject(..#props, details, liste, "Maladie à corps de Lewy", "DE5", "Maladie à corps de Lewy", 230)
	Do ..AddObject(..#props, details, liste, "Maladie à Prion", "DE18", "Maladie à Prion", 240)
	Do ..AddObject(..#props, details, liste, "Maladie d’Alzheimer Certaine (Génétique)", "DE3", "Maladie d’Alzheimer Certaine (Génétique)", 250)
	Do ..AddObject(..#props, details, liste, "Maladie d’Alzheimer Cliniquement probable", "DE1", "Maladie d’Alzheimer Cliniquement probable", 260)
	Do ..AddObject(..#props, details, liste, "Maladie d’Alzheimer Dans le cadre du syndrome de Down", "DE4", "Maladie d’Alzheimer Dans le cadre du syndrome de Down", 270)
	Do ..AddObject(..#props, details, liste, "Maladie d’Alzheimer Probable (avec Biomarqueurs)", "DE2", "Maladie d’Alzheimer Probable (avec Biomarqueurs)", 280)
	Do ..AddObject(..#props, details, liste, "Maladie de Huntington", "DE10", "Maladie de Huntington", 290)
	Do ..AddObject(..#props, details, liste, "Maladie de Parkinson", "DE6", "Maladie de Parkinson", 300)
	Do ..AddObject(..#props, details, liste, "Maladie de Wilson", "DE25", "Maladie de Wilson", 310)
	Do ..AddObject(..#props, details, liste, "Paralysie supranucléaire progressive", "DE8", "Paralysie supranucléaire progressive", 320)
	Do ..AddObject(..#props, details, liste, "Pathologies vasculaires non liées à athérome", "DE16", "Pathologies vasculaires non liées à athérome", 330)
	Do ..AddObject(..#props, details, liste, "Schizophrénie et autres troubles psychotiques (DSM5)", "DE39", "Schizophrénie et autres troubles psychotiques (DSM5)", 340)
	Do ..AddObject(..#props, details, liste, "Sclérose en plaques", "DE13", "Sclérose en plaques", 350)
	Do ..AddObject(..#props, details, liste, "Séquelles d’AVC", "DE17", "Séquelles d’AVC", 360)
	Do ..AddObject(..#props, details, liste, "Séquelles encéphaliques de traumatisme crânien", "DE23", "Séquelles encéphaliques de traumatisme crânien", 370)
	Do ..AddObject(..#props, details, liste, "SLA et autres maladie du Motoneurone", "DE12", "SLA et autres maladie du Motoneurone", 380)
	Do ..AddObject(..#props, details, liste, "Stress post-traumatique", "DE45", "Stress post-traumatique", 390)
	Do ..AddObject(..#props, details, liste, "Syndrome des apnées du sommeil", "DE33", "Syndrome des apnées du sommeil", 400)
	Do ..AddObject(..#props, details, liste, "Traumatisme cranien", "DE48", "Traumatisme cranien", 410)
	Do ..AddObject(..#props, details, liste, "Trouble anxieux (DSM 5)", "DE36", "Trouble anxieux (DSM 5)", 420)
	Do ..AddObject(..#props, details, liste, "Trouble bipolaire (DSM5)", "DE37", "Trouble bipolaire (DSM5)", 430)
	Do ..AddObject(..#props, details, liste, "Trouble dépressif (DSM 5)", "DE35", "Trouble dépressif (DSM 5)", 440)
	Do ..AddObject(..#props, details, liste, "Troubles cognitifs vasculaires", "DE14", "Troubles cognitifs vasculaires", 450)
	Do ..AddObject(..#props, details, liste, "Troubles neurodevellopementaux", "DE40", "Troubles neurodevellopementaux", 460)
	Do ..AddObject(..#props, details, liste, "Troubles obsessionnels-compulsifs et apparentés (DSM5)", "DE38", "Troubles obsessionnels-compulsifs et apparentés (DSM5)", 470)
	Do ..AddObject(..#props, details, liste, "Tumeur intracrânienne", "DE20", "Tumeur intracrânienne", 480)
]]></Implementation>
</Method>

<Method name="InitActeObjetConsultation">
<Description>
Liste pour item ActeObjetConsultation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeObjetConsultation')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Diagnostic", "DIAG", "Diagnostic", 10)
	Do ..AddObject(..#props, details, liste, "Annonce diagnostic", "ANNDIAG", "Annonce diagnostic", 20)
	Do ..AddObject(..#props, details, liste, "Suivi du patient", "SUIVI", "Suivi du patient", 30)
]]></Implementation>
</Method>

<Method name="InitActeModaliteConsultation">
<Description>
Liste pour item ActeModaliteConsultation</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeModaliteConsultation')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Présentiel", "PRESENTIEL", "Présentiel", 10)
	Do ..AddObject(..#props, details, liste, "Téléconsultation", "TELECONS", "Téléconsultation", 10)
]]></Implementation>
</Method>

<Method name="InitActeRechercheProtocole">
<Description>
Liste pour item ActeRechercheProtocole</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeRechercheProtocole')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Étude Clinique Non Thérapeuthique", "ECNT", "Étude Clinique Non Thérapeuthique", 10)
	Do ..AddObject(..#props, details, liste, "Essai Médicamenteux", "EM", "Essai Médicamenteux", 20)
	Do ..AddObject(..#props, details, liste, "Essai Non Médicamenteux", "ENM", "Essai Non Médicamenteux", 30)
	Do ..AddObject(..#props, details, liste, "Essai Médicamenteux et Non Médicamenteux", "EG", "Essai Médicamenteux et Non Médicamenteux", 40)
]]></Implementation>
</Method>

<Method name="InitActeRechercheVisite">
<Description>
Liste pour item ActeRechercheVisite</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeRechercheVisite')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Screening", "S", "Screening", 10)
	Do ..AddObject(..#props, details, liste, "Inclusion", "I", "Inclusion", 10)
	Do ..AddObject(..#props, details, liste, "Visite de Suivi", "VS", "Visite de Suivi", 10)
]]></Implementation>
</Method>

<Method name="InitActeCmrrRecoursCause">
<Description>
Liste pour item ActeCmrrRecoursCause</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeCmrrRecoursCause')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Suivi", "SUIVI", "Suivi", 10)
	Do ..AddObject(..#props, details, liste, "Diagnostic difficile", "DIAGDIFF", "Diagnostic difficile", 20)
	Do ..AddObject(..#props, details, liste, "Plateau technique", "PLATEAUTECH", "Plateau technique", 30)
	Do ..AddObject(..#props, details, liste, "Spécialité de l'expertise", "SPEEXP", "Spécialité de l'expertise", 40)
]]></Implementation>
</Method>

<Method name="InitActeTpEffetIndesirable">
<Description>
Liste pour item ActeTpEffetIndesirable</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
    &sql(select ID, ListeNom into :listeId, :listeNom from Bna.Listes where ListeNomCourt='ActeTpEffetIndesirable')
	w "  ",listeNom," pour acte", !
    Set liste=##class(Bna.Listes).%OpenId(listeId)

	Do ..AddObject(..#props, details, liste, "Non", "N", "Non", 10)
	Do ..AddObject(..#props, details, liste, "Oui", "O", "Oui", 20)
	Do ..AddObject(..#props, details, liste, "Oui, sans rapport avec le traitement", "SR", "Oui, sans rapport avec le traitement", 30)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.ListesItemsD</DataLocation>
<DefaultData>ListesItemsDefaultData</DefaultData>
<IdLocation>^Bna.ListesItemsD</IdLocation>
<IndexLocation>^Bna.ListesItemsI</IndexLocation>
<StreamLocation>^Bna.ListesItemsS</StreamLocation>
<ExtentSize>380</ExtentSize>
<Data name="ListesItemsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Liste</Value>
</Value>
<Value name="3">
<Value>ItemParent</Value>
</Value>
<Value name="4">
<Value>ItemNom</Value>
</Value>
<Value name="5">
<Value>ItemNomCourt</Value>
</Value>
<Value name="6">
<Value>ItemTip</Value>
</Value>
<Value name="7">
<Value>ItemOrdre</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>2</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,16,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000"),$lb(21,21,21,21,21,21,21,21,21,21,21,21,21,21,21),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320))</Histogram>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3.33</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb("1","26","52","78","104","130","155","180","205","230","255","280","305","330","355","380"),$lb(0,0,0,0,1,1,1,0,1,1,1,0,1,1,1),$lb(822083584,822083584,842399744,842399744,892469248,892469248,926416896,926416896,825242624,808714240,858783744,858783744,892665856,892665856,942669824,825765888,842020096,808779776,858783744,858783744,892665856,892665856,942669824,842543104,858797312,808779776,858783744,858783744,892665856,892665856,942669824,859320320))</Histogram>
</Property>
<Property name="ItemNom">
<Selectivity>0.2907%</Selectivity>
<AverageFieldSize>23.99</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" 01-AIN"," 27-EURE"," 51-MARNE"," 77-SEINE-ET-MARNE"," A DOMICILE, SEUL, AVEC FAMILLE À COTÉ"," AUTRES TROUBLES MENTAUX"," CENTRE MÉMOIRE"," DIAGNOSTIC EN ATTENTE"," ENCÉPHALOPATHIE AUTO-IMMUNES"," GUADELOUPE"," MALADIE À CORPS DE LEWY"," NON"," OUI"," SCLÉROSE EN PLAQUES"," TROUBLE BIPOLAIRE"," ÎLE-DE-FRANCE"),$lb(1,1,1,1,2,1,1,1,1,1,1,1,1,1,1),$lb(540029229,808529217,842476869,842476869,892415309,892415309,926362963,926362963,1092633679,541347661,1431589445,1096111186,1128615508,1128615508,1145651527,1145651527,1162756933,1162756933,1196769604,1196769604,1296124993,1296124993,1313820160,1313820160,1330989312,1330989312,1396919365,1396919365,1414680405,1414680405,3461104941,550390853))</Histogram>
</Property>
<Property name="ItemNomCourt">
<Selectivity>0.2915%</Selectivity>
<AverageFieldSize>6.13</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" +50"," 24"," 47"," 73"," 973"," CENTRE"," DE11"," DE34"," DIAGDIFF"," ETAB"," F41.2"," GUADELOUPE"," MR"," O"," S06.9"," VS"),$lb(1,1,1,1,1,1,3,2,1,1,1,1,1,1,1),$lb(539702576,724905984,842268672,842268672,876019712,876019712,926089216,926089216,959918848,959918848,1128615508,1128615508,1145385265,825294848,859045888,1160983552,1229014852,1145651527,1163149634,1163149634,1177825582,1177825582,1196769604,1196769604,1297219584,1297219584,1325400064,1325400064,1395668526,1395668526,1448280064,542528256))</Histogram>
</Property>
<Property name="ItemOrdre">
<Selectivity>1.4035%</Selectivity>
<OutlierSelectivity>.326316:0</OutlierSelectivity>
<AverageFieldSize>2.77</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb(0,0,0,0,0,10,10,20,30,40,50,80,110,190,310,480),$lb(1,1,1,1,0,2,0,0,0,0,0,0,1,0,0),$lb(805306368,0,0,0,0,0,0,0,0,805306368,825229312,0,0,825229312,842006528,842006528,858783744,858783744,875560960,875560960,892338176,892338176,942669824,942669824,825307136,825229312,959447040,825831424,858861568,858861568,876097536,876097536))</Histogram>
</Property>
<Property name="ItemParent">
<Selectivity>1.4543%</Selectivity>
<OutlierSelectivity>.723684:</OutlierSelectivity>
<AverageFieldSize>2.39</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,11,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","1","4","8","11","19"),$lb(21,21,21,21,21,21,21,21,21,21,0,0,0,0,1),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320,822083584,822083584,872415232,872415232,939524096,939524096,825294848,822083584,956301312,825819136))</Histogram>
</Property>
<Property name="ItemTip">
<Selectivity>0.2833%</Selectivity>
<AverageFieldSize>29.94</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" A DOMICILE, AVEC CONJOINT"," AUTRE DÉMENCE VASCULAIRE"," CENTRE MULTI-SITES"," DIAGNOSTIC EN ATTENTE"," DÉPARTEMENT DE L'EURE"," DÉPARTEMENT DE LA HAUTE-SAÔNE"," DÉPARTEMENT DES ALPES-DE-HAUTE-PROVENCE"," DÉPARTEMENT DU LOIRET"," ENCÉPHALOPATHIE CARENTIELLE NON ÉTHYLIQUE"," HDJ DANS UN AUTRE ÉTABLISSEMENT"," MALADIE D’ALZHEIMER CERTAINE (GÉNÉTIQUE)"," OUI"," RÉGION CENTRE-VAL DE LOIRE (18, 28, 36, 37, 41, 45)"," SECONDAIRE (COLLÈGE, CAP, BREVET)"," TROUBLE ANXIEUX / DÉPRESSIF"," ÉTUDE CLINIQUE NON THÉRAPEUTHIQUE"),$lb(2,1,1,2,17,15,14,1,1,1,1,1,1,1,1),$lb(541139012,541347661,1431589445,1096111186,1128615508,1128615508,1145651527,1229014862,3377480018,658855250,1092634689,541868320,1394622796,1163075649,1428180047,1154043969,1162756933,1162756933,1212434976,1212434976,1296124993,1296124993,1330989312,1330989312,1388922697,1388922697,1397048143,1397048143,1414680405,1414680405,3377747268,550065237))</Histogram>
</Property>
<Property name="Liste">
<Selectivity>1.9044%</Selectivity>
<OutlierSelectivity>.276316:2</OutlierSelectivity>
<AverageFieldSize>3.62</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb("1","2","2","2","2","4","14","18","20","24","28","31","32","33","33","39"),$lb(0,1,1,1,0,0,1,0,1,1,0,1,1,2,1),$lb(822083584,822083584,838860800,0,0,0,0,0,0,838860800,872415232,872415232,825491456,872415232,939524096,825753600,842006528,805306368,872415232,872415232,939524096,842530816,858849280,822083584,838860800,838860800,855638016,0,0,855638016,956301312,859373568))</Histogram>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-16</BlockCount>
</SQLMap>
<SQLMap name="ItemNomCourtIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="ItemNomIndex">
<BlockCount>-12</BlockCount>
</SQLMap>
<SQLMap name="ItemParentIndex">
<BlockCount>-8</BlockCount>
</SQLMap>
<SQLMap name="ListeIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Bna.Patients">
<Super>%Persistent</Super>
<TimeChanged>66476,38940.830115947</TimeChanged>
<TimeCreated>66459,39338.932521</TimeCreated>
<DependsOn>Centres,ListesItems</DependsOn>

<Property name="PatientPseudo">
<Description>
Pseudonyme du patient</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="255"/>
</Property>

<Index name="PatientPseudoIndex">
<Properties>PatientPseudo</Properties>
<Unique>1</Unique>
</Index>

<Property name="PatientPseudoBnaV1">
<Description>
Pseudonyme de la Bna v1 (ancienne clé BNA)</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="64"/>
</Property>

<Index name="PatientPseudoBnaV1Index">
<Properties>PatientPseudoBnaV1</Properties>
</Index>

<Property name="PatientCentre">
<Description>
Centre lié</Description>
<Type>Bna.Centres</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsCentre</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="PatientCentreIndex">
<Properties>PatientCentre</Properties>
</Index>

<Property name="PatientTsCreation">
<Description>
Timestamp création du patient (non modifiable)</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Index name="PatientTsCreationIndex">
<Properties>PatientTsCreation</Properties>
</Index>

<Property name="PatientTsDerniereModification">
<Description>
Timestamp dernière modification</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Index name="PatientTsDerniereModificationIndex">
<Properties>PatientTsDerniereModification</Properties>
</Index>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="PatientsPrivatePatient">
<Type>Bna.PatientsPrivate</Type>
<Cardinality>many</Cardinality>
<Inverse>Patient</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="TraceActionsPatient">
<Type>Bna.TraceActions</Type>
<Cardinality>many</Cardinality>
<Inverse>TracePatient</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="ActesPatients">
<Type>Bna.Actes</Type>
<Cardinality>many</Cardinality>
<Inverse>ActePatient</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.PatientsD</DataLocation>
<DefaultData>PatientsDefaultData</DefaultData>
<IdLocation>^Bna.PatientsD</IdLocation>
<IndexLocation>^Bna.PatientsI</IndexLocation>
<StreamLocation>^Bna.PatientsS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="PatientsDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientPseudo</Value>
</Value>
<Value name="3">
<Value>PatientPseudoBnaV1</Value>
</Value>
<Value name="4">
<Value>PatientCentre</Value>
</Value>
<Value name="5">
<Value>PatientTsCreation</Value>
</Value>
<Value name="6">
<Value>PatientTsDerniereModification</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.PatientsPrivate">
<Description>
Données privées des patients</Description>
<Super>%Persistent</Super>
<TimeChanged>66477,56528.167486737</TimeChanged>
<TimeCreated>66459,41773.588283</TimeCreated>
<DependsOn>ListesItems,Patients</DependsOn>

<Property name="Patient">
<Description>
Patient</Description>
<Type>Bna.Patients</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivatePatient</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientIndex">
<Properties>Patient</Properties>
<Unique>1</Unique>
</Index>

<Property name="PatientIns">
<Description>
Identifiant National de Santé (sans la clé)</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="13"/>
</Property>

<Index name="PatientInsIndex">
<Properties>PatientIns</Properties>
<Unique>1</Unique>
</Index>

<Property name="PatientInsCle">
<Description>
Clé validation ins</Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="5"/>
</Property>

<Property name="PatientSexe">
<Description>
LI - Sexe du Patient</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivatePatientSexe</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="PatientSexeIndex">
<Properties>PatientSexe</Properties>
</Index>

<Property name="PatientDateNaissance">
<Description>
Date de naissance (max date du jour -20ans)</Description>
<Type>%Date</Type>
<Required>1</Required>
</Property>

<Index name="PatientDateNaissanceIndex">
<Properties>PatientDateNaissance</Properties>
</Index>

<Property name="PatientNomUsage">
<Description>
Nom d'usage</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Index name="PatientNomUsageIndex">
<Properties>PatientNomUsage</Properties>
</Index>

<Property name="PatientNomNaissance">
<Description>
Nom de naissance</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Index name="PatientNomNaissanceIndex">
<Properties>PatientNomNaissance</Properties>
</Index>

<Property name="PatientPrenom">
<Description>
Prénom</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Property name="PatientAdRue1">
<Description>
Adresse : n° et rue</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Property name="PatientAdRue2">
<Description>
Adresse : Complément d'adresse</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="60"/>
</Property>

<Property name="PatientAdCp">
<Description>
Adresse: Code postal</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="5"/>
</Property>

<Property name="PatientAdVille">
<Description>
Adresse : Ville</Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="PatientAccompagnant">
<Description>
LI - Type d'accompagnant</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateAccompagnant</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientAccompagnantIndex">
<Properties>PatientAccompagnant</Properties>
</Index>

<Property name="PatientSoutienPsyAccompagnant">
<Description>
LI - Soutien psychologique de l'accompagnant</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateSoutienPsyAccompagnant</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="PatientSoutienPsyAccompagnantIndex">
<Properties>PatientSoutienPsyAccompagnant</Properties>
</Index>

<Property name="PatientNiveauEtudes">
<Description>
LI - Niveau d'études</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateNiveauEtudes</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientNiveauEtudesIndex">
<Properties>PatientNiveauEtudes</Properties>
</Index>

<Property name="PatientLangueMaternelle">
<Description>
LI - Langue maternelle</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateLangueMaternelle</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="PatientLangueMaternelleIndex">
<Properties>PatientLangueMaternelle</Properties>
</Index>

<Property name="PatientProfession">
<Description>
LI - Profession</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateProfession</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientProfessionIndex">
<Properties>PatientProfession</Properties>
</Index>

<Property name="PatientEnvoyePar">
<Description>
LI - Type du prescripteur</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateEnvoyePar</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientEnvoyeParIndex">
<Properties>PatientEnvoyePar</Properties>
</Index>

<Property name="PatientSituationGeographique">
<Description>
LI - Situation géographique</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateSituationGeographique</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientSituationGeographiqueIndex">
<Properties>PatientSituationGeographique</Properties>
</Index>

<Property name="PatientModeDeVie">
<Description>
LI - Mode de vie</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateMode</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientModeDeVieIndex">
<Properties>PatientModeDeVie</Properties>
</Index>

<Property name="PatientMesureProtection">
<Description>
LI - Mesure de protection (tutelle, curatelle)</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateMesureProtection</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientMesureProtectionIndex">
<Properties>PatientMesureProtection</Properties>
</Index>

<Property name="PatientApa">
<Description>
LI - Allocation Personnalisée d'autonomie</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateApa</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientApaIndex">
<Properties>PatientApa</Properties>
</Index>

<Property name="PatientAld">
<Description>
LI - Affection de Longue Durée</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateAld</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="PatientAldIndex">
<Properties>PatientAld</Properties>
</Index>

<Property name="PatientConsentementRecherche">
<Description>
Indique que le patient a donné son consentement pour la recherche</Description>
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Index name="PatientConsentementRechercheIndex">
<Properties>PatientConsentementRecherche</Properties>
</Index>

<Property name="PatientConsentementStatistique">
<Description>
Indique que le patient a donné son accord pour un traitement de ses données à des fins statistiques</Description>
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Index name="PatientConsentementStatistiqueIndex">
<Properties>PatientConsentementStatistique</Properties>
</Index>

<Property name="PatientNouveau">
<Description>
Indique que le patient est nouveau dans la BNA</Description>
<Type>%Boolean</Type>
<Required>1</Required>
</Property>

<Index name="PatientNouveauIndex">
<Properties>PatientNouveau</Properties>
</Index>

<Property name="PatientAnneePremiereConsult">
<Description>
Année de la première consult pour maladie mentale</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="4"/>
</Property>

<Property name="PatientFinSuivi">
<Description>
LI - Type de fin de suivi</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>PatientsPrivateFinSuivi</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="PatientFinSuiviIndex">
<Properties>PatientFinSuivi</Properties>
</Index>

<Property name="PatientDateEntreeInstitution">
<Description>
Date d'entrée en institution (si fin suivi = entrée en institution)</Description>
<Type>%Date</Type>
</Property>

<Index name="PatientDateEntreeInstitutionIndex">
<Properties>PatientDateEntreeInstitution</Properties>
</Index>

<Property name="PatientDateDeces">
<Description>
Date de décès (si fin suivi = décès)</Description>
<Type>%Date</Type>
</Property>

<Index name="PatientDateDecesIndex">
<Properties>PatientDateDeces</Properties>
</Index>

<Property name="PatientTsCreation">
<Description>
Timestamp création du patient (non modifiable)</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Index name="PatientTsCreationIndex">
<Properties>PatientTsCreation</Properties>
</Index>

<Property name="PatientTsDerniereModification">
<Description>
Timestamp dernière modification</Description>
<Type>%TimeStamp</Type>
<Required>1</Required>
</Property>

<Index name="PatientTsDerniereModificationIndex">
<Properties>PatientTsDerniereModification</Properties>
</Index>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.PatientsPrivateD</DataLocation>
<DefaultData>PatientsPrivateDefaultData</DefaultData>
<IdLocation>^Bna.PatientsPrivateD</IdLocation>
<IndexLocation>^Bna.PatientsPrivateI</IndexLocation>
<StreamLocation>^Bna.PatientsPrivateS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="PatientsPrivateDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Patient</Value>
</Value>
<Value name="3">
<Value>PatientIns</Value>
</Value>
<Value name="4">
<Value>PatientInsCle</Value>
</Value>
<Value name="5">
<Value>PatientSexe</Value>
</Value>
<Value name="6">
<Value>PatientDateNaissance</Value>
</Value>
<Value name="7">
<Value>PatientNomUsage</Value>
</Value>
<Value name="8">
<Value>PatientNomNaissance</Value>
</Value>
<Value name="9">
<Value>PatientPrenom</Value>
</Value>
<Value name="10">
<Value>PatientAdRue1</Value>
</Value>
<Value name="11">
<Value>PatientAdRue2</Value>
</Value>
<Value name="12">
<Value>PatientAdCp</Value>
</Value>
<Value name="13">
<Value>PatientAdVille</Value>
</Value>
<Value name="14">
<Value>PatientAccompagnant</Value>
</Value>
<Value name="15">
<Value>PatientNiveauEtudes</Value>
</Value>
<Value name="16">
<Value>PatientProfession</Value>
</Value>
<Value name="17">
<Value>PatientEnvoyePar</Value>
</Value>
<Value name="18">
<Value>PatientSituationGeographique</Value>
</Value>
<Value name="19">
<Value>PatientModeDeVie</Value>
</Value>
<Value name="20">
<Value>PatientMesureProtection</Value>
</Value>
<Value name="21">
<Value>PatientApa</Value>
</Value>
<Value name="22">
<Value>PatientAld</Value>
</Value>
<Value name="23">
<Value>PatientConsentementRecherche</Value>
</Value>
<Value name="24">
<Value>PatientConsentementStatistique</Value>
</Value>
<Value name="25">
<Value>PatientAnneePremiereConsult</Value>
</Value>
<Value name="26">
<Value>PatientFinSuivi</Value>
</Value>
<Value name="27">
<Value>PatientDateEntreeInstitution</Value>
</Value>
<Value name="28">
<Value>PatientDateDeces</Value>
</Value>
<Value name="29">
<Value>PatientTsCreation</Value>
</Value>
<Value name="30">
<Value>PatientTsDerniereModification</Value>
</Value>
<Value name="31">
<Value>PatientLangueMaternelle</Value>
</Value>
<Value name="32">
<Value>PatientSoutienPsyAccompagnant</Value>
</Value>
<Value name="33">
<Value>PatientNouveau</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.TraceActions">
<Description>
Traçabilité des actions utilisateurs</Description>
<Super>%Persistent</Super>
<TimeChanged>66461,62597.114254</TimeChanged>
<TimeCreated>66457,42894.476592</TimeCreated>
<DependsOn>ListesItems,Centres,Patients,Actes,TraceMessages</DependsOn>

<Property name="TraceUtilisateurIdentifiant">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="TraceUtilisateurIdentifiantIndex">
<Properties>TraceUtilisateurIdentifiant</Properties>
</Index>

<Property name="TraceUtilisateurNom">
<Type>%String</Type>
<Parameter name="MAXLEN" value="120"/>
</Property>

<Property name="TraceQuand">
<Type>%DateTime</Type>
<Required>1</Required>
</Property>

<Index name="TraceQuandIndex">
<Properties>TraceQuand</Properties>
</Index>

<Property name="TraceCentre">
<Description>
Centre lié</Description>
<Type>Bna.Centres</Type>
<Cardinality>one</Cardinality>
<Inverse>TraceActionsCentre</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="TraceCentreIndex">
<Properties>TraceCentre</Properties>
</Index>

<Property name="TracePatient">
<Description>
Patient lié à l'action </Description>
<Type>Bna.Patients</Type>
<Cardinality>one</Cardinality>
<Inverse>TraceActionsPatient</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="TracePatientIndex">
<Properties>TracePatient</Properties>
</Index>

<Property name="NewProperty1">
<Type>%String</Type>
</Property>

<Property name="TraceActe">
<Description>
Acte lié à l'action</Description>
<Type>Bna.Actes</Type>
<Cardinality>one</Cardinality>
<Inverse>TraceActionsActe</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="TraceActeIndex">
<Properties>TraceActe</Properties>
</Index>

<Property name="TraceMessage">
<Description>
Message pour l'action</Description>
<Type>Bna.TraceMessages</Type>
<Cardinality>one</Cardinality>
<Inverse>TraceActionsMessage</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="TraceMessageIndex">
<Properties>TraceMessage</Properties>
</Index>

<Property name="TraceMessageExtra">
<Description>
Compléments au message</Description>
<Type>%Text</Type>
<Parameter name="MAXLEN" value="10000"/>
</Property>

<Property name="TracePayload">
<Description>
Données modifiées pendant l'action</Description>
<Type>%Text</Type>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.TraceActionsD</DataLocation>
<DefaultData>TraceActionsDefaultData</DefaultData>
<IdLocation>^Bna.TraceActionsD</IdLocation>
<IndexLocation>^Bna.TraceActionsI</IndexLocation>
<StreamLocation>^Bna.TraceActionsS</StreamLocation>
<Data name="TraceActionsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>TraceUtilisateurIdentifiant</Value>
</Value>
<Value name="3">
<Value>TraceUtilisateurNom</Value>
</Value>
<Value name="4">
<Value>TraceQuand</Value>
</Value>
<Value name="5">
<Value>TraceCentre</Value>
</Value>
<Value name="6">
<Value>TracePatient</Value>
</Value>
<Value name="7">
<Value>NewProperty1</Value>
</Value>
<Value name="8">
<Value>TraceActe</Value>
</Value>
<Value name="9">
<Value>TraceMessage</Value>
</Value>
<Value name="10">
<Value>TraceMessageExtra</Value>
</Value>
<Value name="11">
<Value>TracePayload</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.TraceMessages">
<Description>
Messages utilisés dans TraceActions</Description>
<Super>%Persistent</Super>
<TimeChanged>66461,67360.896677</TimeChanged>
<TimeCreated>66461,61176.318987</TimeCreated>

<Property name="TraceMessageTexte">
<Description>
Texte du message</Description>
<Type>%Text</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="1000"/>
</Property>

<Index name="TraceMessageTexteIndex">
<Properties>TraceMessageTexte</Properties>
<Unique>1</Unique>
</Index>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="TraceActionsMessage">
<Type>Bna.TraceActions</Type>
<Cardinality>many</Cardinality>
<Inverse>TraceMessage</Inverse>
<Relationship>1</Relationship>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.TraceMessagesD</DataLocation>
<DefaultData>TraceMessagesDefaultData</DefaultData>
<IdLocation>^Bna.TraceMessagesD</IdLocation>
<IndexLocation>^Bna.TraceMessagesI</IndexLocation>
<StreamLocation>^Bna.TraceMessagesS</StreamLocation>
<Data name="TraceMessagesDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>TraceMessageTexte</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.Traitements">
<Description>
Traitements pharmacologiques</Description>
<Super>%Persistent,Bna.Utils</Super>
<TimeChanged>66476,39025.353036864</TimeChanged>
<TimeCreated>66459,58308.701844</TimeCreated>

<Property name="TraitementNom">
<Description>
Nom complet du traitement</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="120"/>
</Property>

<Index name="TraitementNomIndex">
<Properties>TraitementNom</Properties>
<Unique>1</Unique>
</Index>

<Property name="TraitementNomCourt">
<Description>
Nom court du traitement</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Index name="TraitementNomCourtIndex">
<Properties>TraitementNomCourt</Properties>
<Unique>1</Unique>
</Index>

<Property name="TraitementTip">
<Description>
Texte affiché lors des saisies</Description>
<Type>%Text</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="2000"/>
</Property>

<Property name="TraitementOrdre">
<Description>
Ordre pour liste</Description>
<Type>%SmallInt</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Propriétés inverses

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Property name="TaritementsActesTraitement">
<Type>Bna.TraitementsActes</Type>
<Cardinality>many</Cardinality>
<Inverse>Traitement</Inverse>
<Relationship>1</Relationship>
</Property>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Initialisations

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// ----------------------------------------------------------------------------------------------

]]></Content>
</UDLText>

<Parameter name="props">
<Default>TraitementNom,TraitementNomCourt,TraitementTip,TraitementOrdre</Default>
</Parameter>

<Method name="Init">
<ClassMethod>1</ClassMethod>
<FormalSpec>details:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
	w "Initialisation des traitements", !

	&sql(truncate table Bna.Traitements)
	
	
	Do ..AddObject(..#props, details, "Antidépresseurs", "ANTI-DEP", "Le patient est traité par des antidépresseurs", 10)
	Do ..AddObject(..#props, details, "Antagonistes NDMA", "ANTA-NMDA", "Le patient est traité par des antagonistes de la NMDA", 20)
	Do ..AddObject(..#props, details, "Inhibiteurs de l'acétylcholinestérase", "INHIB-ACETYL", "Le patient est traité par des inhibiteurs de l'acetylcholinestérase", 30)
	Do ..AddObject(..#props, details, "Neuroleptiques", "NEUROLEPT", "Le patient est traité par des neuroleptiques", 40)
	Do ..AddObject(..#props, details, "Anxiolitiques", "ANXIO", "Le patient est traité par des anxiolitiques", 50)
	Do ..AddObject(..#props, details, "Hypnotiques", "HYPNO", "Le patient est traité par des hypnotiques", 60)
	Do ..AddObject(..#props, details, "Nootropes", "NOOTROPE", "Le patient est traité par des nootropes", 70)
	Do ..AddObject(..#props, details, "Thymo-régulateurs", "THYMO-REG", "Le patient est traité par des thymo-régulateurs", 80)
	Do ..AddObject(..#props, details, "Anti-démentiels : Aricept", "AD-ARICEPT", "Le patient est traité par Aricept (anti-démentiel)", 90)
	Do ..AddObject(..#props, details, "Anti-démentiel : Exelon", "AD-EXELON", "Le patient est traité par Exelon (anti-démentiel)", 100)
	Do ..AddObject(..#props, details, "Anti-démentiel : Reminyl", "AD-REMINYL", "Le patient est traité par Reminyl (anti-démentiel)", 110)
	Do ..AddObject(..#props, details, "Anti-démentiel : Ebixa", "AD-EBIXA", "Le patient est traité par Ebixa (anti-démentiel)", 120)
	Do ..AddObject(..#props, details, "Anti-démentiel : Autre", "AD-AUTRE", "Le patient est traité par un autre anti-démentiel", 130)
	Do ..AddObject(..#props, details, "Chronique : Anti-hypertenseurs", "CHR-ANTI-HT", "Le patient est traité par des anti-hypertenseurs (traitement chronique)", 140)
	Do ..AddObject(..#props, details, "Chronique : Anticoagulants", "CHR-ANTI-COAG", "Le patient est traité par des anticoagulants (traitement chronique)", 150)
	Do ..AddObject(..#props, details, "Chronique : Anti-agrégants", "CHR-ANTI-AGR", "Le patient est traité par des anti-agrégants (traitement chronique)", 160)
	Do ..AddObject(..#props, details, "Chronique : Statines", "CHR-STATINE", "Le patient est traité par des statines (traitement chronique)", 170)
	Do ..AddObject(..#props, details, "Chronique : Anti-diabétiques", "CHR-ANTI-DB", "Le patient est traité par des anti-diabétiques (traitement chronique)", 180)
	Do ..AddObject(..#props, details, "Chronique : Autre", "CHR-AUTRE", "Le patient est traité par un autre traitement chronique", 190)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.TraitementsD</DataLocation>
<DefaultData>TraitementsDefaultData</DefaultData>
<IdLocation>^Bna.TraitementsD</IdLocation>
<IndexLocation>^Bna.TraitementsI</IndexLocation>
<StreamLocation>^Bna.TraitementsS</StreamLocation>
<ExtentSize>19</ExtentSize>
<Data name="TraitementsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>TraitementNom</Value>
</Value>
<Value name="3">
<Value>TraitementNomCourt</Value>
</Value>
<Value name="4">
<Value>TraitementOrdre</Value>
</Value>
<Value name="5">
<Value>TraitementTip</Value>
</Value>
</Data>
<Property name="%%CLASSNAME">
<Selectivity>100.0000%</Selectivity>
<AverageFieldSize>2</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,16,$lb("-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000","-10000000000000000000"),$lb(21,21,21,21,21,21,21,21,21,21,21,21,21,21,21),$lb(758198320,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,758198320))</Histogram>
</Property>
<Property name="%%ID">
<Selectivity>1</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,1,0,$lb("1","2","4","6","8","9","10","11","12","13","14","15","16","17","18","19"),$lb(0,0,0,0,0,0,1,1,1,1,1,1,1,1,1),$lb(822083584,822083584,838860800,838860800,872415232,872415232,905969664,905969664,939524096,939524096,956301312,956301312,825229312,805306368,822083584,822083584,838860800,838860800,855638016,855638016,872415232,872415232,889192448,889192448,905969664,905969664,922746880,922746880,939524096,939524096,956301312,825819136))</Histogram>
</Property>
<Property name="TraitementNom">
<Selectivity>1</Selectivity>
<AverageFieldSize>22.84</AverageFieldSize>
</Property>
<Property name="TraitementNomCourt">
<Selectivity>1</Selectivity>
<AverageFieldSize>11.32</AverageFieldSize>
</Property>
<Property name="TraitementOrdre">
<Selectivity>5.2632%</Selectivity>
<AverageFieldSize>3</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(10,20,40,60,80,90,100,110,120,130,140,150,160,170,180,190),$lb(0,0,0,0,0,0,1,1,1,1,1,1,1,1,1),$lb(825229312,825229312,842006528,842006528,875560960,875560960,909115392,909115392,942669824,942669824,959447040,959447040,825241600,808452096,825229312,825229312,842006528,842006528,858783744,858783744,875560960,875560960,892338176,892338176,909115392,909115392,925892608,925892608,942669824,942669824,959447040,825831424))</Histogram>
</Property>
<Property name="TraitementTip">
<Selectivity>5.2632%</Selectivity>
<AverageFieldSize>55.42</AverageFieldSize>
<Histogram>$lb(.06666666666666666667,0,0,$lb(" LE PATIENT EST TRAITÉ PAR ARICEPT (ANTI-DÉMENTIEL)"," LE PATIENT EST TRAITÉ PAR DES ANTAGONISTES DE LA NMDA"," LE PATIENT EST TRAITÉ PAR DES ANTI-DIABÉTIQUES (TRAITEMENT CHRONIQUE)"," LE PATIENT EST TRAITÉ PAR DES ANTICOAGULANTS (TRAITEMENT CHRONIQUE)"," LE PATIENT EST TRAITÉ PAR DES ANXIOLITIQUES"," LE PATIENT EST TRAITÉ PAR DES HYPNOTIQUES"," LE PATIENT EST TRAITÉ PAR DES INHIBITEURS DE L'ACETYLCHOLINESTÉRASE"," LE PATIENT EST TRAITÉ PAR DES NEUROLEPTIQUES"," LE PATIENT EST TRAITÉ PAR DES NOOTROPES"," LE PATIENT EST TRAITÉ PAR DES STATINES (TRAITEMENT CHRONIQUE)"," LE PATIENT EST TRAITÉ PAR DES THYMO-RÉGULATEURS"," LE PATIENT EST TRAITÉ PAR EBIXA (ANTI-DÉMENTIEL)"," LE PATIENT EST TRAITÉ PAR EXELON (ANTI-DÉMENTIEL)"," LE PATIENT EST TRAITÉ PAR REMINYL (ANTI-DÉMENTIEL)"," LE PATIENT EST TRAITÉ PAR UN AUTRE ANTI-DÉMENTIEL"," LE PATIENT EST TRAITÉ PAR UN AUTRE TRAITEMENT CHRONIQUE"),$lb(27,34,35,33,31,31,31,32,31,31,27,28,27,27,36),$lb(541869344,1095911747,1145393952,1095192398,1227703369,759449921,1129267527,1414087503,1481199436,1095653449,1213812814,1213812814,1229867081,1229867081,1313166674,1163219535,1330598994,1313820500,1398030676,1398030676,1414027597,1145393952,1161972056,1112102977,1480936527,1163412812,1380273481,1380273481,1431183425,1095652425,1414676809,541869344))</Histogram>
</Property>
<SQLMap name="IDKEY">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="TraitementNomCourtIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
<SQLMap name="TraitementNomIndex">
<BlockCount>-4</BlockCount>
</SQLMap>
</Storage>
</Class>


<Class name="Bna.TraitementsActes">
<Description>
Traitements pour les actes</Description>
<Super>%Persistent</Super>
<TimeChanged>66476,39067.621704082</TimeChanged>
<TimeCreated>66461,55457.541262</TimeCreated>
<DependsOn>Traitements,Actes,ListesItems</DependsOn>

<Property name="Acte">
<Description>
Acte lié</Description>
<Type>Bna.Actes</Type>
<Cardinality>one</Cardinality>
<Inverse>TraitementsActesActe</Inverse>
<Relationship>1</Relationship>
</Property>

<Index name="ActeIndex">
<Properties>Acte</Properties>
</Index>

<Property name="Traitement">
<Description>
Traitement associé</Description>
<Type>Bna.Traitements</Type>
<Cardinality>one</Cardinality>
<Inverse>TaritementsActesTraitement</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="TraitementIndex">
<Properties>Traitement</Properties>
</Index>

<Property name="TratementActePrescripteur">
<Description>
LI - Prescripteur du traitement</Description>
<Type>Bna.ListesItems</Type>
<Cardinality>one</Cardinality>
<Inverse>TraitementsActesPrecripteur</Inverse>
<Relationship>1</Relationship>
<Required>1</Required>
</Property>

<Index name="TratementActePrescripteurIndex">
<Properties>TratementActePrescripteur</Properties>
</Index>

<Property name="TraitementActeDebut">
<Description>
Date de début du traitement</Description>
<Type>%Date</Type>
</Property>

<Property name="TraitementActeFin">
<Description>
Date de fin du traitement</Description>
<Type>%Date</Type>
</Property>

<Property name="TraitementActeTsCreation">
<Description>
Timestamp création du traitement</Description>
<Type>%TimeStamp</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.TraitementsActesD</DataLocation>
<DefaultData>TraitementsActesDefaultData</DefaultData>
<IdLocation>^Bna.TraitementsActesD</IdLocation>
<IndexLocation>^Bna.TraitementsActesI</IndexLocation>
<StreamLocation>^Bna.TraitementsActesS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="TraitementsActesDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Traitement</Value>
</Value>
<Value name="3">
<Value>TratementActePrescripteur</Value>
</Value>
<Value name="4">
<Value>TraitementActeDebut</Value>
</Value>
<Value name="5">
<Value>TraitementActeFin</Value>
</Value>
<Value name="6">
<Value>TraitementActeTsCreation</Value>
</Value>
<Value name="7">
<Value>Acte</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.tableSQLintermidiare">
<Super>%Persistent,Ens.Request</Super>
<TimeChanged>66540,57715.166394082</TimeChanged>
<TimeCreated>66540,55105.19960541</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// ( :Application  , :CentreADCp  , :CentreADRue1  , :CentreADRue2  , :CentreADVille  , :CentreHDj , :CentreInclusion , :CentreLabel , :CentreLabelAnnee , :CentreMail , :CentreMultisite , :CentreNom , :CentreNomReseau , :CentreNum , :CentreNumADeli , :CentreNumFiness , :CentreNumRmes , :CentreNumRpps , :CentreOuvConsultation , :CentrePersoARC , :CentrePersoASocial , :CentrePersoAutre , :CentrePersoDescriptionAutre , :CentrePersoGeriatre , :CentrePersoIDE , :CentrePersoKine , :CentrePersoNeurologue , :CentrePersoOrthophoniste , :CentrePersoPsychiatre , :CentrePersoPsychologue , :CentrePersoSecretaire , :CentrePersoTEC , :CentreReseau , :CentreResponsable , :CentreType , :ClActiviteConsultMemoire , :ClActiviteReseau , :ClCollabCmCmrr , :ClCollabNeuroPsy , :ClNbFormAn , :ClPratiqueETP , :ClTypeSpecialiste , :CmrrActiviteAnimation , :CmrrActiviteEthique , :CmrrActiviteRecherche , :CmrrCmActiviteSoutien , :CmrrCmActiviteStimul , :CmrrFormationsUniv , :CmrrPublications , :DclALD , :DclAPa , :DclAnneePremierDiag , :DclCmrrRecours , :DclCmrrRecoursDiagDiff , :DclCmrrRecoursPTech , :DclCmrrRecoursSpExpert , :DclCmrrRecoursSuivi , :DclDateActe , :DclDateDeces , :DclDateEntreeInstitution , :DclDateFinSuivi , :DclDiagnostic , :DclDiagnosticN31 , :DclDiagnosticN32 , :DclDiagnosticN33 , :DclEffetInDesirable , :DclEtatDemence , :DclFinSuivi , :DclIADLConsequence , :DclIADLDetection , :DclIPSRAccueilJour , :DclIPSRAucun , :DclIPSRAutre , :DclIPSRClic , :DclIPSRErgotherapeute , :DclIPSREsAD , :DclIPSRGarDeMalaDe , :DclIPSRGroupe , :DclIPSRHDj , :DclIPSRKinesitherapeute , :DclIPSRMaia , :DclIPSROrthophoniste , :DclIPSRPaERPa , :DclIPSRPsychologue , :DclIPSRRepits , :DclIPSRSiaD , :DclIPSRUcc , :DclMMSE , :DclMesureProtection , :DclMoDeDeVie , :DclPCAucun , :DclPCBioMarqueurs , :DclPCIRM , :DclPCPET , :DclPCSPECT , :DclPCScanner , :DclPECAiDant , :DclPR , :DclPRType , :DclPRVisite , :DclRechAcceptPlacebo , :DclRechAutonom , :DclRechContreInDic , :DclRechPresDispo , :DclTPantagonisteNMDA , :DclTPantagonisteNMDAAvantPEC , :DclTPantagonisteNMDADebut , :DclTPantagonisteNMDADebutPar , :DclTPantagonisteNMDAFin , :DclTPantagonisteNMDAFinPar , :DclTPantiEpileptiques , :DclTPantiEpileptiquesAvantPEC , :DclTPantiEpileptiquesDebut , :DclTPantiEpileptiquesDebutPar , :DclTPantiEpileptiquesFin , :DclTPantiEpileptiquesFinPar , :DclTPantiParkinsoniens , :DclTPantiParkinsoniensAvantPEC , :DclTPantiParkinsoniensDebut , :DclTPantiParkinsoniensDebutPar , :DclTPantiParkinsoniensFin , :DclTPantiParkinsoniensFinPar , :DclTPantiDepresseurs , :DclTPantiDepresseursAvantPEC , :DclTPantiDepresseursDebut , :DclTPantiDepresseursDebuTPar , :DclTPantiDepresseursFin , :DclTPantiDepresseursFinPar , :DclTPanxiolitiques , :DclTPanxiolitiquesAvantPEC , :DclTPanxiolitiquesDebut , :DclTPanxiolitiquesDebuTPar , :DclTPanxiolitiquesFin , :DclTPanxiolitiquesFinPar , :DclTPaucun , :DclTPaucunAvantPEC , :DclTPaucunDansListe , :DclTPaucunDansListeAvantPEC , :DclTPaucunDansListeDebut , :DclTPaucunDansListeDebuTPar , :DclTPaucunDansListeFin , :DclTPaucunDansListeFinPar , :DclTPaucunDebut , :DclTPaucunDebuTPar , :DclTPaucunFin , :DclTPaucunFinPar , :DclTPautres , :DclTPautresAvantPEC , :DclTPautresDebut , :DclTPautresDebuTPar , :DclTPautresFin , :DclTPautresFinPar , :DclTPHypnotiques , :DclTPHypnotiquesAvantPEC , :DclTPHypnotiquesDebut , :DclTPHypnotiquesDebuTPar , :DclTPHypnotiquesFin , :DclTPHypnotiquesFinPar , :DclTPInhibAcetyl , :DclTPInhibAcetylAvantPEC , :DclTPInhibAcetylDebut , :DclTPInhibAcetylDebuTPar , :DclTPInhibAcetylFin , :DclTPInhibAcetylFinPar , :DclTPNeuroleptiques , :DclTPNeuroleptiquesAvantPEC , :DclTPNeuroleptiquesDebut , :DclTPNeuroleptiquesDebuTPar , :DclTPNeuroleptiquesFin , :DclTPNeuroleptiquesFinPar , :DclTPNootropes , :DclTPNootropesAvantPEC , :DclTPNootropesDebut , :DclTPNootropesDebuTPar , :DclTPNootropesFin , :DclTPNootropesFinPar , :DclTPThymoRegulateurs , :DclTPThymoRegulateursAvantPEC , :DclTPThymoRegulateursDebut , :DclTPThymoRegulateursDebutPar , :DclTPThymoRegulateursFin , :DclTPThymoRegulateursFinPar , :DclTypeActe , :PatientAccomPagnant , :PatientAnneeNaissance , :PatientID , :PatientIDPreceDent , :PatientNiveauEtuDes , :PatientProfession , :PatientSexe , :PatientSituationGeo , :RetourMail , :atientEnvoyePar , :enregistrement10)

]]></Content>
</UDLText>

<Parameter name="MAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="CentreNom">
<Type>%String</Type>
</Property>

<Property name="CentreAdRue1">
<Type>%String</Type>
</Property>

<Property name="CentreAdRue2">
<Type>%String</Type>
</Property>

<Property name="CentreAdCp">
<Type>%String</Type>
</Property>

<Property name="CentreAdVille">
<Type>%String</Type>
</Property>

<Property name="CentreMail">
<Type>%String</Type>
</Property>

<Property name="CentreType">
<Type>%String</Type>
</Property>

<Property name="CentreNum">
<Type>%String</Type>
</Property>

<Property name="CentreResponsable">
<Type>%String</Type>
</Property>

<Property name="CentreLabel">
<Type>%String</Type>
</Property>

<Property name="CentreLabelAnnee">
<Type>%String</Type>
</Property>

<Property name="CentreReseau">
<Type>%String</Type>
</Property>

<Property name="CentreNomReseau">
<Type>%String</Type>
</Property>

<Property name="CentreInclusion">
<Type>%String</Type>
</Property>

<Property name="CentreMultisite">
<Type>%String</Type>
</Property>

<Property name="CentreHdj">
<Type>%String</Type>
</Property>

<Property name="CentreOuvConsultation">
<Type>%String</Type>
</Property>

<Property name="CentrePersoGeriatre">
<Type>%String</Type>
</Property>

<Property name="CentrePersoNeurologue">
<Type>%String</Type>
</Property>

<Property name="CentrePersoPsychiatre">
<Type>%String</Type>
</Property>

<Property name="CentrePersoPsychologue">
<Type>%String</Type>
</Property>

<Property name="CentrePersoOrthophoniste">
<Type>%String</Type>
</Property>

<Property name="CentrePersoKine">
<Type>%String</Type>
</Property>

<Property name="CentrePersoASocial">
<Type>%String</Type>
</Property>

<Property name="CentrePersoSecretaire">
<Type>%String</Type>
</Property>

<Property name="CentrePersoIDE">
<Type>%String</Type>
</Property>

<Property name="CentrePersoARC">
<Type>%String</Type>
</Property>

<Property name="CentrePersoTEC">
<Type>%String</Type>
</Property>

<Property name="CentrePersoAutre">
<Type>%String</Type>
</Property>

<Property name="CentrePersoDescriptionAutre">
<Type>%String</Type>
</Property>

<Property name="CmrrPublications">
<Type>%String</Type>
</Property>

<Property name="CmrrFormationsUniv">
<Type>%String</Type>
</Property>

<Property name="enregistrement10">
<Type>%String</Type>
</Property>

<Property name="CmrrActiviteAnimation">
<Type>%String</Type>
</Property>

<Property name="CmrrActiviteRecherche">
<Type>%String</Type>
</Property>

<Property name="CmrrActiviteEthique">
<Type>%String</Type>
</Property>

<Property name="CmrrCmActiviteSoutien">
<Type>%String</Type>
</Property>

<Property name="CmrrCmActiviteStimul">
<Type>%String</Type>
</Property>

<Property name="ClTypeSpecialiste">
<Type>%String</Type>
</Property>

<Property name="ClCollabNeuroPsy">
<Type>%String</Type>
</Property>

<Property name="ClPratiqueETP">
<Type>%String</Type>
</Property>

<Property name="ClActiviteConsultMemoire">
<Type>%String</Type>
</Property>

<Property name="ClCollabCmCmrr">
<Type>%String</Type>
</Property>

<Property name="ClActiviteReseau">
<Type>%String</Type>
</Property>

<Property name="ClNbFormAn">
<Type>%String</Type>
</Property>

<Property name="PatientId">
<Type>%String</Type>
</Property>

<Property name="PatientSexe">
<Type>%String</Type>
</Property>

<Property name="PatientAnneeNaissance">
<Type>%String</Type>
</Property>

<Property name="PatientNiveauEtudes">
<Type>%String</Type>
</Property>

<Property name="PatientSituationGeo">
<Type>%String</Type>
</Property>

<Property name="atientEnvoyePar">
<Type>%String</Type>
</Property>

<Property name="DclEtatDemence">
<Type>%String</Type>
</Property>

<Property name="DclAnneePremierDiag">
<Type>%String</Type>
</Property>

<Property name="DclDiagnostic">
<Type>%String</Type>
</Property>

<Property name="DclTypeActe">
<Type>%String</Type>
</Property>

<Property name="DclDateActe">
<Type>%String</Type>
</Property>

<Property name="DclMMSE">
<Type>%String</Type>
</Property>

<Property name="DclIADLDetection">
<Type>%String</Type>
</Property>

<Property name="DclIADLConsequence">
<Type>%String</Type>
</Property>

<Property name="DclModeDeVie">
<Type>%String</Type>
</Property>

<Property name="DclAPA">
<Type>%String</Type>
</Property>

<Property name="DclALD">
<Type>%String</Type>
</Property>

<Property name="DclMesureProtection">
<Type>%String</Type>
</Property>

<Property name="DclFinSuivi">
<Type>%String</Type>
</Property>

<Property name="DclDateFinSuivi">
<Type>%String</Type>
</Property>

<Property name="DclDateEntreeInstitution">
<Type>%String</Type>
</Property>

<Property name="DclDateDeces">
<Type>%String</Type>
</Property>

<Property name="DclTPAucun">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetyl">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDA">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseurs">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiques">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiques">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiques">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropes">
<Type>%String</Type>
</Property>

<Property name="DclTPAutres">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListe">
<Type>%String</Type>
</Property>

<Property name="DclEffetIndesirable">
<Type>%String</Type>
</Property>

<Property name="DclIPSRAucun">
<Type>%String</Type>
</Property>

<Property name="DclIPSROrthophoniste">
<Type>%String</Type>
</Property>

<Property name="DclIPSRPsychologue">
<Type>%String</Type>
</Property>

<Property name="DclIPSRKinesitherapeute">
<Type>%String</Type>
</Property>

<Property name="DclIPSRErgotherapeute">
<Type>%String</Type>
</Property>

<Property name="DclIPSRGroupe">
<Type>%String</Type>
</Property>

<Property name="DclIPSRAccueilJour">
<Type>%String</Type>
</Property>

<Property name="DclIPSRMaia">
<Type>%String</Type>
</Property>

<Property name="DclIPSRClic">
<Type>%String</Type>
</Property>

<Property name="DclIPSRRepits">
<Type>%String</Type>
</Property>

<Property name="DclIPSRSiad">
<Type>%String</Type>
</Property>

<Property name="DclIPSRAutre">
<Type>%String</Type>
</Property>

<Property name="DclPCAucun">
<Type>%String</Type>
</Property>

<Property name="DclPCIRM">
<Type>%String</Type>
</Property>

<Property name="DclPCScanner">
<Type>%String</Type>
</Property>

<Property name="DclPCSPECT">
<Type>%String</Type>
</Property>

<Property name="DclPCPET">
<Type>%String</Type>
</Property>

<Property name="DclPCBioMarqueurs">
<Type>%String</Type>
</Property>

<Property name="DclPR">
<Type>%String</Type>
</Property>

<Property name="DclPRType">
<Type>%String</Type>
</Property>

<Property name="DclPRVisite">
<Type>%String</Type>
</Property>

<Property name="RetourMail">
<Type>%String</Type>
</Property>

<Property name="PatientIdPrecedent">
<Type>%String</Type>
</Property>

<Property name="Application">
<Type>%String</Type>
</Property>

<Property name="CentreNumRmes">
<Type>%String</Type>
</Property>

<Property name="CentreNumFiness">
<Type>%String</Type>
</Property>

<Property name="CentreNumAdeli">
<Type>%String</Type>
</Property>

<Property name="CentreNumRpps">
<Type>%String</Type>
</Property>

<Property name="DclCmrrRecours">
<Type>%String</Type>
</Property>

<Property name="DclCmrrRecoursDiagDiff">
<Type>%String</Type>
</Property>

<Property name="DclCmrrRecoursSuivi">
<Type>%String</Type>
</Property>

<Property name="DclCmrrRecoursPTech">
<Type>%String</Type>
</Property>

<Property name="DclCmrrRecoursSpExpert">
<Type>%String</Type>
</Property>

<Property name="PatientProfession">
<Type>%String</Type>
</Property>

<Property name="PatientAccompagnant">
<Type>%String</Type>
</Property>

<Property name="DclIPSREsad">
<Type>%String</Type>
</Property>

<Property name="DclIPSRHdj">
<Type>%String</Type>
</Property>

<Property name="DclIPSRUcc">
<Type>%String</Type>
</Property>

<Property name="DclRechPresDispo">
<Type>%String</Type>
</Property>

<Property name="DclRechAutonom">
<Type>%String</Type>
</Property>

<Property name="DclRechContreIndic">
<Type>%String</Type>
</Property>

<Property name="DclRechAcceptPlacebo">
<Type>%String</Type>
</Property>

<Property name="DclDiagnosticN31">
<Type>%String</Type>
</Property>

<Property name="DclDiagnosticN32">
<Type>%String</Type>
</Property>

<Property name="DclDiagnosticN33">
<Type>%String</Type>
</Property>

<Property name="DclPECAidant">
<Type>%String</Type>
</Property>

<Property name="DclIPSRGardeMalade">
<Type>%String</Type>
</Property>

<Property name="DclIPSRPAERPA">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiques">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateurs">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniens">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetylDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDADebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseursDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiquesDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiquesDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiquesDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropesDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiquesDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateursDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniensDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAutresDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListeDebut">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunFin">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetylFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDAFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseursFin">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiquesFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiquesFin">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiquesFin">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropesFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiquesFin">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateursFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniensFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAutresFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListeFin">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetylDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDADebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseursDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiquesDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiquesDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiquesDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropesDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiquesDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateursDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniensDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAutresDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListeDebutPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetylFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDAFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseursFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiquesFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiquesFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiquesFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropesFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiquesFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateursFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniensFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAutresFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListeFinPar">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPInhibAcetylAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAntagonisteNMDAAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAntidepresseursAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPNeuroleptiquesAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAnxiolitiquesAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPHypnotiquesAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPNootropesAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiEpileptiquesAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPThymoRegulateursAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAntiParkinsoniensAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAutresAvantPEC">
<Type>%String</Type>
</Property>

<Property name="DclTPAucunDansListeAvantPEC">
<Type>%String</Type>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Bna.tableSQLintermidiareD</DataLocation>
<DefaultData>tableSQLintermidiareDefaultData</DefaultData>
<IdLocation>^Bna.tableSQLintermidiareD</IdLocation>
<IndexLocation>^Bna.tableSQLintermidiareI</IndexLocation>
<StreamLocation>^Bna.tableSQLintermidiareS</StreamLocation>
<ExtentSize>0</ExtentSize>
<Data name="tableSQLintermidiareDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreNom</Value>
</Value>
<Value name="3">
<Value>CentreAdRue1</Value>
</Value>
<Value name="4">
<Value>CentreAdRue2</Value>
</Value>
<Value name="5">
<Value>CentreAdCp</Value>
</Value>
<Value name="6">
<Value>CentreAdVille</Value>
</Value>
<Value name="7">
<Value>CentreMail</Value>
</Value>
<Value name="8">
<Value>CentreType</Value>
</Value>
<Value name="9">
<Value>CentreNum</Value>
</Value>
<Value name="10">
<Value>CentreResponsable</Value>
</Value>
<Value name="11">
<Value>CentreLabel</Value>
</Value>
<Value name="12">
<Value>CentreLabelAnnee</Value>
</Value>
<Value name="13">
<Value>CentreReseau</Value>
</Value>
<Value name="14">
<Value>CentreNomReseau</Value>
</Value>
<Value name="15">
<Value>CentreInclusion</Value>
</Value>
<Value name="16">
<Value>CentreMultisite</Value>
</Value>
<Value name="17">
<Value>CentreHdj</Value>
</Value>
<Value name="18">
<Value>CentreOuvConsultation</Value>
</Value>
<Value name="19">
<Value>CentrePersoGeriatre</Value>
</Value>
<Value name="20">
<Value>CentrePersoNeurologue</Value>
</Value>
<Value name="21">
<Value>CentrePersoPsychiatre</Value>
</Value>
<Value name="22">
<Value>CentrePersoPsychologue</Value>
</Value>
<Value name="23">
<Value>CentrePersoOrthophoniste</Value>
</Value>
<Value name="24">
<Value>CentrePersoKine</Value>
</Value>
<Value name="25">
<Value>CentrePersoASocial</Value>
</Value>
<Value name="26">
<Value>CentrePersoSecretaire</Value>
</Value>
<Value name="27">
<Value>CentrePersoIDE</Value>
</Value>
<Value name="28">
<Value>CentrePersoARC</Value>
</Value>
<Value name="29">
<Value>CentrePersoTEC</Value>
</Value>
<Value name="30">
<Value>CentrePersoAutre</Value>
</Value>
<Value name="31">
<Value>CentrePersoDescriptionAutre</Value>
</Value>
<Value name="32">
<Value>CmrrPublications</Value>
</Value>
<Value name="33">
<Value>CmrrFormationsUniv</Value>
</Value>
<Value name="34">
<Value>enregistrement10</Value>
</Value>
<Value name="35">
<Value>CmrrActiviteAnimation</Value>
</Value>
<Value name="36">
<Value>CmrrActiviteRecherche</Value>
</Value>
<Value name="37">
<Value>CmrrActiviteEthique</Value>
</Value>
<Value name="38">
<Value>CmrrCmActiviteSoutien</Value>
</Value>
<Value name="39">
<Value>CmrrCmActiviteStimul</Value>
</Value>
<Value name="40">
<Value>ClTypeSpecialiste</Value>
</Value>
<Value name="41">
<Value>ClCollabNeuroPsy</Value>
</Value>
<Value name="42">
<Value>ClPratiqueETP</Value>
</Value>
<Value name="43">
<Value>ClActiviteConsultMemoire</Value>
</Value>
<Value name="44">
<Value>ClCollabCmCmrr</Value>
</Value>
<Value name="45">
<Value>ClActiviteReseau</Value>
</Value>
<Value name="46">
<Value>ClNbFormAn</Value>
</Value>
<Value name="47">
<Value>PatientId</Value>
</Value>
<Value name="48">
<Value>PatientSexe</Value>
</Value>
<Value name="49">
<Value>PatientAnneeNaissance</Value>
</Value>
<Value name="50">
<Value>PatientNiveauEtudes</Value>
</Value>
<Value name="51">
<Value>PatientSituationGeo</Value>
</Value>
<Value name="52">
<Value>atientEnvoyePar</Value>
</Value>
<Value name="53">
<Value>DclEtatDemence</Value>
</Value>
<Value name="54">
<Value>DclAnneePremierDiag</Value>
</Value>
<Value name="55">
<Value>DclDiagnostic</Value>
</Value>
<Value name="56">
<Value>DclTypeActe</Value>
</Value>
<Value name="57">
<Value>DclDateActe</Value>
</Value>
<Value name="58">
<Value>DclMMSE</Value>
</Value>
<Value name="59">
<Value>DclIADLDetection</Value>
</Value>
<Value name="60">
<Value>DclIADLConsequence</Value>
</Value>
<Value name="61">
<Value>DclModeDeVie</Value>
</Value>
<Value name="62">
<Value>DclAPA</Value>
</Value>
<Value name="63">
<Value>DclALD</Value>
</Value>
<Value name="64">
<Value>DclMesureProtection</Value>
</Value>
<Value name="65">
<Value>DclFinSuivi</Value>
</Value>
<Value name="66">
<Value>DclDateFinSuivi</Value>
</Value>
<Value name="67">
<Value>DclDateEntreeInstitution</Value>
</Value>
<Value name="68">
<Value>DclDateDeces</Value>
</Value>
<Value name="69">
<Value>DclTPAucun</Value>
</Value>
<Value name="70">
<Value>DclTPInhibAcetyl</Value>
</Value>
<Value name="71">
<Value>DclTPAntagonisteNMDA</Value>
</Value>
<Value name="72">
<Value>DclTPAntidepresseurs</Value>
</Value>
<Value name="73">
<Value>DclTPNeuroleptiques</Value>
</Value>
<Value name="74">
<Value>DclTPAnxiolitiques</Value>
</Value>
<Value name="75">
<Value>DclTPHypnotiques</Value>
</Value>
<Value name="76">
<Value>DclTPNootropes</Value>
</Value>
<Value name="77">
<Value>DclTPAutres</Value>
</Value>
<Value name="78">
<Value>DclTPAucunDansListe</Value>
</Value>
<Value name="79">
<Value>DclEffetIndesirable</Value>
</Value>
<Value name="80">
<Value>DclIPSRAucun</Value>
</Value>
<Value name="81">
<Value>DclIPSROrthophoniste</Value>
</Value>
<Value name="82">
<Value>DclIPSRPsychologue</Value>
</Value>
<Value name="83">
<Value>DclIPSRKinesitherapeute</Value>
</Value>
<Value name="84">
<Value>DclIPSRErgotherapeute</Value>
</Value>
<Value name="85">
<Value>DclIPSRGroupe</Value>
</Value>
<Value name="86">
<Value>DclIPSRAccueilJour</Value>
</Value>
<Value name="87">
<Value>DclIPSRMaia</Value>
</Value>
<Value name="88">
<Value>DclIPSRClic</Value>
</Value>
<Value name="89">
<Value>DclIPSRRepits</Value>
</Value>
<Value name="90">
<Value>DclIPSRSiad</Value>
</Value>
<Value name="91">
<Value>DclIPSRAutre</Value>
</Value>
<Value name="92">
<Value>DclPCAucun</Value>
</Value>
<Value name="93">
<Value>DclPCIRM</Value>
</Value>
<Value name="94">
<Value>DclPCScanner</Value>
</Value>
<Value name="95">
<Value>DclPCSPECT</Value>
</Value>
<Value name="96">
<Value>DclPCPET</Value>
</Value>
<Value name="97">
<Value>DclPCBioMarqueurs</Value>
</Value>
<Value name="98">
<Value>DclPR</Value>
</Value>
<Value name="99">
<Value>DclPRType</Value>
</Value>
<Value name="100">
<Value>DclPRVisite</Value>
</Value>
<Value name="101">
<Value>RetourMail</Value>
</Value>
<Value name="102">
<Value>PatientIdPrecedent</Value>
</Value>
<Value name="103">
<Value>Application</Value>
</Value>
<Value name="104">
<Value>CentreNumRmes</Value>
</Value>
<Value name="105">
<Value>CentreNumFiness</Value>
</Value>
<Value name="106">
<Value>CentreNumAdeli</Value>
</Value>
<Value name="107">
<Value>CentreNumRpps</Value>
</Value>
<Value name="108">
<Value>DclCmrrRecours</Value>
</Value>
<Value name="109">
<Value>DclCmrrRecoursDiagDiff</Value>
</Value>
<Value name="110">
<Value>DclCmrrRecoursSuivi</Value>
</Value>
<Value name="111">
<Value>DclCmrrRecoursPTech</Value>
</Value>
<Value name="112">
<Value>DclCmrrRecoursSpExpert</Value>
</Value>
<Value name="113">
<Value>PatientProfession</Value>
</Value>
<Value name="114">
<Value>PatientAccompagnant</Value>
</Value>
<Value name="115">
<Value>DclIPSREsad</Value>
</Value>
<Value name="116">
<Value>DclIPSRHdj</Value>
</Value>
<Value name="117">
<Value>DclIPSRUcc</Value>
</Value>
<Value name="118">
<Value>DclRechPresDispo</Value>
</Value>
<Value name="119">
<Value>DclRechAutonom</Value>
</Value>
<Value name="120">
<Value>DclRechContreIndic</Value>
</Value>
<Value name="121">
<Value>DclRechAcceptPlacebo</Value>
</Value>
<Value name="122">
<Value>DclDiagnosticN31</Value>
</Value>
<Value name="123">
<Value>DclDiagnosticN32</Value>
</Value>
<Value name="124">
<Value>DclDiagnosticN33</Value>
</Value>
<Value name="125">
<Value>DclPECAidant</Value>
</Value>
<Value name="126">
<Value>DclIPSRGardeMalade</Value>
</Value>
<Value name="127">
<Value>DclIPSRPAERPA</Value>
</Value>
<Value name="128">
<Value>DclTPAntiEpileptiques</Value>
</Value>
<Value name="129">
<Value>DclTPThymoRegulateurs</Value>
</Value>
<Value name="130">
<Value>DclTPAntiParkinsoniens</Value>
</Value>
<Value name="131">
<Value>DclTPAucunDebut</Value>
</Value>
<Value name="132">
<Value>DclTPInhibAcetylDebut</Value>
</Value>
<Value name="133">
<Value>DclTPAntagonisteNMDADebut</Value>
</Value>
<Value name="134">
<Value>DclTPAntidepresseursDebut</Value>
</Value>
<Value name="135">
<Value>DclTPNeuroleptiquesDebut</Value>
</Value>
<Value name="136">
<Value>DclTPAnxiolitiquesDebut</Value>
</Value>
<Value name="137">
<Value>DclTPHypnotiquesDebut</Value>
</Value>
<Value name="138">
<Value>DclTPNootropesDebut</Value>
</Value>
<Value name="139">
<Value>DclTPAntiEpileptiquesDebut</Value>
</Value>
<Value name="140">
<Value>DclTPThymoRegulateursDebut</Value>
</Value>
<Value name="141">
<Value>DclTPAntiParkinsoniensDebut</Value>
</Value>
<Value name="142">
<Value>DclTPAutresDebut</Value>
</Value>
<Value name="143">
<Value>DclTPAucunDansListeDebut</Value>
</Value>
<Value name="144">
<Value>DclTPAucunFin</Value>
</Value>
<Value name="145">
<Value>DclTPInhibAcetylFin</Value>
</Value>
<Value name="146">
<Value>DclTPAntagonisteNMDAFin</Value>
</Value>
<Value name="147">
<Value>DclTPAntidepresseursFin</Value>
</Value>
<Value name="148">
<Value>DclTPNeuroleptiquesFin</Value>
</Value>
<Value name="149">
<Value>DclTPAnxiolitiquesFin</Value>
</Value>
<Value name="150">
<Value>DclTPHypnotiquesFin</Value>
</Value>
<Value name="151">
<Value>DclTPNootropesFin</Value>
</Value>
<Value name="152">
<Value>DclTPAntiEpileptiquesFin</Value>
</Value>
<Value name="153">
<Value>DclTPThymoRegulateursFin</Value>
</Value>
<Value name="154">
<Value>DclTPAntiParkinsoniensFin</Value>
</Value>
<Value name="155">
<Value>DclTPAutresFin</Value>
</Value>
<Value name="156">
<Value>DclTPAucunDansListeFin</Value>
</Value>
<Value name="157">
<Value>DclTPAucunDebutPar</Value>
</Value>
<Value name="158">
<Value>DclTPInhibAcetylDebutPar</Value>
</Value>
<Value name="159">
<Value>DclTPAntagonisteNMDADebutPar</Value>
</Value>
<Value name="160">
<Value>DclTPAntidepresseursDebutPar</Value>
</Value>
<Value name="161">
<Value>DclTPNeuroleptiquesDebutPar</Value>
</Value>
<Value name="162">
<Value>DclTPAnxiolitiquesDebutPar</Value>
</Value>
<Value name="163">
<Value>DclTPHypnotiquesDebutPar</Value>
</Value>
<Value name="164">
<Value>DclTPNootropesDebutPar</Value>
</Value>
<Value name="165">
<Value>DclTPAntiEpileptiquesDebutPar</Value>
</Value>
<Value name="166">
<Value>DclTPThymoRegulateursDebutPar</Value>
</Value>
<Value name="167">
<Value>DclTPAntiParkinsoniensDebutPar</Value>
</Value>
<Value name="168">
<Value>DclTPAutresDebutPar</Value>
</Value>
<Value name="169">
<Value>DclTPAucunDansListeDebutPar</Value>
</Value>
<Value name="170">
<Value>DclTPAucunFinPar</Value>
</Value>
<Value name="171">
<Value>DclTPInhibAcetylFinPar</Value>
</Value>
<Value name="172">
<Value>DclTPAntagonisteNMDAFinPar</Value>
</Value>
<Value name="173">
<Value>DclTPAntidepresseursFinPar</Value>
</Value>
<Value name="174">
<Value>DclTPNeuroleptiquesFinPar</Value>
</Value>
<Value name="175">
<Value>DclTPAnxiolitiquesFinPar</Value>
</Value>
<Value name="176">
<Value>DclTPHypnotiquesFinPar</Value>
</Value>
<Value name="177">
<Value>DclTPNootropesFinPar</Value>
</Value>
<Value name="178">
<Value>DclTPAntiEpileptiquesFinPar</Value>
</Value>
<Value name="179">
<Value>DclTPThymoRegulateursFinPar</Value>
</Value>
<Value name="180">
<Value>DclTPAntiParkinsoniensFinPar</Value>
</Value>
<Value name="181">
<Value>DclTPAutresFinPar</Value>
</Value>
<Value name="182">
<Value>DclTPAucunDansListeFinPar</Value>
</Value>
<Value name="183">
<Value>DclTPAucunAvantPEC</Value>
</Value>
<Value name="184">
<Value>DclTPInhibAcetylAvantPEC</Value>
</Value>
<Value name="185">
<Value>DclTPAntagonisteNMDAAvantPEC</Value>
</Value>
<Value name="186">
<Value>DclTPAntidepresseursAvantPEC</Value>
</Value>
<Value name="187">
<Value>DclTPNeuroleptiquesAvantPEC</Value>
</Value>
<Value name="188">
<Value>DclTPAnxiolitiquesAvantPEC</Value>
</Value>
<Value name="189">
<Value>DclTPHypnotiquesAvantPEC</Value>
</Value>
<Value name="190">
<Value>DclTPNootropesAvantPEC</Value>
</Value>
<Value name="191">
<Value>DclTPAntiEpileptiquesAvantPEC</Value>
</Value>
<Value name="192">
<Value>DclTPThymoRegulateursAvantPEC</Value>
</Value>
<Value name="193">
<Value>DclTPAntiParkinsoniensAvantPEC</Value>
</Value>
<Value name="194">
<Value>DclTPAutresAvantPEC</Value>
</Value>
<Value name="195">
<Value>DclTPAucunDansListeAvantPEC</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Bna.testtableinsert">
<ClassType>persistent</ClassType>
<ProcedureBlock>0</ProcedureBlock>
<Super>Ens.Request</Super>
<TimeChanged>66529,46083.364730856</TimeChanged>
<TimeCreated>66528,57847.416271791</TimeCreated>

<Property name="nom">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Property name="nom3">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Property name="nom2">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Property name="prenom">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30"/>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>testtableinsertDefaultData</DefaultData>
<Data name="testtableinsertDefaultData">
<Structure>listnode</Structure>
<Subscript>"testtableinsert"</Subscript>
<Value name="1">
<Value>nom</Value>
</Value>
<Value name="2">
<Value>nom3</Value>
</Value>
<Value name="3">
<Value>nom2</Value>
</Value>
<Value name="4">
<Value>prenom</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="DTL.patienttofhirdtl">
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>66478,39055.318700062</TimeChanged>
<TimeCreated>66478,37366.500028146</TimeCreated>
<DependsOn>user.ListesItems,HS.SDA3.Container</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<Parameter name="TREATEMPTYREPEATINGFIELDASNULL">
<Default>0</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='user.ListesItems' targetClass='HS.SDA3.Container' create='new' language='objectscript' >
<assign value='"12345679"' property='target.Patient.MPIID' action='set' />
<assign value='source.ItemNom' property='target.Patient.Name.FamilyName' action='set' />
<assign value='source.ItemNomCourt' property='target.Patient.Name.GivenName' action='set' />
</transform>
]]></Data>
</XData>
</Class>


<Project name="EnsExportProduction_2023-03-08 14-12-18_144+0" LastModified="2023-03-08 14:14:44.979383895">
  <ProjectDescription>Studio Project generated from Production 'BNATESTPKG.FoundationProduction' at 2023-03-08 14:12:18.144 UTC</ProjectDescription>
  <Items>
    <ProjectItem name="BNATESTPKG.FoundationProduction" type="CLS"></ProjectItem>
    <ProjectItem name="BNAsql.ajouttableActes" type="CLS"></ProjectItem>
    <ProjectItem name="BNAsql.ajouttablePatientPravite" type="CLS"></ProjectItem>
    <ProjectItem name="BNAsql.insertintotableIntermidiare" type="CLS"></ProjectItem>
    <ProjectItem name="BNAsql.testinsertdanstabledetest2" type="CLS"></ProjectItem>
    <ProjectItem name="BNAtest.TBNAFHIRtestpractionner" type="CLS"></ProjectItem>
    <ProjectItem name="BPL.patienttofhir" type="CLS"></ProjectItem>
    <ProjectItem name="BPLBNA.BPLCSVBNA" type="CLS"></ProjectItem>
    <ProjectItem name="BPLBNA.ajoutdanssql" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.Actes" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.Centres" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.CentresAnnuels" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.Listes" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.ListesItems" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.Patients" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.PatientsPrivate" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.TraceActions" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.TraceMessages" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.Traitements" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.TraitementsActes" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.tableSQLintermidiare" type="CLS"></ProjectItem>
    <ProjectItem name="Bna.testtableinsert" type="CLS"></ProjectItem>
    <ProjectItem name="DTL.patienttofhirdtl" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.Application" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.Application.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdCp" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdCp.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdRue1" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdRue1.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdRue2" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdRue2.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdVille" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreAdVille.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreHdj" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreHdj.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreInclusion" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreInclusion.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreLabel" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreLabel.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreLabelAnnee" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreLabelAnnee.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreMail" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreMail.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreMultisite" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreMultisite.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNom" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNom.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNomReseau" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNomReseau.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNum" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNum.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumAdeli" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumAdeli.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumFiness" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumFiness.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumRmes" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumRmes.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumRpps" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreNumRpps.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreOuvConsultation" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreOuvConsultation.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoARC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoARC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoASocial" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoASocial.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoAutre" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoAutre.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoDescriptionAutre" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoDescriptionAutre.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoGeriatre" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoGeriatre.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoIDE" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoIDE.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoKine" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoKine.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoNeurologue" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoNeurologue.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoOrthophoniste" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoOrthophoniste.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoPsychiatre" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoPsychiatre.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoPsychologue" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoPsychologue.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoSecretaire" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoSecretaire.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoTEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentrePersoTEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreReseau" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreReseau.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreResponsable" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreResponsable.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreType" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CentreType.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClActiviteConsultMemoire" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClActiviteConsultMemoire.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClActiviteReseau" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClActiviteReseau.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClCollabCmCmrr" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClCollabCmCmrr.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClCollabNeuroPsy" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClCollabNeuroPsy.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClNbFormAn" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClNbFormAn.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClPratiqueETP" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClPratiqueETP.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClTypeSpecialiste" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.ClTypeSpecialiste.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteAnimation" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteAnimation.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteEthique" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteEthique.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteFormation" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteFormation.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteRecherche" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrActiviteRecherche.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrCmActiviteSoutien" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrCmActiviteSoutien.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrCmActiviteStimul" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrCmActiviteStimul.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrFormationsUniv" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrFormationsUniv.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrPublications" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.CmrrPublications.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclALD" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclALD.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclAPA" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclAPA.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclAnneePremierDiag" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclAnneePremierDiag.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecours" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecours.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursDiagDiff" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursDiagDiff.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursPTech" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursPTech.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursSpExpert" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursSpExpert.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursSuivi" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclCmrrRecoursSuivi.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateActe" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateActe.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateDeces" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateDeces.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateEntreeInstitution" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateEntreeInstitution.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateFinSuivi" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDateFinSuivi.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnostic" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnostic.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN31" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN31.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN32" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN32.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN33" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclDiagnosticN33.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclEffetIndesirable" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclEffetIndesirable.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclEtatDemence" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclEtatDemence.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclFinSuivi" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclFinSuivi.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIADLConsequence" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIADLConsequence.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIADLDetection" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIADLDetection.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAccueilJour" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAccueilJour.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAucun" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAucun.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAutre" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRAutre.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRClic" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRClic.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRErgotherapeute" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRErgotherapeute.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSREsad" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSREsad.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRGardeMalade" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRGardeMalade.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRGroupe" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRGroupe.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRHdj" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRHdj.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRKinesitherapeute" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRKinesitherapeute.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRMaia" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRMaia.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSROrthophoniste" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSROrthophoniste.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRPAERPA" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRPAERPA.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRPsychologue" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRPsychologue.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRRepits" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRRepits.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRSiad" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRSiad.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRUcc" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclIPSRUcc.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclMMSE" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclMMSE.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclMesureProtection" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclMesureProtection.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclModeDeVie" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclModeDeVie.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCAucun" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCAucun.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCBioMarqueurs" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCBioMarqueurs.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCIRM" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCIRM.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCPET" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCPET.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCSPECT" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCSPECT.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCScanner" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPCScanner.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPECAidant" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPECAidant.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPR" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPR.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPRType" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPRType.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPRVisite" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclPRVisite.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechAcceptPlacebo" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechAcceptPlacebo.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechAutonom" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechAutonom.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechContreIndic" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechContreIndic.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechPresDispo" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclRechPresDispo.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDA" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDA.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDADebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDADebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDADebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDADebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntagonisteNMDAFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiques" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiques.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiEpileptiquesFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniens" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniens.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntiParkinsoniensFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseurs" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseurs.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAntidepresseursFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiques" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiques.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAnxiolitiquesFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucun" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucun.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListe" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListe.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDansListeFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAucunFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutres" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutres.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPAutresFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiques" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiques.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPHypnotiquesFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetyl" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetyl.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPInhibAcetylFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiques" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiques.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNeuroleptiquesFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropes" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropes.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPNootropesFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateurs" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateurs.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursAvantPEC" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursAvantPEC.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursDebut" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursDebut.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursDebutPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursDebutPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursFin" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursFin.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursFinPar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTPThymoRegulateursFinPar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTypeActe" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.DclTypeActe.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientAccompagnant" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientAccompagnant.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientAnneeNaissance" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientAnneeNaissance.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientComplexeRecord" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientComplexeRecord.Batch" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientEnvoyePar" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientEnvoyePar.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientId" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientId.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientIdPrecedent" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientIdPrecedent.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientNiveauEtudes" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientNiveauEtudes.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientProfession" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientProfession.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientSexe" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientSexe.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientSituationGeo" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.PatientSituationGeo.Record" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.RetourMail" type="CLS"></ProjectItem>
    <ProjectItem name="Patientrecord.RetourMail.Record" type="CLS"></ProjectItem>
    <ProjectItem name="user.ListesItems" type="CLS"></ProjectItem>
    <ProjectItem name="user.patientlist" type="CLS"></ProjectItem>
    <ProjectItem name="Settings:EnsLib.RecordMap.Service.ComplexBatchFileService.PTD" type="PTD"></ProjectItem>
    <ProjectItem name="EnsExportNotes.EnsExportProduction_2023-03-08 14-12-18_144+0.PTD" type="PTD"></ProjectItem>
  </Items>
</Project>


<Class name="Patientrecord.Application">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.Application'
on 2023-03-08 at 13:47:41.417 [2023-03-08 13:47:41.417 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.417892136</TimeChanged>
<TimeCreated>66527,40625.123228502</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.Application.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "102-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("102-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.Application.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["102-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.Application" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.Application.Record" complexBatchManaged="1" label="102-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.Application.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.Application'
on 2023-03-08 at 13:47:41.412 [2023-03-08 13:47:41.412 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.438988841</TimeChanged>
<TimeCreated>66541,49661.412217435</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.Application.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Appli94A5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Appli94A5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Appli94A5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Appli94A5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreAdCp">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreAdCp'
on 2023-03-08 at 13:47:26.347 [2023-03-08 13:47:26.347 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.348124537</TimeChanged>
<TimeCreated>66477,55763.277148096</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreAdCp.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "004-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("004-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreAdCp.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["004-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreAdCp" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreAdCp.Record" complexBatchManaged="1" label="004-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreAdCp.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreAdCp'
on 2023-03-08 at 13:47:26.342 [2023-03-08 13:47:26.342 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.369415543</TimeChanged>
<TimeCreated>66541,49646.342326335</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreAdCp.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrB934.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrB934.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrB934.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrB934.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreAdRue1">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreAdRue1'
on 2023-03-08 at 13:47:26.037 [2023-03-08 13:47:26.037 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.037715654</TimeChanged>
<TimeCreated>66477,55550.21642484</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreAdRue1.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "002-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("002-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreAdRue1.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["002-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreAdRue1" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreAdRue1.Record" complexBatchManaged="1" label="002-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreAdRue1.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreAdRue1'
on 2023-03-08 at 13:47:26.031 [2023-03-08 13:47:26.031 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.05938706</TimeChanged>
<TimeCreated>66541,49646.031910552</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreAdRue1.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrCB28.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrCB28.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrCB28.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrCB28.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreAdRue2">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreAdRue2'
on 2023-03-08 at 13:47:26.193 [2023-03-08 13:47:26.193 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.193966496</TimeChanged>
<TimeCreated>66477,55652.692666126</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreAdRue2.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "003-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreAdRue2 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("003-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreAdRue2,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreAdRue2.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["003-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreAdRue2" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreAdRue2.Record" complexBatchManaged="1" label="003-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreAdRue2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreAdRue2.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreAdRue2'
on 2023-03-08 at 13:47:26.188 [2023-03-08 13:47:26.188 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.215277501</TimeChanged>
<TimeCreated>66541,49646.188159094</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreAdRue2">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreAdRue2.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrCA68.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrCA68.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrCA68.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrCA68.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreAdRue2</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreAdVille">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreAdVille'
on 2023-03-08 at 13:47:26.500 [2023-03-08 13:47:26.500 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.501613978</TimeChanged>
<TimeCreated>66477,55890.953351117</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreAdVille.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "005-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreAdVille = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("005-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreAdVille,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreAdVille.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["005-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreAdVille" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreAdVille.Record" complexBatchManaged="1" label="005-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreAdVille" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreAdVille.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreAdVille'
on 2023-03-08 at 13:47:26.495 [2023-03-08 13:47:26.495 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.522871284</TimeChanged>
<TimeCreated>66541,49646.495153776</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreAdVille">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreAdVille.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrF715.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrF715.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrF715.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrF715.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreAdVille</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreHdj">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreHdj'
on 2023-03-08 at 13:47:28.203 [2023-03-08 13:47:28.203 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.203800452</TimeChanged>
<TimeCreated>66526,49064.426306776</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreHdj.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "016-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreHdj = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("016-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreHdj,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreHdj.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["016-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreHdj" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreHdj.Record" complexBatchManaged="1" label="016-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreHdj" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreHdj.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreHdj'
on 2023-03-08 at 13:47:28.198 [2023-03-08 13:47:28.198 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.225337744</TimeChanged>
<TimeCreated>66541,49648.198046455</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreHdj">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreHdj.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr69C3.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr69C3.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr69C3.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr69C3.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreHdj</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreInclusion">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreInclusion'
on 2023-03-08 at 13:47:27.893 [2023-03-08 13:47:27.893 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.894457875</TimeChanged>
<TimeCreated>66526,48883.276099646</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreInclusion.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "014-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreInclusion = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("014-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreInclusion,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreInclusion.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["014-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreInclusion" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreInclusion.Record" complexBatchManaged="1" label="014-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreInclusion" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreInclusion.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreInclusion'
on 2023-03-08 at 13:47:27.888 [2023-03-08 13:47:27.888 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.915527967</TimeChanged>
<TimeCreated>66541,49647.888593077</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreInclusion">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreInclusion.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrF6BB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrF6BB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrF6BB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrF6BB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreInclusion</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreLabel">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreLabel'
on 2023-03-08 at 13:47:27.283 [2023-03-08 13:47:27.283 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.283757887</TimeChanged>
<TimeCreated>66477,56212.693365436</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreLabel.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "010-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreLabel = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("010-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreLabel,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreLabel.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["010-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreLabel" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreLabel.Record" complexBatchManaged="1" label="010-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreLabel" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreLabel.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreLabel'
on 2023-03-08 at 13:47:27.278 [2023-03-08 13:47:27.278 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.305305293</TimeChanged>
<TimeCreated>66541,49647.277977485</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreLabel">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreLabel.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr6DCB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr6DCB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr6DCB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr6DCB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreLabel</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreLabelAnnee">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreLabelAnnee'
on 2023-03-08 at 13:47:27.436 [2023-03-08 13:47:27.436 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.436886528</TimeChanged>
<TimeCreated>66477,56297.35426588</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreLabelAnnee.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "011-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreLabelAnnee = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("011-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreLabelAnnee,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreLabelAnnee.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["011-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreLabelAnnee" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreLabelAnnee.Record" complexBatchManaged="1" label="011-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreLabelAnnee" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreLabelAnnee.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreLabelAnnee'
on 2023-03-08 at 13:47:27.431 [2023-03-08 13:47:27.431 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.458194634</TimeChanged>
<TimeCreated>66541,49647.431077426</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreLabelAnnee">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreLabelAnnee.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr3D13.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr3D13.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr3D13.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr3D13.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreLabelAnnee</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreMail">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreMail'
on 2023-03-08 at 13:47:26.654 [2023-03-08 13:47:26.654 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.655171119</TimeChanged>
<TimeCreated>66477,46726.057272275</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreMail.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "006-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreMail = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("006-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreMail,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreMail.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["006-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreMail" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreMail.Record" complexBatchManaged="1" label="006-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreMail" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreMail.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreMail'
on 2023-03-08 at 13:47:26.649 [2023-03-08 13:47:26.649 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.680412026</TimeChanged>
<TimeCreated>66541,49646.649073817</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreMail">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreMail.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr4139.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr4139.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr4139.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr4139.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreMail</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreMultisite">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreMultisite'
on 2023-03-08 at 13:47:28.047 [2023-03-08 13:47:28.047 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.047861914</TimeChanged>
<TimeCreated>66526,48979.946564892</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreMultisite.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "015-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreMultisite = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("015-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreMultisite,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreMultisite.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["015-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreMultisite" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreMultisite.Record" complexBatchManaged="1" label="015-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreMultisite" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreMultisite.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreMultisite'
on 2023-03-08 at 13:47:28.042 [2023-03-08 13:47:28.042 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.069664305</TimeChanged>
<TimeCreated>66541,49648.042017116</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreMultisite">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreMultisite.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrA4AF.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrA4AF.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrA4AF.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrA4AF.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreMultisite</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNom">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNom'
on 2023-03-08 at 13:47:25.883 [2023-03-08 13:47:25.883 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49645.884613013</TimeChanged>
<TimeCreated>66477,55345.73989308</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNom.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "001-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreNom = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("001-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreNom,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNom.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["001-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNom" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNom.Record" complexBatchManaged="1" label="001-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreNom" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNom.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNom'
on 2023-03-08 at 13:47:25.878 [2023-03-08 13:47:25.878 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49645.905790019</TimeChanged>
<TimeCreated>66541,49645.878816411</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreNom">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNom.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr9A65.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr9A65.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr9A65.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr9A65.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreNom</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNomReseau">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNomReseau'
on 2023-03-08 at 13:47:27.740 [2023-03-08 13:47:27.740 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.741277036</TimeChanged>
<TimeCreated>66526,48770.816331502</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNomReseau.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "013-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreNomReseau = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("013-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreNomReseau,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNomReseau.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["013-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNomReseau" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNomReseau.Record" complexBatchManaged="1" label="013-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreNomReseau" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNomReseau.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNomReseau'
on 2023-03-08 at 13:47:27.735 [2023-03-08 13:47:27.735 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.762377727</TimeChanged>
<TimeCreated>66541,49647.735483138</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreNomReseau">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNomReseau.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrBFF2.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrBFF2.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrBFF2.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrBFF2.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreNomReseau</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNum">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNum'
on 2023-03-08 at 13:47:26.971 [2023-03-08 13:47:26.971 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.972440304</TimeChanged>
<TimeCreated>66477,47033.395652903</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNum.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "008-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreNum = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("008-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreNum,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNum.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["008-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNum" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNum.Record" complexBatchManaged="1" label="008-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreNum" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNum.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNum'
on 2023-03-08 at 13:47:26.966 [2023-03-08 13:47:26.966 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.99706981</TimeChanged>
<TimeCreated>66541,49646.966671602</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreNum">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNum.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrFA6E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrFA6E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrFA6E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrFA6E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreNum</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNumAdeli">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNumAdeli'
on 2023-03-08 at 13:47:41.879 [2023-03-08 13:47:41.879 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.880640451</TimeChanged>
<TimeCreated>66527,48776.60421412</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNumAdeli.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "105-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("105-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNumAdeli.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["105-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNumAdeli" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNumAdeli.Record" complexBatchManaged="1" label="105-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNumAdeli.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNumAdeli'
on 2023-03-08 at 13:47:41.874 [2023-03-08 13:47:41.874 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.902270056</TimeChanged>
<TimeCreated>66541,49661.874904749</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNumAdeli.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr1F07.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr1F07.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr1F07.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr1F07.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNumFiness">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNumFiness'
on 2023-03-08 at 13:47:41.725 [2023-03-08 13:47:41.725 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.726582413</TimeChanged>
<TimeCreated>66527,48719.252649917</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNumFiness.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "104-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("104-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNumFiness.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["104-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNumFiness" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNumFiness.Record" complexBatchManaged="1" label="104-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNumFiness.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNumFiness'
on 2023-03-08 at 13:47:41.720 [2023-03-08 13:47:41.720 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.747693218</TimeChanged>
<TimeCreated>66541,49661.720898711</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNumFiness.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr17EA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr17EA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr17EA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr17EA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNumRmes">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNumRmes'
on 2023-03-08 at 13:47:41.569 [2023-03-08 13:47:41.569 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.570546574</TimeChanged>
<TimeCreated>66527,48658.001968033</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNumRmes.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "103-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("103-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNumRmes.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["103-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNumRmes" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNumRmes.Record" complexBatchManaged="1" label="103-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNumRmes.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNumRmes'
on 2023-03-08 at 13:47:41.564 [2023-03-08 13:47:41.564 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.59447618</TimeChanged>
<TimeCreated>66541,49661.564842172</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNumRmes.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centre9D7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centre9D7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centre9D7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centre9D7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreNumRpps">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreNumRpps'
on 2023-03-08 at 13:47:42.036 [2023-03-08 13:47:42.036 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.03747449</TimeChanged>
<TimeCreated>66527,48839.663321905</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreNumRpps.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "106-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("106-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreNumRpps.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["106-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreNumRpps" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreNumRpps.Record" complexBatchManaged="1" label="106-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreNumRpps.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreNumRpps'
on 2023-03-08 at 13:47:42.031 [2023-03-08 13:47:42.031 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.058997695</TimeChanged>
<TimeCreated>66541,49662.031767688</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreNumRpps.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr9F49.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr9F49.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr9F49.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr9F49.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreOuvConsultation">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreOuvConsultation'
on 2023-03-08 at 13:47:28.359 [2023-03-08 13:47:28.359 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.36086509</TimeChanged>
<TimeCreated>66526,49157.204151288</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreOuvConsultation.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "017-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreOuvConsultation = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("017-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreOuvConsultation,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreOuvConsultation.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["017-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreOuvConsultation" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreOuvConsultation.Record" complexBatchManaged="1" label="017-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreOuvConsultation" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreOuvConsultation.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreOuvConsultation'
on 2023-03-08 at 13:47:28.353 [2023-03-08 13:47:28.353 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.382061082</TimeChanged>
<TimeCreated>66541,49648.353672993</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreOuvConsultation">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreOuvConsultation.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr51CD.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr51CD.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr51CD.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr51CD.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreOuvConsultation</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoARC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoARC'
on 2023-03-08 at 13:47:29.898 [2023-03-08 13:47:29.898 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.89887888</TimeChanged>
<TimeCreated>66526,49968.567867941</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoARC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "027-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoARC = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("027-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoARC,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoARC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["027-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoARC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoARC.Record" complexBatchManaged="1" label="027-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoARC" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoARC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoARC'
on 2023-03-08 at 13:47:29.893 [2023-03-08 13:47:29.893 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.919941872</TimeChanged>
<TimeCreated>66541,49649.893116282</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoARC">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoARC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr657E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr657E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr657E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr657E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoARC</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoASocial">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoASocial'
on 2023-03-08 at 13:47:29.438 [2023-03-08 13:47:29.438 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.438813563</TimeChanged>
<TimeCreated>66526,49741.157771369</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoASocial.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "024-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoASocial = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("024-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoASocial,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoASocial.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["024-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoASocial" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoASocial.Record" complexBatchManaged="1" label="024-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoASocial" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoASocial.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoASocial'
on 2023-03-08 at 13:47:29.432 [2023-03-08 13:47:29.432 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.460376054</TimeChanged>
<TimeCreated>66541,49649.432860065</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoASocial">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoASocial.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrC57F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrC57F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrC57F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrC57F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoASocial</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoAutre">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoAutre'
on 2023-03-08 at 13:47:30.202 [2023-03-08 13:47:30.202 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.203228959</TimeChanged>
<TimeCreated>66526,50124.789127695</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoAutre.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "029-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoAutre = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("029-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoAutre,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoAutre.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["029-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoAutre" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoAutre.Record" complexBatchManaged="1" label="029-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoAutre" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoAutre.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoAutre'
on 2023-03-08 at 13:47:30.197 [2023-03-08 13:47:30.197 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.224402751</TimeChanged>
<TimeCreated>66541,49650.197387262</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoAutre">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoAutre.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr7ABE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr7ABE.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr7ABE.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr7ABE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoAutre</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoDescriptionAutre">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoDescriptionAutre'
on 2023-03-08 at 13:47:30.355 [2023-03-08 13:47:30.355 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.356330599</TimeChanged>
<TimeCreated>66526,50219.184627116</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoDescriptionAutre.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "030-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoDescriptionAutre = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("030-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoDescriptionAutre,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoDescriptionAutre.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["030-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoDescriptionAutre" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoDescriptionAutre.Record" complexBatchManaged="1" label="030-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoDescriptionAutre" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoDescriptionAutre.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoDescriptionAutre'
on 2023-03-08 at 13:47:30.350 [2023-03-08 13:47:30.350 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.37773029</TimeChanged>
<TimeCreated>66541,49650.350460901</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoDescriptionAutre">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoDescriptionAutre.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr70CB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr70CB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr70CB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr70CB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoDescriptionAutre</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoGeriatre">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoGeriatre'
on 2023-03-08 at 13:47:28.513 [2023-03-08 13:47:28.513 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.514058029</TimeChanged>
<TimeCreated>66526,49257.172270774</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoGeriatre.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "018-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoGeriatre = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("018-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoGeriatre,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoGeriatre.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["018-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoGeriatre" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoGeriatre.Record" complexBatchManaged="1" label="018-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoGeriatre" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoGeriatre.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoGeriatre'
on 2023-03-08 at 13:47:28.507 [2023-03-08 13:47:28.507 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.535861721</TimeChanged>
<TimeCreated>66541,49648.507945732</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoGeriatre">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoGeriatre.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr6A13.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr6A13.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr6A13.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr6A13.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoGeriatre</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoIDE">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoIDE'
on 2023-03-08 at 13:47:29.744 [2023-03-08 13:47:29.744 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.745414141</TimeChanged>
<TimeCreated>66526,49903.702199652</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoIDE.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "026-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoIDE = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("026-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoIDE,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoIDE.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["026-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoIDE" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoIDE.Record" complexBatchManaged="1" label="026-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoIDE" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoIDE.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoIDE'
on 2023-03-08 at 13:47:29.739 [2023-03-08 13:47:29.739 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.766562433</TimeChanged>
<TimeCreated>66541,49649.739636243</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoIDE">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoIDE.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrC571.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrC571.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrC571.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrC571.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoIDE</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoKine">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoKine'
on 2023-03-08 at 13:47:29.285 [2023-03-08 13:47:29.285 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.285998123</TimeChanged>
<TimeCreated>66526,49679.543412265</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoKine.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "023-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoKine = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("023-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoKine,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoKine.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["023-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoKine" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoKine.Record" complexBatchManaged="1" label="023-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoKine" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoKine.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoKine'
on 2023-03-08 at 13:47:29.279 [2023-03-08 13:47:29.279 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.307367415</TimeChanged>
<TimeCreated>66541,49649.279293626</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoKine">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoKine.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr4E4A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr4E4A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr4E4A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr4E4A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoKine</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoNeurologue">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoNeurologue'
on 2023-03-08 at 13:47:28.667 [2023-03-08 13:47:28.667 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.668340368</TimeChanged>
<TimeCreated>66526,49332.452240703</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoNeurologue.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "019-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoNeurologue = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("019-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoNeurologue,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoNeurologue.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["019-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoNeurologue" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoNeurologue.Record" complexBatchManaged="1" label="019-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoNeurologue" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoNeurologue.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoNeurologue'
on 2023-03-08 at 13:47:28.662 [2023-03-08 13:47:28.662 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.68959266</TimeChanged>
<TimeCreated>66541,49648.66246497</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoNeurologue">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoNeurologue.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrECD7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrECD7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrECD7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrECD7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoNeurologue</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoOrthophoniste">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoOrthophoniste'
on 2023-03-08 at 13:47:29.130 [2023-03-08 13:47:29.130 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.131462684</TimeChanged>
<TimeCreated>66526,49600.131005935</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoOrthophoniste.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "022-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoOrthophoniste = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("022-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoOrthophoniste,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoOrthophoniste.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["022-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoOrthophoniste" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoOrthophoniste.Record" complexBatchManaged="1" label="022-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoOrthophoniste" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoOrthophoniste.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoOrthophoniste'
on 2023-03-08 at 13:47:29.125 [2023-03-08 13:47:29.125 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.152871676</TimeChanged>
<TimeCreated>66541,49649.125595187</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoOrthophoniste">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoOrthophoniste.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr77E8.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr77E8.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr77E8.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr77E8.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoOrthophoniste</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoPsychiatre">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoPsychiatre'
on 2023-03-08 at 13:47:28.823 [2023-03-08 13:47:28.823 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.824502506</TimeChanged>
<TimeCreated>66526,49424.227999777</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoPsychiatre.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "020-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoPsychiatre = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("020-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoPsychiatre,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoPsychiatre.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["020-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoPsychiatre" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoPsychiatre.Record" complexBatchManaged="1" label="020-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoPsychiatre" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoPsychiatre.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoPsychiatre'
on 2023-03-08 at 13:47:28.818 [2023-03-08 13:47:28.818 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.845566998</TimeChanged>
<TimeCreated>66541,49648.818626308</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoPsychiatre">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoPsychiatre.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr126C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr126C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr126C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr126C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoPsychiatre</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoPsychologue">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoPsychologue'
on 2023-03-08 at 13:47:28.977 [2023-03-08 13:47:28.977 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49648.978123645</TimeChanged>
<TimeCreated>66526,49516.327213488</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoPsychologue.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "021-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoPsychologue = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("021-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoPsychologue,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoPsychologue.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["021-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoPsychologue" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoPsychologue.Record" complexBatchManaged="1" label="021-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoPsychologue" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoPsychologue.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoPsychologue'
on 2023-03-08 at 13:47:28.972 [2023-03-08 13:47:28.972 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49648.999415037</TimeChanged>
<TimeCreated>66541,49648.972210148</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoPsychologue">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoPsychologue.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr41E5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr41E5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr41E5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr41E5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoPsychologue</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoSecretaire">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoSecretaire'
on 2023-03-08 at 13:47:29.592 [2023-03-08 13:47:29.592 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49649.592802601</TimeChanged>
<TimeCreated>66526,49812.27203953</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoSecretaire.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "025-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoSecretaire = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("025-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoSecretaire,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoSecretaire.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["025-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoSecretaire" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoSecretaire.Record" complexBatchManaged="1" label="025-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoSecretaire" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoSecretaire.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoSecretaire'
on 2023-03-08 at 13:47:29.586 [2023-03-08 13:47:29.586 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49649.613956793</TimeChanged>
<TimeCreated>66541,49649.586893204</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoSecretaire">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoSecretaire.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr1687.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr1687.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr1687.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr1687.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoSecretaire</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentrePersoTEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentrePersoTEC'
on 2023-03-08 at 13:47:30.050 [2023-03-08 13:47:30.050 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.05093332</TimeChanged>
<TimeCreated>66526,50049.674949628</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentrePersoTEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "028-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentrePersoTEC = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("028-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentrePersoTEC,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentrePersoTEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["028-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentrePersoTEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentrePersoTEC.Record" complexBatchManaged="1" label="028-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentrePersoTEC" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentrePersoTEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentrePersoTEC'
on 2023-03-08 at 13:47:30.045 [2023-03-08 13:47:30.045 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.071855212</TimeChanged>
<TimeCreated>66541,49650.045157022</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentrePersoTEC">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentrePersoTEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr5160.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr5160.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr5160.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr5160.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentrePersoTEC</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreReseau">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreReseau'
on 2023-03-08 at 13:47:27.588 [2023-03-08 13:47:27.588 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.589482869</TimeChanged>
<TimeCreated>66526,48644.021152361</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreReseau.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "012-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreReseau = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("012-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreReseau,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreReseau.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["012-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreReseau" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreReseau.Record" complexBatchManaged="1" label="012-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreReseau" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreReseau.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreReseau'
on 2023-03-08 at 13:47:27.583 [2023-03-08 13:47:27.583 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.610412474</TimeChanged>
<TimeCreated>66541,49647.583685767</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreReseau">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreReseau.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CentrA21E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CentrA21E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CentrA21E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CentrA21E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreReseau</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreResponsable">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreResponsable'
on 2023-03-08 at 13:47:27.128 [2023-03-08 13:47:27.128 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49647.129422046</TimeChanged>
<TimeCreated>66477,56114.72132025</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreResponsable.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "009-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreResponsable = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("009-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreResponsable,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreResponsable.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["009-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreResponsable" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreResponsable.Record" complexBatchManaged="1" label="009-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreResponsable" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreResponsable.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreResponsable'
on 2023-03-08 at 13:47:27.123 [2023-03-08 13:47:27.123 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49647.150940251</TimeChanged>
<TimeCreated>66541,49647.123605644</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreResponsable">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreResponsable.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr60F0.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr60F0.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr60F0.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr60F0.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreResponsable</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CentreType">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CentreType'
on 2023-03-08 at 13:47:26.817 [2023-03-08 13:47:26.817 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49646.818016662</TimeChanged>
<TimeCreated>66477,55998.812295689</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CentreType.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "007-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CentreType = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("007-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CentreType,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CentreType.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["007-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CentreType" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CentreType.Record" complexBatchManaged="1" label="007-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CentreType" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CentreType.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CentreType'
on 2023-03-08 at 13:47:26.812 [2023-03-08 13:47:26.812 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49646.840281268</TimeChanged>
<TimeCreated>66541,49646.812251161</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CentreType">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CentreType.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Centr8C75.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Centr8C75.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Centr8C75.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Centr8C75.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreType</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClActiviteConsultMemoire">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClActiviteConsultMemoire'
on 2023-03-08 at 13:47:32.204 [2023-03-08 13:47:32.204 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.205307066</TimeChanged>
<TimeCreated>66526,51331.725374919</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClActiviteConsultMemoire.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "042-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClActiviteConsultMemoire = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("042-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClActiviteConsultMemoire,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClActiviteConsultMemoire.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["042-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClActiviteConsultMemoire" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClActiviteConsultMemoire.Record" complexBatchManaged="1" label="042-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClActiviteConsultMemoire" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClActiviteConsultMemoire.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClActiviteConsultMemoire'
on 2023-03-08 at 13:47:32.199 [2023-03-08 13:47:32.199 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.226347057</TimeChanged>
<TimeCreated>66541,49652.199400068</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClActiviteConsultMemoire">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClActiviteConsultMemoire.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClAct1615.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClAct1615.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClAct1615.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClAct1615.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClActiviteConsultMemoire</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClActiviteReseau">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClActiviteReseau'
on 2023-03-08 at 13:47:32.512 [2023-03-08 13:47:32.512 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.513221943</TimeChanged>
<TimeCreated>66526,51450.954579232</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClActiviteReseau.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "044-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClActiviteReseau = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("044-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClActiviteReseau,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClActiviteReseau.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["044-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClActiviteReseau" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClActiviteReseau.Record" complexBatchManaged="1" label="044-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClActiviteReseau" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClActiviteReseau.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClActiviteReseau'
on 2023-03-08 at 13:47:32.507 [2023-03-08 13:47:32.507 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.534391735</TimeChanged>
<TimeCreated>66541,49652.507409746</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClActiviteReseau">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClActiviteReseau.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClAct1930.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClAct1930.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClAct1930.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClAct1930.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClActiviteReseau</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClCollabCmCmrr">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClCollabCmCmrr'
on 2023-03-08 at 13:47:32.357 [2023-03-08 13:47:32.357 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.358282005</TimeChanged>
<TimeCreated>66526,51393.301565142</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClCollabCmCmrr.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "043-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClCollabCmCmrr = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("043-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClCollabCmCmrr,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClCollabCmCmrr.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["043-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClCollabCmCmrr" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClCollabCmCmrr.Record" complexBatchManaged="1" label="043-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClCollabCmCmrr" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClCollabCmCmrr.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClCollabCmCmrr'
on 2023-03-08 at 13:47:32.352 [2023-03-08 13:47:32.352 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.380216096</TimeChanged>
<TimeCreated>66541,49652.352478507</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClCollabCmCmrr">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClCollabCmCmrr.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClCol627D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClCol627D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClCol627D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClCol627D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClCollabCmCmrr</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClCollabNeuroPsy">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClCollabNeuroPsy'
on 2023-03-08 at 13:47:31.897 [2023-03-08 13:47:31.897 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.898094687</TimeChanged>
<TimeCreated>66526,50878.265836798</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClCollabNeuroPsy.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "040-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClCollabNeuroPsy = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("040-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClCollabNeuroPsy,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClCollabNeuroPsy.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["040-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClCollabNeuroPsy" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClCollabNeuroPsy.Record" complexBatchManaged="1" label="040-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClCollabNeuroPsy" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClCollabNeuroPsy.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClCollabNeuroPsy'
on 2023-03-08 at 13:47:31.892 [2023-03-08 13:47:31.892 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.919269279</TimeChanged>
<TimeCreated>66541,49651.89232329</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClCollabNeuroPsy">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClCollabNeuroPsy.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClColla3A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClColla3A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClColla3A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClColla3A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClCollabNeuroPsy</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClNbFormAn">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClNbFormAn'
on 2023-03-08 at 13:47:32.665 [2023-03-08 13:47:32.665 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.666514883</TimeChanged>
<TimeCreated>66526,51504.661639892</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClNbFormAn.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "045-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClNbFormAn = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("045-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClNbFormAn,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClNbFormAn.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["045-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClNbFormAn" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClNbFormAn.Record" complexBatchManaged="1" label="045-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClNbFormAn" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClNbFormAn.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClNbFormAn'
on 2023-03-08 at 13:47:32.660 [2023-03-08 13:47:32.660 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.687511174</TimeChanged>
<TimeCreated>66541,49652.660745985</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClNbFormAn">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClNbFormAn.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClNbF6BE9.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClNbF6BE9.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClNbF6BE9.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClNbF6BE9.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClNbFormAn</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClPratiqueETP">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClPratiqueETP'
on 2023-03-08 at 13:47:32.050 [2023-03-08 13:47:32.050 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.051530326</TimeChanged>
<TimeCreated>66526,50944.924139738</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClPratiqueETP.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "041-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClPratiqueETP = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("041-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClPratiqueETP,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClPratiqueETP.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["041-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClPratiqueETP" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClPratiqueETP.Record" complexBatchManaged="1" label="041-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClPratiqueETP" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClPratiqueETP.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClPratiqueETP'
on 2023-03-08 at 13:47:32.045 [2023-03-08 13:47:32.045 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.073188918</TimeChanged>
<TimeCreated>66541,49652.045736629</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClPratiqueETP">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClPratiqueETP.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClPraA355.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClPraA355.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClPraA355.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClPraA355.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClPratiqueETP</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.ClTypeSpecialiste">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.ClTypeSpecialiste'
on 2023-03-08 at 13:47:31.744 [2023-03-08 13:47:31.744 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.744802748</TimeChanged>
<TimeCreated>66526,50801.714352169</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.ClTypeSpecialiste.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "039-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.ClTypeSpecialiste = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("039-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.ClTypeSpecialiste,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.ClTypeSpecialiste.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["039-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.ClTypeSpecialiste" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.ClTypeSpecialiste.Record" complexBatchManaged="1" label="039-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="ClTypeSpecialiste" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.ClTypeSpecialiste.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.ClTypeSpecialiste'
on 2023-03-08 at 13:47:31.738 [2023-03-08 13:47:31.738 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.76608454</TimeChanged>
<TimeCreated>66541,49651.73894585</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="ClTypeSpecialiste">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.ClTypeSpecialiste.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.ClTypF29E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.ClTypF29E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.ClTypF29E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.ClTypF29E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClTypeSpecialiste</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrActiviteAnimation">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrActiviteAnimation'
on 2023-03-08 at 13:47:30.973 [2023-03-08 13:47:30.973 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.974036854</TimeChanged>
<TimeCreated>66526,50474.281915127</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrActiviteAnimation.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "034-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrActiviteAnimation = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("034-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrActiviteAnimation,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrActiviteAnimation.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["034-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrActiviteAnimation" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrActiviteAnimation.Record" complexBatchManaged="1" label="034-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrActiviteAnimation" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrActiviteAnimation.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrActiviteAnimation'
on 2023-03-08 at 13:47:30.968 [2023-03-08 13:47:30.968 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.995156545</TimeChanged>
<TimeCreated>66541,49650.968196256</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrActiviteAnimation">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrActiviteAnimation.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrAE0D9.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrAE0D9.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrAE0D9.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrAE0D9.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrActiviteAnimation</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrActiviteEthique">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrActiviteEthique'
on 2023-03-08 at 13:47:31.278 [2023-03-08 13:47:31.278 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.279605633</TimeChanged>
<TimeCreated>66526,50603.803215818</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrActiviteEthique.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "036-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrActiviteEthique = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("036-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrActiviteEthique,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrActiviteEthique.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["036-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrActiviteEthique" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrActiviteEthique.Record" complexBatchManaged="1" label="036-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrActiviteEthique" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrActiviteEthique.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrActiviteEthique'
on 2023-03-08 at 13:47:31.273 [2023-03-08 13:47:31.273 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.300950324</TimeChanged>
<TimeCreated>66541,49651.273733435</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrActiviteEthique">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrActiviteEthique.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrAcACB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrAcACB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrAcACB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrAcACB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrActiviteEthique</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrActiviteFormation">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrActiviteFormation'
on 2023-03-08 at 13:47:30.820 [2023-03-08 13:47:30.820 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.821062114</TimeChanged>
<TimeCreated>66526,50406.660009283</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrActiviteFormation.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "033-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrActiviteFormation = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("033-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrActiviteFormation,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrActiviteFormation.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["033-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrActiviteFormation" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrActiviteFormation.Record" complexBatchManaged="1" label="033-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrActiviteFormation" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrActiviteFormation.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrActiviteFormation'
on 2023-03-08 at 13:47:30.815 [2023-03-08 13:47:30.815 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.842220106</TimeChanged>
<TimeCreated>66541,49650.815190517</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrActiviteFormation">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrActiviteFormation.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrA1D95.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrA1D95.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrA1D95.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrA1D95.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrActiviteFormation</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrActiviteRecherche">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrActiviteRecherche'
on 2023-03-08 at 13:47:31.126 [2023-03-08 13:47:31.126 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.126945693</TimeChanged>
<TimeCreated>66526,50536.301904508</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrActiviteRecherche.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "035-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrActiviteRecherche = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("035-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrActiviteRecherche,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrActiviteRecherche.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["035-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrActiviteRecherche" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrActiviteRecherche.Record" complexBatchManaged="1" label="035-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrActiviteRecherche" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrActiviteRecherche.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrActiviteRecherche'
on 2023-03-08 at 13:47:31.121 [2023-03-08 13:47:31.121 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.148200885</TimeChanged>
<TimeCreated>66541,49651.121066595</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrActiviteRecherche">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrActiviteRecherche.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrA8B79.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrA8B79.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrA8B79.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrA8B79.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrActiviteRecherche</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrCmActiviteSoutien">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrCmActiviteSoutien'
on 2023-03-08 at 13:47:31.432 [2023-03-08 13:47:31.432 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.433228472</TimeChanged>
<TimeCreated>66526,50668.186974995</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrCmActiviteSoutien.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "037-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrCmActiviteSoutien = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("037-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrCmActiviteSoutien,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrCmActiviteSoutien.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["037-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrCmActiviteSoutien" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrCmActiviteSoutien.Record" complexBatchManaged="1" label="037-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrCmActiviteSoutien" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrCmActiviteSoutien.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrCmActiviteSoutien'
on 2023-03-08 at 13:47:31.427 [2023-03-08 13:47:31.427 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.454374863</TimeChanged>
<TimeCreated>66541,49651.427311674</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrCmActiviteSoutien">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrCmActiviteSoutien.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrC9C48.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrC9C48.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrC9C48.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrC9C48.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrCmActiviteSoutien</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrCmActiviteStimul">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrCmActiviteStimul'
on 2023-03-08 at 13:47:31.585 [2023-03-08 13:47:31.585 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49651.586579711</TimeChanged>
<TimeCreated>66526,50743.022657042</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrCmActiviteStimul.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "038-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrCmActiviteStimul = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("038-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrCmActiviteStimul,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrCmActiviteStimul.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["038-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrCmActiviteStimul" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrCmActiviteStimul.Record" complexBatchManaged="1" label="038-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrCmActiviteStimul" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrCmActiviteStimul.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrCmActiviteStimul'
on 2023-03-08 at 13:47:31.580 [2023-03-08 13:47:31.580 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49651.607964002</TimeChanged>
<TimeCreated>66541,49651.580703013</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrCmActiviteStimul">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrCmActiviteStimul.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrCDAC4.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrCDAC4.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrCDAC4.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrCDAC4.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrCmActiviteStimul</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrFormationsUniv">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrFormationsUniv'
on 2023-03-08 at 13:47:30.666 [2023-03-08 13:47:30.666 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.667042876</TimeChanged>
<TimeCreated>66526,50342.525297626</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrFormationsUniv.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "032-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrFormationsUniv = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("032-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrFormationsUniv,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrFormationsUniv.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["032-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrFormationsUniv" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrFormationsUniv.Record" complexBatchManaged="1" label="032-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrFormationsUniv" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrFormationsUniv.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrFormationsUniv'
on 2023-03-08 at 13:47:30.661 [2023-03-08 13:47:30.661 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.688492167</TimeChanged>
<TimeCreated>66541,49650.661216678</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrFormationsUniv">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrFormationsUniv.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrFC57D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrFC57D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrFC57D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrFC57D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrFormationsUniv</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.CmrrPublications">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.CmrrPublications'
on 2023-03-08 at 13:47:30.512 [2023-03-08 13:47:30.512 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49650.513541336</TimeChanged>
<TimeCreated>66526,50289.691370877</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.CmrrPublications.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "031-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.CmrrPublications = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("031-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.CmrrPublications,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.CmrrPublications.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["031-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.CmrrPublications" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.CmrrPublications.Record" complexBatchManaged="1" label="031-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="CmrrPublications" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.CmrrPublications.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.CmrrPublications'
on 2023-03-08 at 13:47:30.507 [2023-03-08 13:47:30.507 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49650.534792028</TimeChanged>
<TimeCreated>66541,49650.507676339</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="CmrrPublications">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.CmrrPublications.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.CmrrP7667.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.CmrrP7667.RecordD</IdLocation>
<IndexLocation>^Patientrecord.CmrrP7667.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.CmrrP7667.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CmrrPublications</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclALD">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclALD'
on 2023-03-08 at 13:47:35.279 [2023-03-08 13:47:35.279 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.280660746</TimeChanged>
<TimeCreated>66527,36228.057310104</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclALD.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "062-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("062-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclALD.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["062-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclALD" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclALD.Record" complexBatchManaged="1" label="062-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclALD.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclALD'
on 2023-03-08 at 13:47:35.275 [2023-03-08 13:47:35.275 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.301430338</TimeChanged>
<TimeCreated>66541,49655.275002848</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclALD.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclALD.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclALD.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclALD.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclALD.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclAPA">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclAPA'
on 2023-03-08 at 13:47:35.120 [2023-03-08 13:47:35.120 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.121001309</TimeChanged>
<TimeCreated>66527,36173.799945191</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclAPA.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "061-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("061-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclAPA.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["061-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclAPA" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclAPA.Record" complexBatchManaged="1" label="061-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclAPA.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclAPA'
on 2023-03-08 at 13:47:35.115 [2023-03-08 13:47:35.115 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.1440681</TimeChanged>
<TimeCreated>66541,49655.115293112</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclAPA.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclAPA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclAPA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclAPA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclAPA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclAnneePremierDiag">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclAnneePremierDiag'
on 2023-03-08 at 13:47:33.890 [2023-03-08 13:47:33.890 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.891708697</TimeChanged>
<TimeCreated>66527,35517.325395742</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclAnneePremierDiag.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "053-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("053-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclAnneePremierDiag.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["053-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclAnneePremierDiag" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclAnneePremierDiag.Record" complexBatchManaged="1" label="053-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclAnneePremierDiag.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclAnneePremierDiag'
on 2023-03-08 at 13:47:33.885 [2023-03-08 13:47:33.885 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.912696288</TimeChanged>
<TimeCreated>66541,49653.885863699</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclAnneePremierDiag.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclAn23DA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclAn23DA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclAn23DA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclAn23DA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclCmrrRecours">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclCmrrRecours'
on 2023-03-08 at 13:47:42.191 [2023-03-08 13:47:42.191 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.191696428</TimeChanged>
<TimeCreated>66527,48934.895451989</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclCmrrRecours.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "107-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("107-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclCmrrRecours.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["107-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclCmrrRecours" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclCmrrRecours.Record" complexBatchManaged="1" label="107-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclCmrrRecours.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclCmrrRecours'
on 2023-03-08 at 13:47:42.185 [2023-03-08 13:47:42.185 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.212784533</TimeChanged>
<TimeCreated>66541,49662.185938726</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclCmrrRecours.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclCm7EE8.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclCm7EE8.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclCm7EE8.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclCm7EE8.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclCmrrRecoursDiagDiff">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclCmrrRecoursDiagDiff'
on 2023-03-08 at 13:47:42.344 [2023-03-08 13:47:42.344 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.345154566</TimeChanged>
<TimeCreated>66527,48984.318463971</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclCmrrRecoursDiagDiff.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "108-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("108-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclCmrrRecoursDiagDiff.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["108-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclCmrrRecoursDiagDiff" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclCmrrRecoursDiagDiff.Record" complexBatchManaged="1" label="108-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclCmrrRecoursDiagDiff.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclCmrrRecoursDiagDiff'
on 2023-03-08 at 13:47:42.339 [2023-03-08 13:47:42.339 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.366379071</TimeChanged>
<TimeCreated>66541,49662.339340764</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclCmrrRecoursDiagDiff.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclCmF33F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclCmF33F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclCmF33F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclCmF33F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclCmrrRecoursPTech">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclCmrrRecoursPTech'
on 2023-03-08 at 13:47:42.662 [2023-03-08 13:47:42.662 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.662925745</TimeChanged>
<TimeCreated>66527,49246.26136306</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclCmrrRecoursPTech.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "110-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("110-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclCmrrRecoursPTech.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["110-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclCmrrRecoursPTech" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclCmrrRecoursPTech.Record" complexBatchManaged="1" label="110-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclCmrrRecoursPTech.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclCmrrRecoursPTech'
on 2023-03-08 at 13:47:42.657 [2023-03-08 13:47:42.657 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.68425295</TimeChanged>
<TimeCreated>66541,49662.657163543</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclCmrrRecoursPTech.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclCmr291.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclCmr291.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclCmr291.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclCmr291.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclCmrrRecoursSpExpert">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclCmrrRecoursSpExpert'
on 2023-03-08 at 13:47:42.815 [2023-03-08 13:47:42.815 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.816183383</TimeChanged>
<TimeCreated>66527,49296.059442928</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclCmrrRecoursSpExpert.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "111-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("111-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclCmrrRecoursSpExpert.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["111-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclCmrrRecoursSpExpert" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclCmrrRecoursSpExpert.Record" complexBatchManaged="1" label="111-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclCmrrRecoursSpExpert.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclCmrrRecoursSpExpert'
on 2023-03-08 at 13:47:42.810 [2023-03-08 13:47:42.810 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.837062988</TimeChanged>
<TimeCreated>66541,49662.810381681</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclCmrrRecoursSpExpert.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclCmC025.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclCmC025.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclCmC025.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclCmC025.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclCmrrRecoursSuivi">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclCmrrRecoursSuivi'
on 2023-03-08 at 13:47:42.502 [2023-03-08 13:47:42.502 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.503060905</TimeChanged>
<TimeCreated>66527,49125.706154558</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclCmrrRecoursSuivi.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "109-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("109-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclCmrrRecoursSuivi.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["109-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclCmrrRecoursSuivi" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclCmrrRecoursSuivi.Record" complexBatchManaged="1" label="109-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclCmrrRecoursSuivi.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclCmrrRecoursSuivi'
on 2023-03-08 at 13:47:42.497 [2023-03-08 13:47:42.497 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.52460901</TimeChanged>
<TimeCreated>66541,49662.497251904</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclCmrrRecoursSuivi.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclCm6DD0.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclCm6DD0.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclCm6DD0.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclCm6DD0.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDateActe">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDateActe'
on 2023-03-08 at 13:47:34.350 [2023-03-08 13:47:34.350 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.351026115</TimeChanged>
<TimeCreated>66527,35743.282585514</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDateActe.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "056-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("056-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDateActe.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["056-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDateActe" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDateActe.Record" complexBatchManaged="1" label="056-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDateActe.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDateActe'
on 2023-03-08 at 13:47:34.345 [2023-03-08 13:47:34.345 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.372082906</TimeChanged>
<TimeCreated>66541,49654.345186017</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDateActe.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDa62C1.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDa62C1.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDa62C1.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDa62C1.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDateDeces">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDateDeces'
on 2023-03-08 at 13:47:36.046 [2023-03-08 13:47:36.046 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.047251605</TimeChanged>
<TimeCreated>66527,36602.352742211</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDateDeces.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "067-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("067-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDateDeces.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["067-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDateDeces" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDateDeces.Record" complexBatchManaged="1" label="067-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDateDeces.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDateDeces'
on 2023-03-08 at 13:47:36.041 [2023-03-08 13:47:36.041 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.06825191</TimeChanged>
<TimeCreated>66541,49656.041533603</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDateDeces.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDaF99E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDaF99E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDaF99E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDaF99E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDateEntreeInstitution">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDateEntreeInstitution'
on 2023-03-08 at 13:47:35.893 [2023-03-08 13:47:35.893 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.893816267</TimeChanged>
<TimeCreated>66527,36480.413835986</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDateEntreeInstitution.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "066-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("066-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDateEntreeInstitution.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["066-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDateEntreeInstitution" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDateEntreeInstitution.Record" complexBatchManaged="1" label="066-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDateEntreeInstitution.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDateEntreeInstitution'
on 2023-03-08 at 13:47:35.887 [2023-03-08 13:47:35.887 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.915380672</TimeChanged>
<TimeCreated>66541,49655.887716365</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDateEntreeInstitution.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDaD79D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDaD79D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDaD79D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDaD79D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDateFinSuivi">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDateFinSuivi'
on 2023-03-08 at 13:47:35.739 [2023-03-08 13:47:35.739 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.739963428</TimeChanged>
<TimeCreated>66527,36402.573920954</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDateFinSuivi.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "065-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("065-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDateFinSuivi.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["065-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDateFinSuivi" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDateFinSuivi.Record" complexBatchManaged="1" label="065-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDateFinSuivi.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDateFinSuivi'
on 2023-03-08 at 13:47:35.734 [2023-03-08 13:47:35.734 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.761182134</TimeChanged>
<TimeCreated>66541,49655.734155227</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDateFinSuivi.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDaA491.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDaA491.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDaA491.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDaA491.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDiagnostic">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDiagnostic'
on 2023-03-08 at 13:47:34.043 [2023-03-08 13:47:34.043 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.044583136</TimeChanged>
<TimeCreated>66527,35583.567809496</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDiagnostic.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "054-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("054-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDiagnostic.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["054-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDiagnostic" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDiagnostic.Record" complexBatchManaged="1" label="054-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDiagnostic.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDiagnostic'
on 2023-03-08 at 13:47:34.038 [2023-03-08 13:47:34.038 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.065800428</TimeChanged>
<TimeCreated>66541,49654.038828938</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDiagnostic.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDiDC7D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDiDC7D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDiDC7D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDiDC7D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDiagnosticN31">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDiagnosticN31'
on 2023-03-08 at 13:47:44.348 [2023-03-08 13:47:44.348 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.348794208</TimeChanged>
<TimeCreated>66527,49819.5728832</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDiagnosticN31.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "121-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("121-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDiagnosticN31.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["121-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDiagnosticN31" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDiagnosticN31.Record" complexBatchManaged="1" label="121-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDiagnosticN31.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDiagnosticN31'
on 2023-03-08 at 13:47:44.343 [2023-03-08 13:47:44.343 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.369662014</TimeChanged>
<TimeCreated>66541,49664.343022606</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDiagnosticN31.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDiEB7D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDiEB7D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDiEB7D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDiEB7D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDiagnosticN32">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDiagnosticN32'
on 2023-03-08 at 13:47:44.500 [2023-03-08 13:47:44.500 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.501374155</TimeChanged>
<TimeCreated>66527,49891.781023015</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDiagnosticN32.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "122-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("122-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDiagnosticN32.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["122-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDiagnosticN32" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDiagnosticN32.Record" complexBatchManaged="1" label="122-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDiagnosticN32.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDiagnosticN32'
on 2023-03-08 at 13:47:44.495 [2023-03-08 13:47:44.495 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.522223762</TimeChanged>
<TimeCreated>66541,49664.495589554</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDiagnosticN32.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDiEA3D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDiEA3D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDiEA3D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDiEA3D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclDiagnosticN33">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclDiagnosticN33'
on 2023-03-08 at 13:47:44.662 [2023-03-08 13:47:44.662 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.663385506</TimeChanged>
<TimeCreated>66527,49955.93184678</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclDiagnosticN33.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "123-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("123-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclDiagnosticN33.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["123-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclDiagnosticN33" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclDiagnosticN33.Record" complexBatchManaged="1" label="123-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclDiagnosticN33.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclDiagnosticN33'
on 2023-03-08 at 13:47:44.656 [2023-03-08 13:47:44.656 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.684570513</TimeChanged>
<TimeCreated>66541,49664.656811204</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclDiagnosticN33.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclDi2AFC.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclDi2AFC.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclDi2AFC.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclDi2AFC.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclEffetIndesirable">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclEffetIndesirable'
on 2023-03-08 at 13:47:37.740 [2023-03-08 13:47:37.740 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.741226325</TimeChanged>
<TimeCreated>66527,37996.292535672</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclEffetIndesirable.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "078-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("078-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclEffetIndesirable.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["078-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclEffetIndesirable" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclEffetIndesirable.Record" complexBatchManaged="1" label="078-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclEffetIndesirable.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclEffetIndesirable'
on 2023-03-08 at 13:47:37.735 [2023-03-08 13:47:37.735 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.76201643</TimeChanged>
<TimeCreated>66541,49657.735407123</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclEffetIndesirable.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclEf4016.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclEf4016.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclEf4016.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclEf4016.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclEtatDemence">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclEtatDemence'
on 2023-03-08 at 13:47:33.737 [2023-03-08 13:47:33.737 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.738562058</TimeChanged>
<TimeCreated>66527,35418.342738652</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclEtatDemence.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "052-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("052-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclEtatDemence.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["052-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclEtatDemence" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclEtatDemence.Record" complexBatchManaged="1" label="052-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclEtatDemence.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclEtatDemence'
on 2023-03-08 at 13:47:33.732 [2023-03-08 13:47:33.732 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.759674849</TimeChanged>
<TimeCreated>66541,49653.73279346</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclEtatDemence.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclEt179E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclEt179E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclEt179E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclEt179E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclFinSuivi">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclFinSuivi'
on 2023-03-08 at 13:47:35.585 [2023-03-08 13:47:35.585 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.586666325</TimeChanged>
<TimeCreated>66527,36347.120321627</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclFinSuivi.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "064-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("064-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclFinSuivi.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["064-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclFinSuivi" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclFinSuivi.Record" complexBatchManaged="1" label="064-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclFinSuivi.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclFinSuivi'
on 2023-03-08 at 13:47:35.580 [2023-03-08 13:47:35.580 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.608085116</TimeChanged>
<TimeCreated>66541,49655.580911527</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclFinSuivi.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclFi122C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclFi122C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclFi122C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclFi122C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIADLConsequence">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIADLConsequence'
on 2023-03-08 at 13:47:34.811 [2023-03-08 13:47:34.811 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.812082632</TimeChanged>
<TimeCreated>66527,35930.313971882</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIADLConsequence.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "059-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("059-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIADLConsequence.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["059-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIADLConsequence" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIADLConsequence.Record" complexBatchManaged="1" label="059-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIADLConsequence.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIADLConsequence'
on 2023-03-08 at 13:47:34.806 [2023-03-08 13:47:34.806 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.833453823</TimeChanged>
<TimeCreated>66541,49654.806289334</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIADLConsequence.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIA1F34.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIA1F34.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIA1F34.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIA1F34.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIADLDetection">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIADLDetection'
on 2023-03-08 at 13:47:34.657 [2023-03-08 13:47:34.657 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.658492193</TimeChanged>
<TimeCreated>66527,35843.973657491</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIADLDetection.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "058-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("058-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIADLDetection.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["058-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIADLDetection" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIADLDetection.Record" complexBatchManaged="1" label="058-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIADLDetection.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIADLDetection'
on 2023-03-08 at 13:47:34.652 [2023-03-08 13:47:34.652 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.679741184</TimeChanged>
<TimeCreated>66541,49654.652706195</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIADLDetection.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIA5C82.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIA5C82.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIA5C82.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIA5C82.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRAccueilJour">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRAccueilJour'
on 2023-03-08 at 13:47:38.810 [2023-03-08 13:47:38.810 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.81130079</TimeChanged>
<TimeCreated>66527,38345.234632922</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRAccueilJour.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "085-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("085-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRAccueilJour.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["085-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRAccueilJour" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRAccueilJour.Record" complexBatchManaged="1" label="085-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRAccueilJour.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRAccueilJour'
on 2023-03-08 at 13:47:38.805 [2023-03-08 13:47:38.805 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.832311095</TimeChanged>
<TimeCreated>66541,49658.805523188</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRAccueilJour.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPAC22.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPAC22.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPAC22.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPAC22.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRAucun">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRAucun'
on 2023-03-08 at 13:47:37.892 [2023-03-08 13:47:37.892 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.893453162</TimeChanged>
<TimeCreated>66527,38053.89135766</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRAucun.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "079-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("079-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRAucun.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["079-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRAucun" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRAucun.Record" complexBatchManaged="1" label="079-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRAucun.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRAucun'
on 2023-03-08 at 13:47:37.887 [2023-03-08 13:47:37.887 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.914169267</TimeChanged>
<TimeCreated>66541,49657.887674961</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRAucun.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPFD52.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPFD52.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPFD52.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPFD52.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRAutre">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRAutre'
on 2023-03-08 at 13:47:39.576 [2023-03-08 13:47:39.576 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.57696078</TimeChanged>
<TimeCreated>66527,38702.641823997</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRAutre.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "090-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("090-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRAutre.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["090-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRAutre" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRAutre.Record" complexBatchManaged="1" label="090-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRAutre.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRAutre'
on 2023-03-08 at 13:47:39.571 [2023-03-08 13:47:39.571 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.597867385</TimeChanged>
<TimeCreated>66541,49659.571233978</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRAutre.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPSEA1.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPSEA1.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPSEA1.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPSEA1.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRClic">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRClic'
on 2023-03-08 at 13:47:39.116 [2023-03-08 13:47:39.116 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.117627166</TimeChanged>
<TimeCreated>66527,38455.638066928</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRClic.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "087-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("087-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRClic.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["087-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRClic" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRClic.Record" complexBatchManaged="1" label="087-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRClic.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRClic'
on 2023-03-08 at 13:47:39.111 [2023-03-08 13:47:39.111 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.138828871</TimeChanged>
<TimeCreated>66541,49659.111869464</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRClic.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPC26B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPC26B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPC26B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPC26B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRErgotherapeute">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRErgotherapeute'
on 2023-03-08 at 13:47:38.503 [2023-03-08 13:47:38.503 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.504635914</TimeChanged>
<TimeCreated>66527,38243.805839745</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRErgotherapeute.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "083-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("083-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRErgotherapeute.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["083-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRErgotherapeute" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRErgotherapeute.Record" complexBatchManaged="1" label="083-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRErgotherapeute.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRErgotherapeute'
on 2023-03-08 at 13:47:38.498 [2023-03-08 13:47:38.498 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.525883719</TimeChanged>
<TimeCreated>66541,49658.498798812</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRErgotherapeute.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPSA7A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPSA7A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPSA7A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPSA7A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSREsad">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSREsad'
on 2023-03-08 at 13:47:43.275 [2023-03-08 13:47:43.275 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.276244597</TimeChanged>
<TimeCreated>66527,49450.615752254</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSREsad.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "114-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("114-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSREsad.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["114-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSREsad" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSREsad.Record" complexBatchManaged="1" label="114-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSREsad.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSREsad'
on 2023-03-08 at 13:47:43.270 [2023-03-08 13:47:43.270 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.297262802</TimeChanged>
<TimeCreated>66541,49663.270450195</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSREsad.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP8E1C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP8E1C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP8E1C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP8E1C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRGardeMalade">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRGardeMalade'
on 2023-03-08 at 13:47:44.969 [2023-03-08 13:47:44.969 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.970281202</TimeChanged>
<TimeCreated>66528,48723.045203968</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRGardeMalade.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "125-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("125-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRGardeMalade.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["125-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRGardeMalade" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRGardeMalade.Record" complexBatchManaged="1" label="125-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRGardeMalade.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRGardeMalade'
on 2023-03-08 at 13:47:44.964 [2023-03-08 13:47:44.964 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.991203008</TimeChanged>
<TimeCreated>66541,49664.964552</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRGardeMalade.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP8E90.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP8E90.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP8E90.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP8E90.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRGroupe">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRGroupe'
on 2023-03-08 at 13:47:38.657 [2023-03-08 13:47:38.657 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.658565452</TimeChanged>
<TimeCreated>66527,38291.858546885</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRGroupe.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "084-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("084-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRGroupe.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["084-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRGroupe" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRGroupe.Record" complexBatchManaged="1" label="084-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRGroupe.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRGroupe'
on 2023-03-08 at 13:47:38.652 [2023-03-08 13:47:38.652 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.679645857</TimeChanged>
<TimeCreated>66541,49658.652864051</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRGroupe.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP8003.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP8003.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP8003.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP8003.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRHdj">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRHdj'
on 2023-03-08 at 13:47:43.428 [2023-03-08 13:47:43.428 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.429199035</TimeChanged>
<TimeCreated>66527,49498.46583623</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRHdj.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "115-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("115-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRHdj.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["115-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRHdj" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRHdj.Record" complexBatchManaged="1" label="115-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRHdj.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRHdj'
on 2023-03-08 at 13:47:43.423 [2023-03-08 13:47:43.423 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.45022334</TimeChanged>
<TimeCreated>66541,49663.423415333</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRHdj.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP2952.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP2952.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP2952.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP2952.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRKinesitherapeute">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRKinesitherapeute'
on 2023-03-08 at 13:47:38.350 [2023-03-08 13:47:38.350 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.351304976</TimeChanged>
<TimeCreated>66527,38198.929944328</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRKinesitherapeute.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "082-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("082-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRKinesitherapeute.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["082-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRKinesitherapeute" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRKinesitherapeute.Record" complexBatchManaged="1" label="082-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRKinesitherapeute.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRKinesitherapeute'
on 2023-03-08 at 13:47:38.345 [2023-03-08 13:47:38.345 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.372392681</TimeChanged>
<TimeCreated>66541,49658.345464374</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRKinesitherapeute.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP6973.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP6973.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP6973.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP6973.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRMaia">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRMaia'
on 2023-03-08 at 13:47:38.963 [2023-03-08 13:47:38.963 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.964466328</TimeChanged>
<TimeCreated>66527,38392.21830948</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRMaia.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "086-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("086-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRMaia.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["086-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRMaia" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRMaia.Record" complexBatchManaged="1" label="086-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRMaia.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRMaia'
on 2023-03-08 at 13:47:38.958 [2023-03-08 13:47:38.958 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.985745333</TimeChanged>
<TimeCreated>66541,49658.958752726</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRMaia.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP2879.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP2879.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP2879.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP2879.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSROrthophoniste">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSROrthophoniste'
on 2023-03-08 at 13:47:38.045 [2023-03-08 13:47:38.045 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.0462131</TimeChanged>
<TimeCreated>66527,38110.210678577</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSROrthophoniste.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "080-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("080-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSROrthophoniste.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["080-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSROrthophoniste" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSROrthophoniste.Record" complexBatchManaged="1" label="080-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSROrthophoniste.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSROrthophoniste'
on 2023-03-08 at 13:47:38.040 [2023-03-08 13:47:38.040 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.067157205</TimeChanged>
<TimeCreated>66541,49658.040401799</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSROrthophoniste.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP3C9D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP3C9D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP3C9D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP3C9D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRPAERPA">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRPAERPA'
on 2023-03-08 at 13:47:45.128 [2023-03-08 13:47:45.128 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.128990251</TimeChanged>
<TimeCreated>66528,55145.083489371</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRPAERPA.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "126-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("126-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRPAERPA.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["126-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRPAERPA" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRPAERPA.Record" complexBatchManaged="1" label="126-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRPAERPA.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRPAERPA'
on 2023-03-08 at 13:47:45.118 [2023-03-08 13:47:45.118 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.150013958</TimeChanged>
<TimeCreated>66541,49665.118458448</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRPAERPA.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP6BA5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP6BA5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP6BA5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP6BA5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRPsychologue">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRPsychologue'
on 2023-03-08 at 13:47:38.198 [2023-03-08 13:47:38.198 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49658.198737338</TimeChanged>
<TimeCreated>66527,38156.073055963</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRPsychologue.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "081-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("081-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRPsychologue.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["081-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRPsychologue" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRPsychologue.Record" complexBatchManaged="1" label="081-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRPsychologue.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRPsychologue'
on 2023-03-08 at 13:47:38.192 [2023-03-08 13:47:38.192 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49658.219837643</TimeChanged>
<TimeCreated>66541,49658.192934137</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRPsychologue.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP2557.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP2557.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP2557.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP2557.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRRepits">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRRepits'
on 2023-03-08 at 13:47:39.270 [2023-03-08 13:47:39.270 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.271098404</TimeChanged>
<TimeCreated>66527,38525.880198676</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRRepits.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "088-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("088-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRRepits.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["088-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRRepits" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRRepits.Record" complexBatchManaged="1" label="088-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRRepits.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRRepits'
on 2023-03-08 at 13:47:39.265 [2023-03-08 13:47:39.265 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.292357709</TimeChanged>
<TimeCreated>66541,49659.265301502</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRRepits.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP5A30.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP5A30.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP5A30.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP5A30.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRSiad">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRSiad'
on 2023-03-08 at 13:47:39.423 [2023-03-08 13:47:39.423 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.424367442</TimeChanged>
<TimeCreated>66527,38579.844241573</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRSiad.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "089-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("089-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRSiad.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["089-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRSiad" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRSiad.Record" complexBatchManaged="1" label="089-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRSiad.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRSiad'
on 2023-03-08 at 13:47:39.418 [2023-03-08 13:47:39.418 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.445302147</TimeChanged>
<TimeCreated>66541,49659.41859004</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRSiad.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIPS139.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIPS139.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIPS139.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIPS139.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclIPSRUcc">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclIPSRUcc'
on 2023-03-08 at 13:47:43.580 [2023-03-08 13:47:43.580 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.580869172</TimeChanged>
<TimeCreated>66527,49557.487261898</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclIPSRUcc.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "116-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("116-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclIPSRUcc.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["116-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclIPSRUcc" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclIPSRUcc.Record" complexBatchManaged="1" label="116-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclIPSRUcc.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclIPSRUcc'
on 2023-03-08 at 13:47:43.575 [2023-03-08 13:47:43.575 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.602465378</TimeChanged>
<TimeCreated>66541,49663.575109071</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclIPSRUcc.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclIP1900.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclIP1900.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclIP1900.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclIP1900.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclMMSE">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclMMSE'
on 2023-03-08 at 13:47:34.504 [2023-03-08 13:47:34.504 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.504717054</TimeChanged>
<TimeCreated>66527,35791.131915449</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclMMSE.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "057-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("057-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclMMSE.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["057-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclMMSE" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclMMSE.Record" complexBatchManaged="1" label="057-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclMMSE.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclMMSE'
on 2023-03-08 at 13:47:34.499 [2023-03-08 13:47:34.499 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.525595345</TimeChanged>
<TimeCreated>66541,49654.498989756</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclMMSE.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclMMSE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclMMSE.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclMMSE.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclMMSE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclMesureProtection">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclMesureProtection'
on 2023-03-08 at 13:47:35.432 [2023-03-08 13:47:35.432 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49655.432905886</TimeChanged>
<TimeCreated>66527,36288.691488614</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclMesureProtection.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "063-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("063-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclMesureProtection.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["063-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclMesureProtection" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclMesureProtection.Record" complexBatchManaged="1" label="063-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclMesureProtection.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclMesureProtection'
on 2023-03-08 at 13:47:35.427 [2023-03-08 13:47:35.427 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49655.454303777</TimeChanged>
<TimeCreated>66541,49655.427118888</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclMesureProtection.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclMeB95D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclMeB95D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclMeB95D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclMeB95D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclModeDeVie">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclModeDeVie'
on 2023-03-08 at 13:47:34.965 [2023-03-08 13:47:34.965 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.965894871</TimeChanged>
<TimeCreated>66527,36054.662095916</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclModeDeVie.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "060-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("060-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclModeDeVie.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["060-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclModeDeVie" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclModeDeVie.Record" complexBatchManaged="1" label="060-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclModeDeVie.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclModeDeVie'
on 2023-03-08 at 13:47:34.960 [2023-03-08 13:47:34.960 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.987096862</TimeChanged>
<TimeCreated>66541,49654.960163373</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclModeDeVie.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclMo24F0.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclMo24F0.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclMo24F0.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclMo24F0.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCAucun">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCAucun'
on 2023-03-08 at 13:47:39.728 [2023-03-08 13:47:39.728 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.729637217</TimeChanged>
<TimeCreated>66527,38745.837728599</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCAucun.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "091-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("091-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCAucun.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["091-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCAucun" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCAucun.Record" complexBatchManaged="1" label="091-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCAucun.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCAucun'
on 2023-03-08 at 13:47:39.723 [2023-03-08 13:47:39.723 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.750777223</TimeChanged>
<TimeCreated>66541,49659.723920316</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCAucun.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPC6717.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPC6717.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPC6717.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPC6717.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCBioMarqueurs">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCBioMarqueurs'
on 2023-03-08 at 13:47:40.494 [2023-03-08 13:47:40.494 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.494767007</TimeChanged>
<TimeCreated>66527,40132.231927422</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCBioMarqueurs.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "096-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("096-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCBioMarqueurs.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["096-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCBioMarqueurs" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCBioMarqueurs.Record" complexBatchManaged="1" label="096-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCBioMarqueurs.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCBioMarqueurs'
on 2023-03-08 at 13:47:40.489 [2023-03-08 13:47:40.489 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.518186713</TimeChanged>
<TimeCreated>66541,49660.488974906</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCBioMarqueurs.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPC420C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPC420C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPC420C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPC420C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCIRM">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCIRM'
on 2023-03-08 at 13:47:39.881 [2023-03-08 13:47:39.881 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49659.882106555</TimeChanged>
<TimeCreated>66527,38795.05785475</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCIRM.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "092-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("092-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCIRM.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["092-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCIRM" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCIRM.Record" complexBatchManaged="1" label="092-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCIRM.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCIRM'
on 2023-03-08 at 13:47:39.876 [2023-03-08 13:47:39.876 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49659.903508761</TimeChanged>
<TimeCreated>66541,49659.876419054</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCIRM.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPCIRM.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPCIRM.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPCIRM.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPCIRM.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCPET">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCPET'
on 2023-03-08 at 13:47:40.341 [2023-03-08 13:47:40.341 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.341996969</TimeChanged>
<TimeCreated>66527,40089.615380903</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCPET.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "095-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("095-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCPET.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["095-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCPET" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCPET.Record" complexBatchManaged="1" label="095-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCPET.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCPET'
on 2023-03-08 at 13:47:40.336 [2023-03-08 13:47:40.336 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.362967974</TimeChanged>
<TimeCreated>66541,49660.336274268</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCPET.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPCPET.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPCPET.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPCPET.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPCPET.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCSPECT">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCSPECT'
on 2023-03-08 at 13:47:40.188 [2023-03-08 13:47:40.188 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.188740131</TimeChanged>
<TimeCreated>66527,38903.12793296</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCSPECT.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "094-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("094-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCSPECT.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["094-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCSPECT" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCSPECT.Record" complexBatchManaged="1" label="094-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCSPECT.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCSPECT'
on 2023-03-08 at 13:47:40.183 [2023-03-08 13:47:40.183 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.209761336</TimeChanged>
<TimeCreated>66541,49660.18302823</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCSPECT.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPC10D2.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPC10D2.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPC10D2.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPC10D2.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPCScanner">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPCScanner'
on 2023-03-08 at 13:47:40.034 [2023-03-08 13:47:40.034 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.035482793</TimeChanged>
<TimeCreated>66527,38850.65480543</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPCScanner.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "093-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("093-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPCScanner.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["093-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPCScanner" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPCScanner.Record" complexBatchManaged="1" label="093-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPCScanner.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPCScanner'
on 2023-03-08 at 13:47:40.029 [2023-03-08 13:47:40.029 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.056461098</TimeChanged>
<TimeCreated>66541,49660.029776392</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPCScanner.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPCBCAA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPCBCAA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPCBCAA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPCBCAA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPECAidant">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPECAidant'
on 2023-03-08 at 13:47:44.815 [2023-03-08 13:47:44.815 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.816240754</TimeChanged>
<TimeCreated>66528,48663.962950972</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPECAidant.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "124-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("124-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPECAidant.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["124-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPECAidant" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPECAidant.Record" complexBatchManaged="1" label="124-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPECAidant.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPECAidant'
on 2023-03-08 at 13:47:44.810 [2023-03-08 13:47:44.810 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.838548361</TimeChanged>
<TimeCreated>66541,49664.810268252</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPECAidant.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPEFD68.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPEFD68.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPEFD68.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPEFD68.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPR">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPR'
on 2023-03-08 at 13:47:40.654 [2023-03-08 13:47:40.654 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.655482347</TimeChanged>
<TimeCreated>66527,40217.804534815</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPR.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "097-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("097-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPR.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["097-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPR" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPR.Record" complexBatchManaged="1" label="097-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPR.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPR'
on 2023-03-08 at 13:47:40.649 [2023-03-08 13:47:40.649 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.676079952</TimeChanged>
<TimeCreated>66541,49660.649779846</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPR.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPR.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPR.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPR.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPR.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPRType">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPRType'
on 2023-03-08 at 13:47:40.807 [2023-03-08 13:47:40.807 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.808603685</TimeChanged>
<TimeCreated>66527,40320.106250196</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPRType.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "098-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("098-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPRType.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["098-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPRType" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPRType.Record" complexBatchManaged="1" label="098-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPRType.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPRType'
on 2023-03-08 at 13:47:40.802 [2023-03-08 13:47:40.802 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.82959859</TimeChanged>
<TimeCreated>66541,49660.802840684</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPRType.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPRA7D1.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPRA7D1.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPRA7D1.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPRA7D1.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclPRVisite">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclPRVisite'
on 2023-03-08 at 13:47:40.959 [2023-03-08 13:47:40.959 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49660.960509323</TimeChanged>
<TimeCreated>66527,40388.059180137</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclPRVisite.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "099-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("099-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclPRVisite.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["099-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclPRVisite" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclPRVisite.Record" complexBatchManaged="1" label="099-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclPRVisite.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclPRVisite'
on 2023-03-08 at 13:47:40.954 [2023-03-08 13:47:40.954 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49660.981529928</TimeChanged>
<TimeCreated>66541,49660.954801121</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclPRVisite.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclPRA7FA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclPRA7FA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclPRA7FA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclPRA7FA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclRechAcceptPlacebo">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclRechAcceptPlacebo'
on 2023-03-08 at 13:47:44.195 [2023-03-08 13:47:44.195 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.19592136</TimeChanged>
<TimeCreated>66527,49772.288276389</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclRechAcceptPlacebo.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "120-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("120-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclRechAcceptPlacebo.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["120-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclRechAcceptPlacebo" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclRechAcceptPlacebo.Record" complexBatchManaged="1" label="120-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclRechAcceptPlacebo.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclRechAcceptPlacebo'
on 2023-03-08 at 13:47:44.190 [2023-03-08 13:47:44.190 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.217053467</TimeChanged>
<TimeCreated>66541,49664.190144758</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclRechAcceptPlacebo.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclRe17C3.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclRe17C3.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclRe17C3.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclRe17C3.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclRechAutonom">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclRechAutonom'
on 2023-03-08 at 13:47:43.887 [2023-03-08 13:47:43.887 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.888065164</TimeChanged>
<TimeCreated>66527,49659.196831788</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclRechAutonom.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "118-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("118-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclRechAutonom.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["118-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclRechAutonom" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclRechAutonom.Record" complexBatchManaged="1" label="118-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclRechAutonom.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclRechAutonom'
on 2023-03-08 at 13:47:43.882 [2023-03-08 13:47:43.882 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.90959707</TimeChanged>
<TimeCreated>66541,49663.882158662</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclRechAutonom.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclRe86D5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclRe86D5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclRe86D5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclRe86D5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclRechContreIndic">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclRechContreIndic'
on 2023-03-08 at 13:47:44.041 [2023-03-08 13:47:44.041 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49664.042212612</TimeChanged>
<TimeCreated>66527,49712.294236751</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclRechContreIndic.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "119-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("119-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclRechContreIndic.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["119-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclRechContreIndic" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclRechContreIndic.Record" complexBatchManaged="1" label="119-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclRechContreIndic.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclRechContreIndic'
on 2023-03-08 at 13:47:44.036 [2023-03-08 13:47:44.036 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49664.063586919</TimeChanged>
<TimeCreated>66541,49664.03630761</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclRechContreIndic.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclRe159E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclRe159E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclRe159E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclRe159E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclRechPresDispo">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclRechPresDispo'
on 2023-03-08 at 13:47:43.733 [2023-03-08 13:47:43.733 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.734267216</TimeChanged>
<TimeCreated>66527,49606.769298719</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclRechPresDispo.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "117-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("117-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclRechPresDispo.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["117-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclRechPresDispo" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclRechPresDispo.Record" complexBatchManaged="1" label="117-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclRechPresDispo.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclRechPresDispo'
on 2023-03-08 at 13:47:43.728 [2023-03-08 13:47:43.728 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.755169322</TimeChanged>
<TimeCreated>66541,49663.728491014</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclRechPresDispo.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclRe7D41.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclRe7D41.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclRe7D41.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclRe7D41.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDA">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDA'
on 2023-03-08 at 13:47:36.517 [2023-03-08 13:47:36.517 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.518486821</TimeChanged>
<TimeCreated>66527,36772.503272174</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDA.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "070-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("070-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDA.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["070-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDA" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDA.Record" complexBatchManaged="1" label="070-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDA.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDA'
on 2023-03-08 at 13:47:36.512 [2023-03-08 13:47:36.512 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.539382327</TimeChanged>
<TimeCreated>66541,49656.51270902</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDA.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP3B60.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP3B60.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP3B60.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP3B60.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDAAvantPEC'
on 2023-03-08 at 13:47:54.059 [2023-03-08 13:47:54.059 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.060620781</TimeChanged>
<TimeCreated>66528,61312.589881429</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "184-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("184-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["184-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDAAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record" complexBatchManaged="1" label="184-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDAAvantPEC'
on 2023-03-08 at 13:47:54.054 [2023-03-08 13:47:54.054 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.082050391</TimeChanged>
<TimeCreated>66541,49674.054761578</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPE8D7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPE8D7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPE8D7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPE8D7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDADebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDADebut'
on 2023-03-08 at 13:47:46.052 [2023-03-08 13:47:46.052 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.05320024</TimeChanged>
<TimeCreated>66528,58114.261456901</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDADebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "132-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("132-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDADebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["132-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDADebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDADebut.Record" complexBatchManaged="1" label="132-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDADebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDADebut'
on 2023-03-08 at 13:47:46.047 [2023-03-08 13:47:46.047 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.074138947</TimeChanged>
<TimeCreated>66541,49666.047311838</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDADebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP86E4.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP86E4.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP86E4.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP86E4.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDADebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDADebutPar'
on 2023-03-08 at 13:47:50.051 [2023-03-08 13:47:50.051 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.05223799</TimeChanged>
<TimeCreated>66528,59426.015900095</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDADebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "158-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("158-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDADebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["158-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDADebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDADebutPar.Record" complexBatchManaged="1" label="158-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDADebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDADebutPar'
on 2023-03-08 at 13:47:50.046 [2023-03-08 13:47:50.046 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.073562496</TimeChanged>
<TimeCreated>66541,49670.046356688</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDADebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPF38B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPF38B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPF38B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPF38B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDAFin'
on 2023-03-08 at 13:47:48.057 [2023-03-08 13:47:48.057 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.058355567</TimeChanged>
<TimeCreated>66528,58860.420208301</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDAFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "145-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("145-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDAFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["145-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDAFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDAFin.Record" complexBatchManaged="1" label="145-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDAFin'
on 2023-03-08 at 13:47:48.052 [2023-03-08 13:47:48.052 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.079496073</TimeChanged>
<TimeCreated>66541,49668.052477365</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDAFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP475D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP475D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP475D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP475D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntagonisteNMDAFinPar'
on 2023-03-08 at 13:47:52.055 [2023-03-08 13:47:52.055 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.055894272</TimeChanged>
<TimeCreated>66528,60525.628745875</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntagonisteNMDAFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "171-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("171-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntagonisteNMDAFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["171-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntagonisteNMDAFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntagonisteNMDAFinPar.Record" complexBatchManaged="1" label="171-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntagonisteNMDAFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntagonisteNMDAFinPar'
on 2023-03-08 at 13:47:52.050 [2023-03-08 13:47:52.050 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.077192181</TimeChanged>
<TimeCreated>66541,49672.050007369</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntagonisteNMDAFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP860B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP860B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP860B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP860B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiques">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiques'
on 2023-03-08 at 13:47:45.281 [2023-03-08 13:47:45.281 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.281929699</TimeChanged>
<TimeCreated>66528,55219.173337043</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiques.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "127-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("127-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiques.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["127-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiques" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiques.Record" complexBatchManaged="1" label="127-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiques.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiques'
on 2023-03-08 at 13:47:45.276 [2023-03-08 13:47:45.276 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.303342006</TimeChanged>
<TimeCreated>66541,49665.276155397</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiques.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP9C42.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP9C42.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP9C42.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP9C42.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiquesAvantPEC'
on 2023-03-08 at 13:47:54.986 [2023-03-08 13:47:54.986 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.987127701</TimeChanged>
<TimeCreated>66528,61595.914618149</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "190-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("190-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["190-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiquesAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record" complexBatchManaged="1" label="190-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiquesAvantPEC'
on 2023-03-08 at 13:47:54.981 [2023-03-08 13:47:54.981 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49675.008276011</TimeChanged>
<TimeCreated>66541,49674.981259299</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPE382.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPE382.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPE382.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPE382.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiquesDebut'
on 2023-03-08 at 13:47:46.978 [2023-03-08 13:47:46.978 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.979030429</TimeChanged>
<TimeCreated>66528,58501.861196754</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiquesDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "138-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("138-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiquesDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["138-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiquesDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiquesDebut.Record" complexBatchManaged="1" label="138-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiquesDebut'
on 2023-03-08 at 13:47:46.973 [2023-03-08 13:47:46.973 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.000202836</TimeChanged>
<TimeCreated>66541,49666.973201028</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiquesDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPF53F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPF53F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPF53F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPF53F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiquesDebutPar'
on 2023-03-08 at 13:47:50.978 [2023-03-08 13:47:50.978 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.979613379</TimeChanged>
<TimeCreated>66528,60211.40879302</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiquesDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "164-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("164-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiquesDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["164-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiquesDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiquesDebutPar.Record" complexBatchManaged="1" label="164-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiquesDebutPar'
on 2023-03-08 at 13:47:50.973 [2023-03-08 13:47:50.973 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.000912786</TimeChanged>
<TimeCreated>66541,49670.973718577</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiquesDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPF8DE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPF8DE.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPF8DE.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPF8DE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiquesFin'
on 2023-03-08 at 13:47:48.975 [2023-03-08 13:47:48.975 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.976607653</TimeChanged>
<TimeCreated>66528,59109.086653139</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiquesFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "151-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("151-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiquesFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["151-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiquesFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiquesFin.Record" complexBatchManaged="1" label="151-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiquesFin'
on 2023-03-08 at 13:47:48.970 [2023-03-08 13:47:48.970 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.99758426</TimeChanged>
<TimeCreated>66541,49668.970717352</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiquesFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP7D87.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP7D87.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP7D87.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP7D87.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiEpileptiquesFinPar'
on 2023-03-08 at 13:47:52.979 [2023-03-08 13:47:52.979 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.980667191</TimeChanged>
<TimeCreated>66528,60978.930583294</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiEpileptiquesFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "177-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("177-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiEpileptiquesFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["177-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiEpileptiquesFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiEpileptiquesFinPar.Record" complexBatchManaged="1" label="177-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiEpileptiquesFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiEpileptiquesFinPar'
on 2023-03-08 at 13:47:52.974 [2023-03-08 13:47:52.974 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.001487101</TimeChanged>
<TimeCreated>66541,49672.974701088</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiEpileptiquesFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPDD38.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPDD38.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPDD38.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPDD38.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniens">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniens'
on 2023-03-08 at 13:47:45.591 [2023-03-08 13:47:45.591 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.592513396</TimeChanged>
<TimeCreated>66528,55339.990216652</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniens.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "129-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("129-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniens.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["129-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniens" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniens.Record" complexBatchManaged="1" label="129-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniens.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniens'
on 2023-03-08 at 13:47:45.586 [2023-03-08 13:47:45.586 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.614244603</TimeChanged>
<TimeCreated>66541,49665.586444194</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniens.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP67AB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP67AB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP67AB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP67AB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniensAvantPEC'
on 2023-03-08 at 13:47:55.295 [2023-03-08 13:47:55.295 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49675.296073442</TimeChanged>
<TimeCreated>66528,61692.396773275</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "192-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("192-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["192-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniensAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record" complexBatchManaged="1" label="192-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniensAvantPEC'
on 2023-03-08 at 13:47:55.290 [2023-03-08 13:47:55.290 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49675.317348951</TimeChanged>
<TimeCreated>66541,49675.290271739</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPAE06.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPAE06.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPAE06.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPAE06.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniensDebut'
on 2023-03-08 at 13:47:47.285 [2023-03-08 13:47:47.285 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.286499825</TimeChanged>
<TimeCreated>66528,58612.122225813</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniensDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "140-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("140-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniensDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["140-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniensDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniensDebut.Record" complexBatchManaged="1" label="140-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniensDebut'
on 2023-03-08 at 13:47:47.280 [2023-03-08 13:47:47.280 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.307645432</TimeChanged>
<TimeCreated>66541,49667.280651224</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniensDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPA653.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPA653.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPA653.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPA653.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniensDebutPar'
on 2023-03-08 at 13:47:51.286 [2023-03-08 13:47:51.286 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.287414275</TimeChanged>
<TimeCreated>66528,60293.60216588</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniensDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "166-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("166-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniensDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["166-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniensDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniensDebutPar.Record" complexBatchManaged="1" label="166-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniensDebutPar'
on 2023-03-08 at 13:47:51.281 [2023-03-08 13:47:51.281 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.308870182</TimeChanged>
<TimeCreated>66541,49671.281555074</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniensDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP155A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP155A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP155A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP155A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniensFin'
on 2023-03-08 at 13:47:49.282 [2023-03-08 13:47:49.282 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.282892549</TimeChanged>
<TimeCreated>66528,59207.760370597</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniensFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "153-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("153-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniensFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["153-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniensFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniensFin.Record" complexBatchManaged="1" label="153-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniensFin'
on 2023-03-08 at 13:47:49.277 [2023-03-08 13:47:49.277 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.303837956</TimeChanged>
<TimeCreated>66541,49669.277065547</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniensFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPB915.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPB915.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPB915.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPB915.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntiParkinsoniensFinPar'
on 2023-03-08 at 13:47:53.288 [2023-03-08 13:47:53.288 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.289332131</TimeChanged>
<TimeCreated>66528,61072.543915535</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntiParkinsoniensFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "179-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("179-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntiParkinsoniensFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["179-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntiParkinsoniensFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntiParkinsoniensFinPar.Record" complexBatchManaged="1" label="179-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntiParkinsoniensFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntiParkinsoniensFinPar'
on 2023-03-08 at 13:47:53.283 [2023-03-08 13:47:53.283 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.310428541</TimeChanged>
<TimeCreated>66541,49673.283488729</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntiParkinsoniensFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPF0CB.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPF0CB.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPF0CB.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPF0CB.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseurs">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseurs'
on 2023-03-08 at 13:47:36.670 [2023-03-08 13:47:36.670 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.670785859</TimeChanged>
<TimeCreated>66527,37380.836522622</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseurs.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "071-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("071-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseurs.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["071-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseurs" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseurs.Record" complexBatchManaged="1" label="071-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseurs.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseurs'
on 2023-03-08 at 13:47:36.664 [2023-03-08 13:47:36.664 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.692060564</TimeChanged>
<TimeCreated>66541,49656.664918558</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseurs.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP764E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP764E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP764E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP764E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseursAvantPEC'
on 2023-03-08 at 13:47:54.214 [2023-03-08 13:47:54.214 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.215485751</TimeChanged>
<TimeCreated>66528,61363.767548737</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseursAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "185-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("185-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseursAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["185-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseursAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseursAvantPEC.Record" complexBatchManaged="1" label="185-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseursAvantPEC'
on 2023-03-08 at 13:47:54.209 [2023-03-08 13:47:54.209 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.236907761</TimeChanged>
<TimeCreated>66541,49674.209641849</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseursAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP78C9.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP78C9.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP78C9.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP78C9.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseursDebut'
on 2023-03-08 at 13:47:46.205 [2023-03-08 13:47:46.205 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.206448288</TimeChanged>
<TimeCreated>66528,58179.790510959</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseursDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "133-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("133-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseursDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["133-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseursDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseursDebut.Record" complexBatchManaged="1" label="133-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseursDebut'
on 2023-03-08 at 13:47:46.200 [2023-03-08 13:47:46.200 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.228015895</TimeChanged>
<TimeCreated>66541,49666.200652586</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseursDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPEC1B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPEC1B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPEC1B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPEC1B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseursDebutPar'
on 2023-03-08 at 13:47:50.206 [2023-03-08 13:47:50.206 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.207780238</TimeChanged>
<TimeCreated>66528,59464.370829331</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseursDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "159-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("159-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseursDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["159-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseursDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseursDebutPar.Record" complexBatchManaged="1" label="159-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseursDebutPar'
on 2023-03-08 at 13:47:50.201 [2023-03-08 13:47:50.201 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.228965645</TimeChanged>
<TimeCreated>66541,49670.201172636</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseursDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP6395.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP6395.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP6395.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP6395.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseursFin'
on 2023-03-08 at 13:47:48.211 [2023-03-08 13:47:48.211 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.212227015</TimeChanged>
<TimeCreated>66528,58906.78607048</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseursFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "146-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("146-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseursFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["146-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseursFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseursFin.Record" complexBatchManaged="1" label="146-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseursFin'
on 2023-03-08 at 13:47:48.206 [2023-03-08 13:47:48.206 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.233185021</TimeChanged>
<TimeCreated>66541,49668.206416213</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseursFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP1E08.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP1E08.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP1E08.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP1E08.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAntidepresseursFinPar'
on 2023-03-08 at 13:47:52.209 [2023-03-08 13:47:52.209 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.210190242</TimeChanged>
<TimeCreated>66528,60567.56021454</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAntidepresseursFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "172-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("172-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAntidepresseursFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["172-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAntidepresseursFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAntidepresseursFinPar.Record" complexBatchManaged="1" label="172-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAntidepresseursFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAntidepresseursFinPar'
on 2023-03-08 at 13:47:52.204 [2023-03-08 13:47:52.204 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.231340951</TimeChanged>
<TimeCreated>66541,49672.204267739</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAntidepresseursFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPC621.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPC621.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPC621.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPC621.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiques">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiques'
on 2023-03-08 at 13:47:36.976 [2023-03-08 13:47:36.976 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.977493635</TimeChanged>
<TimeCreated>66527,37609.752705481</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiques.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "073-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("073-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiques.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["073-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiques" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiques.Record" complexBatchManaged="1" label="073-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiques.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiques'
on 2023-03-08 at 13:47:36.971 [2023-03-08 13:47:36.971 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.99864244</TimeChanged>
<TimeCreated>66541,49656.971724334</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiques.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP9310.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP9310.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP9310.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP9310.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiquesAvantPEC'
on 2023-03-08 at 13:47:54.524 [2023-03-08 13:47:54.524 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.525487492</TimeChanged>
<TimeCreated>66528,61454.022653168</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiquesAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "187-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("187-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiquesAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["187-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiquesAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiquesAvantPEC.Record" complexBatchManaged="1" label="187-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiquesAvantPEC'
on 2023-03-08 at 13:47:54.519 [2023-03-08 13:47:54.519 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.546441502</TimeChanged>
<TimeCreated>66541,49674.519696689</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiquesAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPA6F9.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPA6F9.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPA6F9.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPA6F9.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiquesDebut'
on 2023-03-08 at 13:47:46.517 [2023-03-08 13:47:46.517 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.517758785</TimeChanged>
<TimeCreated>66528,58304.266446632</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiquesDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "135-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("135-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiquesDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["135-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiquesDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiquesDebut.Record" complexBatchManaged="1" label="135-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiquesDebut'
on 2023-03-08 at 13:47:46.511 [2023-03-08 13:47:46.511 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.538817792</TimeChanged>
<TimeCreated>66541,49666.511939383</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiquesDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP2D85.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP2D85.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP2D85.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP2D85.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiquesDebutPar'
on 2023-03-08 at 13:47:50.517 [2023-03-08 13:47:50.517 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.518610335</TimeChanged>
<TimeCreated>66528,60051.003999422</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiquesDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "161-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("161-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiquesDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["161-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiquesDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiquesDebutPar.Record" complexBatchManaged="1" label="161-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiquesDebutPar'
on 2023-03-08 at 13:47:50.512 [2023-03-08 13:47:50.512 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.540004042</TimeChanged>
<TimeCreated>66541,49670.512783033</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiquesDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP1DA5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP1DA5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP1DA5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP1DA5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiquesFin'
on 2023-03-08 at 13:47:48.517 [2023-03-08 13:47:48.517 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.51783911</TimeChanged>
<TimeCreated>66528,58982.30662345</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiquesFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "148-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("148-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiquesFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["148-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiquesFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiquesFin.Record" complexBatchManaged="1" label="148-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiquesFin'
on 2023-03-08 at 13:47:48.512 [2023-03-08 13:47:48.512 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.538900517</TimeChanged>
<TimeCreated>66541,49668.512020008</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiquesFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP5C23.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP5C23.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP5C23.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP5C23.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAnxiolitiquesFinPar'
on 2023-03-08 at 13:47:52.518 [2023-03-08 13:47:52.518 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.518860382</TimeChanged>
<TimeCreated>66528,60659.856133819</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAnxiolitiquesFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "174-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("174-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAnxiolitiquesFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["174-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAnxiolitiquesFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAnxiolitiquesFinPar.Record" complexBatchManaged="1" label="174-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAnxiolitiquesFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAnxiolitiquesFinPar'
on 2023-03-08 at 13:47:52.513 [2023-03-08 13:47:52.513 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.539955491</TimeChanged>
<TimeCreated>66541,49672.513046279</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAnxiolitiquesFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP6E61.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP6E61.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP6E61.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP6E61.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucun">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucun'
on 2023-03-08 at 13:47:36.198 [2023-03-08 13:47:36.198 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.199564842</TimeChanged>
<TimeCreated>66527,36660.954269372</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucun.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "068-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("068-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucun.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["068-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucun" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucun.Record" complexBatchManaged="1" label="068-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucun.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucun'
on 2023-03-08 at 13:47:36.193 [2023-03-08 13:47:36.193 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.220459848</TimeChanged>
<TimeCreated>66541,49656.193809141</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucun.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPA450.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPA450.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPA450.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPA450.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunAvantPEC'
on 2023-03-08 at 13:47:53.752 [2023-03-08 13:47:53.752 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.753208142</TimeChanged>
<TimeCreated>66528,61217.907349666</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "182-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("182-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["182-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunAvantPEC.Record" complexBatchManaged="1" label="182-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunAvantPEC'
on 2023-03-08 at 13:47:53.747 [2023-03-08 13:47:53.747 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.774252651</TimeChanged>
<TimeCreated>66541,49673.747381239</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPFF1B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPFF1B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPFF1B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPFF1B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListe">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListe'
on 2023-03-08 at 13:47:37.588 [2023-03-08 13:47:37.588 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.588980787</TimeChanged>
<TimeCreated>66527,37923.910887756</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListe.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "077-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("077-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListe.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["077-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListe" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListe.Record" complexBatchManaged="1" label="077-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListe.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListe'
on 2023-03-08 at 13:47:37.583 [2023-03-08 13:47:37.583 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.609968192</TimeChanged>
<TimeCreated>66541,49657.583189085</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListe.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP70A7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP70A7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP70A7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP70A7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListeAvantPEC'
on 2023-03-08 at 13:47:55.605 [2023-03-08 13:47:55.605 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49675.606230982</TimeChanged>
<TimeCreated>66528,61780.310883228</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListeAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "194-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("194-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListeAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["194-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListeAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListeAvantPEC.Record" complexBatchManaged="1" label="194-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListeAvantPEC'
on 2023-03-08 at 13:47:55.600 [2023-03-08 13:47:55.600 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49675.627531592</TimeChanged>
<TimeCreated>66541,49675.60039198</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListeAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP5A61.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP5A61.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP5A61.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP5A61.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListeDebut'
on 2023-03-08 at 13:47:47.593 [2023-03-08 13:47:47.593 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.594324222</TimeChanged>
<TimeCreated>66528,58721.578058709</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListeDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "142-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("142-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListeDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["142-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListeDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListeDebut.Record" complexBatchManaged="1" label="142-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListeDebut'
on 2023-03-08 at 13:47:47.587 [2023-03-08 13:47:47.587 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.615467328</TimeChanged>
<TimeCreated>66541,49667.58769612</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListeDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPB346.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPB346.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPB346.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPB346.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListeDebutPar'
on 2023-03-08 at 13:47:51.594 [2023-03-08 13:47:51.594 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.595426172</TimeChanged>
<TimeCreated>66528,60380.822788513</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListeDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "168-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("168-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListeDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["168-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListeDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListeDebutPar.Record" complexBatchManaged="1" label="168-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListeDebutPar'
on 2023-03-08 at 13:47:51.589 [2023-03-08 13:47:51.589 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.616703278</TimeChanged>
<TimeCreated>66541,49671.58955127</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListeDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP413D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP413D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP413D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP413D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListeFin'
on 2023-03-08 at 13:47:49.589 [2023-03-08 13:47:49.589 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.590681945</TimeChanged>
<TimeCreated>66528,59300.79366851</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListeFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "155-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("155-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListeFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["155-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListeFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListeFin.Record" complexBatchManaged="1" label="155-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListeFin'
on 2023-03-08 at 13:47:49.584 [2023-03-08 13:47:49.584 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.611711752</TimeChanged>
<TimeCreated>66541,49669.584863943</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListeFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP4ADA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP4ADA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP4ADA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP4ADA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDansListeFinPar'
on 2023-03-08 at 13:47:53.596 [2023-03-08 13:47:53.596 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.597130071</TimeChanged>
<TimeCreated>66528,61169.493202648</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDansListeFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "181-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("181-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDansListeFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["181-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDansListeFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDansListeFinPar.Record" complexBatchManaged="1" label="181-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDansListeFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDansListeFinPar'
on 2023-03-08 at 13:47:53.591 [2023-03-08 13:47:53.591 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.61818108</TimeChanged>
<TimeCreated>66541,49673.591212768</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDansListeFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP3FBF.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP3FBF.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP3FBF.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP3FBF.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDebut'
on 2023-03-08 at 13:47:45.745 [2023-03-08 13:47:45.745 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.746630344</TimeChanged>
<TimeCreated>66528,55395.324061986</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "130-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("130-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["130-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDebut.Record" complexBatchManaged="1" label="130-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDebut'
on 2023-03-08 at 13:47:45.740 [2023-03-08 13:47:45.740 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.767548051</TimeChanged>
<TimeCreated>66541,49665.740929243</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP96A8.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP96A8.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP96A8.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP96A8.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunDebutPar'
on 2023-03-08 at 13:47:49.743 [2023-03-08 13:47:49.743 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.743838493</TimeChanged>
<TimeCreated>66528,59343.305228093</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "156-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("156-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["156-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunDebutPar.Record" complexBatchManaged="1" label="156-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunDebutPar'
on 2023-03-08 at 13:47:49.738 [2023-03-08 13:47:49.738 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.7649508</TimeChanged>
<TimeCreated>66541,49669.738088891</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPE447.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPE447.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPE447.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPE447.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunFin'
on 2023-03-08 at 13:47:47.747 [2023-03-08 13:47:47.747 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.74782987</TimeChanged>
<TimeCreated>66528,58766.016153595</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "143-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("143-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["143-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunFin.Record" complexBatchManaged="1" label="143-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunFin'
on 2023-03-08 at 13:47:47.741 [2023-03-08 13:47:47.741 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.768711276</TimeChanged>
<TimeCreated>66541,49667.741752268</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPB84C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPB84C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPB84C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPB84C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAucunFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAucunFinPar'
on 2023-03-08 at 13:47:51.748 [2023-03-08 13:47:51.748 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.749434733</TimeChanged>
<TimeCreated>66528,60419.915330969</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAucunFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "169-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("169-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAucunFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["169-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAucunFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAucunFinPar.Record" complexBatchManaged="1" label="169-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAucunFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAucunFinPar'
on 2023-03-08 at 13:47:51.743 [2023-03-08 13:47:51.743 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.770431742</TimeChanged>
<TimeCreated>66541,49671.74370813</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAucunFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP731A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP731A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP731A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP731A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutres">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutres'
on 2023-03-08 at 13:47:37.436 [2023-03-08 13:47:37.436 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.436997949</TimeChanged>
<TimeCreated>66527,37858.817842273</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutres.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "076-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("076-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutres.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["076-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutres" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutres.Record" complexBatchManaged="1" label="076-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutres.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutres'
on 2023-03-08 at 13:47:37.431 [2023-03-08 13:47:37.431 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.457749354</TimeChanged>
<TimeCreated>66541,49657.431267948</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutres.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP9CF6.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP9CF6.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP9CF6.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP9CF6.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutresAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutresAvantPEC'
on 2023-03-08 at 13:47:55.450 [2023-03-08 13:47:55.450 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49675.451019312</TimeChanged>
<TimeCreated>66528,61734.199691889</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutresAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "193-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("193-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutresAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["193-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutresAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutresAvantPEC.Record" complexBatchManaged="1" label="193-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutresAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutresAvantPEC'
on 2023-03-08 at 13:47:55.445 [2023-03-08 13:47:55.445 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49675.472334522</TimeChanged>
<TimeCreated>66541,49675.445145709</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutresAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP6488.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP6488.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP6488.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP6488.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutresDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutresDebut'
on 2023-03-08 at 13:47:47.439 [2023-03-08 13:47:47.439 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.440018673</TimeChanged>
<TimeCreated>66528,58669.240648337</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutresDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "141-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("141-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutresDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["141-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutresDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutresDebut.Record" complexBatchManaged="1" label="141-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutresDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutresDebut'
on 2023-03-08 at 13:47:47.434 [2023-03-08 13:47:47.434 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.46122458</TimeChanged>
<TimeCreated>66541,49667.434204072</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutresDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPEF8F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPEF8F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPEF8F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPEF8F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutresDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutresDebutPar'
on 2023-03-08 at 13:47:51.441 [2023-03-08 13:47:51.441 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.441793024</TimeChanged>
<TimeCreated>66528,60336.459462284</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutresDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "167-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("167-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutresDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["167-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutresDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutresDebutPar.Record" complexBatchManaged="1" label="167-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutresDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutresDebutPar'
on 2023-03-08 at 13:47:51.436 [2023-03-08 13:47:51.436 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.46285943</TimeChanged>
<TimeCreated>66541,49671.436080922</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutresDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP7FD4.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP7FD4.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP7FD4.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP7FD4.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutresFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutresFin'
on 2023-03-08 at 13:47:49.435 [2023-03-08 13:47:49.435 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.436518497</TimeChanged>
<TimeCreated>66528,59250.866330988</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutresFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "154-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("154-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutresFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["154-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutresFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutresFin.Record" complexBatchManaged="1" label="154-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutresFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutresFin'
on 2023-03-08 at 13:47:49.430 [2023-03-08 13:47:49.430 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.457595604</TimeChanged>
<TimeCreated>66541,49669.430862595</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutresFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP5BC7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP5BC7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP5BC7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP5BC7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPAutresFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPAutresFinPar'
on 2023-03-08 at 13:47:53.442 [2023-03-08 13:47:53.442 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.443068201</TimeChanged>
<TimeCreated>66528,61117.276288722</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPAutresFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "180-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("180-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPAutresFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["180-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPAutresFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPAutresFinPar.Record" complexBatchManaged="1" label="180-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPAutresFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPAutresFinPar'
on 2023-03-08 at 13:47:53.437 [2023-03-08 13:47:53.437 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.46393361</TimeChanged>
<TimeCreated>66541,49673.437307498</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPAutresFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP6923.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP6923.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP6923.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP6923.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiques">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiques'
on 2023-03-08 at 13:47:37.130 [2023-03-08 13:47:37.130 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.131034373</TimeChanged>
<TimeCreated>66527,37740.511684986</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiques.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "074-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("074-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiques.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["074-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiques" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiques.Record" complexBatchManaged="1" label="074-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiques.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiques'
on 2023-03-08 at 13:47:37.125 [2023-03-08 13:47:37.125 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.152558479</TimeChanged>
<TimeCreated>66541,49657.125227372</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiques.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP92AC.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP92AC.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP92AC.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP92AC.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiquesAvantPEC'
on 2023-03-08 at 13:47:54.679 [2023-03-08 13:47:54.679 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.679825562</TimeChanged>
<TimeCreated>66528,61496.92494216</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiquesAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "188-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("188-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiquesAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["188-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiquesAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiquesAvantPEC.Record" complexBatchManaged="1" label="188-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiquesAvantPEC'
on 2023-03-08 at 13:47:54.674 [2023-03-08 13:47:54.674 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.701007572</TimeChanged>
<TimeCreated>66541,49674.673996459</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiquesAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPE7E2.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPE7E2.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPE7E2.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPE7E2.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiquesDebut'
on 2023-03-08 at 13:47:46.671 [2023-03-08 13:47:46.671 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.672078834</TimeChanged>
<TimeCreated>66528,58355.526760191</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiquesDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "136-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("136-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiquesDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["136-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiquesDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiquesDebut.Record" complexBatchManaged="1" label="136-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiquesDebut'
on 2023-03-08 at 13:47:46.666 [2023-03-08 13:47:46.666 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.69344164</TimeChanged>
<TimeCreated>66541,49666.666303532</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiquesDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPHAD5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPHAD5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPHAD5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPHAD5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiquesDebutPar'
on 2023-03-08 at 13:47:50.672 [2023-03-08 13:47:50.672 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.673030683</TimeChanged>
<TimeCreated>66528,60121.539167967</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiquesDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "162-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("162-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiquesDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["162-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiquesDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiquesDebutPar.Record" complexBatchManaged="1" label="162-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiquesDebutPar'
on 2023-03-08 at 13:47:50.667 [2023-03-08 13:47:50.667 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.69400179</TimeChanged>
<TimeCreated>66541,49670.667204382</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiquesDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPFCBE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPFCBE.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPFCBE.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPFCBE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiquesFin'
on 2023-03-08 at 13:47:48.669 [2023-03-08 13:47:48.669 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.670671758</TimeChanged>
<TimeCreated>66528,59021.91130802</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiquesFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "149-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("149-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiquesFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["149-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiquesFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiquesFin.Record" complexBatchManaged="1" label="149-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiquesFin'
on 2023-03-08 at 13:47:48.664 [2023-03-08 13:47:48.664 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.691624464</TimeChanged>
<TimeCreated>66541,49668.664898956</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiquesFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP28E3.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP28E3.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP28E3.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP28E3.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPHypnotiquesFinPar'
on 2023-03-08 at 13:47:52.672 [2023-03-08 13:47:52.672 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.672807952</TimeChanged>
<TimeCreated>66528,60879.037743958</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPHypnotiquesFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "175-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("175-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPHypnotiquesFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["175-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPHypnotiquesFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPHypnotiquesFinPar.Record" complexBatchManaged="1" label="175-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPHypnotiquesFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPHypnotiquesFinPar'
on 2023-03-08 at 13:47:52.667 [2023-03-08 13:47:52.667 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.694063161</TimeChanged>
<TimeCreated>66541,49672.667061149</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPHypnotiquesFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP5246.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP5246.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP5246.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP5246.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetyl">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetyl'
on 2023-03-08 at 13:47:36.365 [2023-03-08 13:47:36.365 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.365718784</TimeChanged>
<TimeCreated>66527,36719.32997981</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetyl.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "069-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("069-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetyl.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["069-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetyl" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetyl.Record" complexBatchManaged="1" label="069-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetyl.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetyl'
on 2023-03-08 at 13:47:36.359 [2023-03-08 13:47:36.359 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.386840189</TimeChanged>
<TimeCreated>66541,49656.359930582</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetyl.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP9BAF.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP9BAF.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP9BAF.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP9BAF.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetylAvantPEC'
on 2023-03-08 at 13:47:53.906 [2023-03-08 13:47:53.906 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.906897711</TimeChanged>
<TimeCreated>66528,61271.795257758</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetylAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "183-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("183-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetylAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["183-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetylAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetylAvantPEC.Record" complexBatchManaged="1" label="183-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetylAvantPEC'
on 2023-03-08 at 13:47:53.901 [2023-03-08 13:47:53.901 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.927975821</TimeChanged>
<TimeCreated>66541,49673.901002409</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetylAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPF23B.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPF23B.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPF23B.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPF23B.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetylDebut'
on 2023-03-08 at 13:47:45.898 [2023-03-08 13:47:45.898 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.899302092</TimeChanged>
<TimeCreated>66528,58066.200977261</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetylDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "131-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("131-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetylDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["131-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetylDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetylDebut.Record" complexBatchManaged="1" label="131-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetylDebut'
on 2023-03-08 at 13:47:45.893 [2023-03-08 13:47:45.893 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.920617999</TimeChanged>
<TimeCreated>66541,49665.89347249</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetylDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP9692.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP9692.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP9692.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP9692.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetylDebutPar'
on 2023-03-08 at 13:47:49.896 [2023-03-08 13:47:49.896 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.897222741</TimeChanged>
<TimeCreated>66528,59387.729130613</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetylDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "157-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("157-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetylDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["157-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetylDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetylDebutPar.Record" complexBatchManaged="1" label="157-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetylDebutPar'
on 2023-03-08 at 13:47:49.891 [2023-03-08 13:47:49.891 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.918510848</TimeChanged>
<TimeCreated>66541,49669.891386339</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetylDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPE967.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPE967.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPE967.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPE967.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetylFin'
on 2023-03-08 at 13:47:47.900 [2023-03-08 13:47:47.900 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.900814017</TimeChanged>
<TimeCreated>66528,58820.49905844</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetylFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "144-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("144-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetylFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["144-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetylFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetylFin.Record" complexBatchManaged="1" label="144-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetylFin'
on 2023-03-08 at 13:47:47.895 [2023-03-08 13:47:47.895 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.921925824</TimeChanged>
<TimeCreated>66541,49667.895055316</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetylFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP7815.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP7815.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP7815.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP7815.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPInhibAcetylFinPar'
on 2023-03-08 at 13:47:51.901 [2023-03-08 13:47:51.901 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.902408402</TimeChanged>
<TimeCreated>66528,60474.180134728</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPInhibAcetylFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "170-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("170-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPInhibAcetylFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["170-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPInhibAcetylFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPInhibAcetylFinPar.Record" complexBatchManaged="1" label="170-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPInhibAcetylFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPInhibAcetylFinPar'
on 2023-03-08 at 13:47:51.896 [2023-03-08 13:47:51.896 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.923547312</TimeChanged>
<TimeCreated>66541,49671.896611699</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPInhibAcetylFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP609A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP609A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP609A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP609A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiques">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiques'
on 2023-03-08 at 13:47:36.823 [2023-03-08 13:47:36.823 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49656.824478897</TimeChanged>
<TimeCreated>66527,37462.567573338</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiques.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "072-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("072-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiques.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["072-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiques" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiques.Record" complexBatchManaged="1" label="072-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiques.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiques'
on 2023-03-08 at 13:47:36.818 [2023-03-08 13:47:36.818 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49656.845830603</TimeChanged>
<TimeCreated>66541,49656.818585296</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiques.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP1532.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP1532.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP1532.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP1532.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiquesAvantPEC'
on 2023-03-08 at 13:47:54.369 [2023-03-08 13:47:54.369 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.369917821</TimeChanged>
<TimeCreated>66528,61405.51804175</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiquesAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "186-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("186-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiquesAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["186-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiquesAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiquesAvantPEC.Record" complexBatchManaged="1" label="186-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiquesAvantPEC'
on 2023-03-08 at 13:47:54.364 [2023-03-08 13:47:54.364 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.391291431</TimeChanged>
<TimeCreated>66541,49674.364108219</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiquesAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPNF9D.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPNF9D.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPNF9D.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPNF9D.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiquesDebut'
on 2023-03-08 at 13:47:46.363 [2023-03-08 13:47:46.363 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.364272937</TimeChanged>
<TimeCreated>66528,58255.815308517</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiquesDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "134-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("134-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiquesDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["134-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiquesDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiquesDebut.Record" complexBatchManaged="1" label="134-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiquesDebut'
on 2023-03-08 at 13:47:46.357 [2023-03-08 13:47:46.357 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.385493544</TimeChanged>
<TimeCreated>66541,49666.357025335</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiquesDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP6254.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP6254.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP6254.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP6254.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiquesDebutPar'
on 2023-03-08 at 13:47:50.363 [2023-03-08 13:47:50.363 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.364602287</TimeChanged>
<TimeCreated>66528,59507.838385527</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiquesDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "160-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("160-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiquesDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["160-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiquesDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiquesDebutPar.Record" complexBatchManaged="1" label="160-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiquesDebutPar'
on 2023-03-08 at 13:47:50.358 [2023-03-08 13:47:50.358 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.385561594</TimeChanged>
<TimeCreated>66541,49670.358685785</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiquesDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP14C1.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP14C1.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP14C1.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP14C1.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiquesFin'
on 2023-03-08 at 13:47:48.364 [2023-03-08 13:47:48.364 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.365218362</TimeChanged>
<TimeCreated>66528,58945.969477905</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiquesFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "147-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("147-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiquesFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["147-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiquesFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiquesFin.Record" complexBatchManaged="1" label="147-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiquesFin'
on 2023-03-08 at 13:47:48.359 [2023-03-08 13:47:48.359 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.386078669</TimeChanged>
<TimeCreated>66541,49668.359372761</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiquesFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP36E1.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP36E1.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP36E1.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP36E1.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNeuroleptiquesFinPar'
on 2023-03-08 at 13:47:52.363 [2023-03-08 13:47:52.363 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.364538212</TimeChanged>
<TimeCreated>66528,60613.226261688</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNeuroleptiquesFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "173-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("173-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNeuroleptiquesFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["173-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNeuroleptiquesFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNeuroleptiquesFinPar.Record" complexBatchManaged="1" label="173-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNeuroleptiquesFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNeuroleptiquesFinPar'
on 2023-03-08 at 13:47:52.358 [2023-03-08 13:47:52.358 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.385871921</TimeChanged>
<TimeCreated>66541,49672.358697009</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNeuroleptiquesFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP32EE.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP32EE.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP32EE.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP32EE.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropes">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropes'
on 2023-03-08 at 13:47:37.283 [2023-03-08 13:47:37.283 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49657.284062711</TimeChanged>
<TimeCreated>66527,37808.419600204</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropes.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "075-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("075-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropes.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["075-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropes" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropes.Record" complexBatchManaged="1" label="075-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropes.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropes'
on 2023-03-08 at 13:47:37.278 [2023-03-08 13:47:37.278 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49657.305097416</TimeChanged>
<TimeCreated>66541,49657.27829551</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropes.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP2BFA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP2BFA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP2BFA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP2BFA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropesAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropesAvantPEC'
on 2023-03-08 at 13:47:54.833 [2023-03-08 13:47:54.833 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49674.833811932</TimeChanged>
<TimeCreated>66528,61552.169220935</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropesAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "189-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("189-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropesAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["189-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropesAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropesAvantPEC.Record" complexBatchManaged="1" label="189-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropesAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropesAvantPEC'
on 2023-03-08 at 13:47:54.827 [2023-03-08 13:47:54.827 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49674.854643941</TimeChanged>
<TimeCreated>66541,49674.827951929</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropesAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP3A4F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP3A4F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP3A4F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP3A4F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropesDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropesDebut'
on 2023-03-08 at 13:47:46.825 [2023-03-08 13:47:46.825 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49666.825863282</TimeChanged>
<TimeCreated>66528,58461.307634299</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropesDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "137-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("137-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropesDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["137-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropesDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropesDebut.Record" complexBatchManaged="1" label="137-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropesDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropesDebut'
on 2023-03-08 at 13:47:46.820 [2023-03-08 13:47:46.820 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49666.847022388</TimeChanged>
<TimeCreated>66541,49666.82011548</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropesDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP5AB8.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP5AB8.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP5AB8.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP5AB8.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropesDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropesDebutPar'
on 2023-03-08 at 13:47:50.825 [2023-03-08 13:47:50.825 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49670.826260231</TimeChanged>
<TimeCreated>66528,60163.003979319</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropesDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "163-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("163-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropesDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["163-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropesDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropesDebutPar.Record" complexBatchManaged="1" label="163-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropesDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropesDebutPar'
on 2023-03-08 at 13:47:50.820 [2023-03-08 13:47:50.820 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49670.847311538</TimeChanged>
<TimeCreated>66541,49670.82049503</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropesDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP2113.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP2113.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP2113.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP2113.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropesFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropesFin'
on 2023-03-08 at 13:47:48.823 [2023-03-08 13:47:48.823 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49668.823695706</TimeChanged>
<TimeCreated>66528,59069.828946553</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropesFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "150-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("150-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropesFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["150-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropesFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropesFin.Record" complexBatchManaged="1" label="150-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropesFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropesFin'
on 2023-03-08 at 13:47:48.817 [2023-03-08 13:47:48.817 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49668.844681312</TimeChanged>
<TimeCreated>66541,49668.817952204</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropesFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPA870.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPA870.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPA870.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPA870.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPNootropesFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPNootropesFinPar'
on 2023-03-08 at 13:47:52.825 [2023-03-08 13:47:52.825 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49672.826378921</TimeChanged>
<TimeCreated>66528,60932.067329128</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPNootropesFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "176-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("176-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPNootropesFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["176-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPNootropesFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPNootropesFinPar.Record" complexBatchManaged="1" label="176-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPNootropesFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPNootropesFinPar'
on 2023-03-08 at 13:47:52.820 [2023-03-08 13:47:52.820 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49672.847488431</TimeChanged>
<TimeCreated>66541,49672.820578119</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPNootropesFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPBFD7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPBFD7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPBFD7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPBFD7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateurs">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateurs'
on 2023-03-08 at 13:47:45.437 [2023-03-08 13:47:45.437 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49665.438232448</TimeChanged>
<TimeCreated>66528,55272.338453856</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateurs.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "128-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("128-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateurs.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["128-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateurs" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateurs.Record" complexBatchManaged="1" label="128-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateurs.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateurs'
on 2023-03-08 at 13:47:45.431 [2023-03-08 13:47:45.431 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49665.459497655</TimeChanged>
<TimeCreated>66541,49665.431562946</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateurs.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTP92BA.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTP92BA.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTP92BA.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTP92BA.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursAvantPEC">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateursAvantPEC'
on 2023-03-08 at 13:47:55.140 [2023-03-08 13:47:55.140 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49675.141657372</TimeChanged>
<TimeCreated>66528,61647.98048427</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateursAvantPEC.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "191-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("191-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateursAvantPEC.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["191-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateursAvantPEC" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateursAvantPEC.Record" complexBatchManaged="1" label="191-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursAvantPEC.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateursAvantPEC'
on 2023-03-08 at 13:47:55.135 [2023-03-08 13:47:55.135 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49675.162962181</TimeChanged>
<TimeCreated>66541,49675.135742769</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateursAvantPEC.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPC163.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPC163.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPC163.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPC163.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursDebut">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateursDebut'
on 2023-03-08 at 13:47:47.132 [2023-03-08 13:47:47.132 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49667.133283978</TimeChanged>
<TimeCreated>66528,58555.267616996</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateursDebut.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "139-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("139-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateursDebut.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["139-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateursDebut" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateursDebut.Record" complexBatchManaged="1" label="139-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursDebut.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateursDebut'
on 2023-03-08 at 13:47:47.127 [2023-03-08 13:47:47.127 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49667.154510284</TimeChanged>
<TimeCreated>66541,49667.127383076</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateursDebut.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPC99C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPC99C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPC99C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPC99C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursDebutPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateursDebutPar'
on 2023-03-08 at 13:47:51.132 [2023-03-08 13:47:51.132 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49671.133445627</TimeChanged>
<TimeCreated>66528,60255.849464171</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateursDebutPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "165-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("165-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateursDebutPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["165-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateursDebutPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateursDebutPar.Record" complexBatchManaged="1" label="165-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursDebutPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateursDebutPar'
on 2023-03-08 at 13:47:51.127 [2023-03-08 13:47:51.127 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49671.154886334</TimeChanged>
<TimeCreated>66541,49671.127563525</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateursDebutPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPDA3F.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPDA3F.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPDA3F.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPDA3F.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursFin">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateursFin'
on 2023-03-08 at 13:47:49.129 [2023-03-08 13:47:49.129 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49669.129831901</TimeChanged>
<TimeCreated>66528,59161.898532716</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateursFin.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "152-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("152-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateursFin.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["152-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateursFin" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateursFin.Record" complexBatchManaged="1" label="152-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursFin.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateursFin'
on 2023-03-08 at 13:47:49.124 [2023-03-08 13:47:49.124 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49669.151107408</TimeChanged>
<TimeCreated>66541,49669.1239672</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateursFin.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPEC02.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPEC02.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPEC02.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPEC02.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursFinPar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTPThymoRegulateursFinPar'
on 2023-03-08 at 13:47:53.133 [2023-03-08 13:47:53.133 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49673.134675061</TimeChanged>
<TimeCreated>66528,61027.480265297</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTPThymoRegulateursFinPar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "178-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("178-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTPThymoRegulateursFinPar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["178-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTPThymoRegulateursFinPar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTPThymoRegulateursFinPar.Record" complexBatchManaged="1" label="178-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTPThymoRegulateursFinPar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTPThymoRegulateursFinPar'
on 2023-03-08 at 13:47:53.128 [2023-03-08 13:47:53.128 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49673.156238171</TimeChanged>
<TimeCreated>66541,49673.128807058</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTPThymoRegulateursFinPar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTPA444.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTPA444.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTPA444.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTPA444.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.DclTypeActe">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.DclTypeActe'
on 2023-03-08 at 13:47:34.196 [2023-03-08 13:47:34.196 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49654.197655375</TimeChanged>
<TimeCreated>66527,35672.94334127</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.DclTypeActe.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "055-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("055-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.DclTypeActe.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["055-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.DclTypeActe" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.DclTypeActe.Record" complexBatchManaged="1" label="055-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.DclTypeActe.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.DclTypeActe'
on 2023-03-08 at 13:47:34.191 [2023-03-08 13:47:34.191 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49654.218820967</TimeChanged>
<TimeCreated>66541,49654.191818478</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.DclTypeActe.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.DclTyEB59.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.DclTyEB59.RecordD</IdLocation>
<IndexLocation>^Patientrecord.DclTyEB59.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.DclTyEB59.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientAccompagnant">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientAccompagnant'
on 2023-03-08 at 13:47:43.121 [2023-03-08 13:47:43.121 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49663.122524659</TimeChanged>
<TimeCreated>66527,49407.419992761</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientAccompagnant.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "113-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("113-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientAccompagnant.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["113-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientAccompagnant" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientAccompagnant.Record" complexBatchManaged="1" label="113-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientAccompagnant.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientAccompagnant'
on 2023-03-08 at 13:47:43.116 [2023-03-08 13:47:43.116 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49663.143213164</TimeChanged>
<TimeCreated>66541,49663.116743457</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientAccompagnant.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.PatieC24A.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.PatieC24A.RecordD</IdLocation>
<IndexLocation>^Patientrecord.PatieC24A.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.PatieC24A.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientAnneeNaissance">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientAnneeNaissance'
on 2023-03-08 at 13:47:33.123 [2023-03-08 13:47:33.123 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.124591201</TimeChanged>
<TimeCreated>66526,51706.720905108</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientAnneeNaissance.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "048-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.PatientAnneeNaissance = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("048-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.PatientAnneeNaissance,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientAnneeNaissance.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["048-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientAnneeNaissance" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientAnneeNaissance.Record" complexBatchManaged="1" label="048-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="PatientAnneeNaissance" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientAnneeNaissance.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientAnneeNaissance'
on 2023-03-08 at 13:47:33.118 [2023-03-08 13:47:33.118 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.145923793</TimeChanged>
<TimeCreated>66541,49653.118703803</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PatientAnneeNaissance">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientAnneeNaissance.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patie7A6E.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patie7A6E.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patie7A6E.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patie7A6E.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientAnneeNaissance</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientComplexeRecord.Batch">
<Description>
RECORDMAP: Modified during compilation of Complex RecordMap 'Patientrecord.PatientComplexeRecord'
on 2023-03-08 at 13:47:25.871 [2023-03-08 13:47:25.871 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexBatch,Ens.Request</Super>
<TimeChanged>66541,49675.919422224</TimeChanged>
<TimeCreated>66541,49645.871246309</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Property name="CentreNom">
<Type>Patientrecord.CentreNom.Record</Type>
</Property>

<Property name="CentreAdRue1">
<Type>Patientrecord.CentreAdRue1.Record</Type>
</Property>

<Property name="CentreAdRue2">
<Type>Patientrecord.CentreAdRue2.Record</Type>
</Property>

<Property name="CentreAdCp">
<Type>Patientrecord.CentreAdCp.Record</Type>
</Property>

<Property name="CentreAdVille">
<Type>Patientrecord.CentreAdVille.Record</Type>
</Property>

<Property name="CentreMail">
<Type>Patientrecord.CentreMail.Record</Type>
</Property>

<Property name="CentreType">
<Type>Patientrecord.CentreType.Record</Type>
</Property>

<Property name="CentreNum">
<Type>Patientrecord.CentreNum.Record</Type>
</Property>

<Property name="CentreResponsable">
<Type>Patientrecord.CentreResponsable.Record</Type>
</Property>

<Property name="CentreLabel">
<Type>Patientrecord.CentreLabel.Record</Type>
</Property>

<Property name="CentreLabelAnnee">
<Type>Patientrecord.CentreLabelAnnee.Record</Type>
</Property>

<Property name="CentreReseau">
<Type>Patientrecord.CentreReseau.Record</Type>
</Property>

<Property name="CentreNomReseau">
<Type>Patientrecord.CentreNomReseau.Record</Type>
</Property>

<Property name="CentreInclusion">
<Type>Patientrecord.CentreInclusion.Record</Type>
</Property>

<Property name="CentreMultisite">
<Type>Patientrecord.CentreMultisite.Record</Type>
</Property>

<Property name="CentreHdj">
<Type>Patientrecord.CentreHdj.Record</Type>
</Property>

<Property name="CentreOuvConsultation">
<Type>Patientrecord.CentreOuvConsultation.Record</Type>
</Property>

<Property name="CentrePersoGeriatre">
<Type>Patientrecord.CentrePersoGeriatre.Record</Type>
</Property>

<Property name="CentrePersoNeurologue">
<Type>Patientrecord.CentrePersoNeurologue.Record</Type>
</Property>

<Property name="CentrePersoPsychiatre">
<Type>Patientrecord.CentrePersoPsychiatre.Record</Type>
</Property>

<Property name="CentrePersoPsychologue">
<Type>Patientrecord.CentrePersoPsychologue.Record</Type>
</Property>

<Property name="CentrePersoOrthophoniste">
<Type>Patientrecord.CentrePersoOrthophoniste.Record</Type>
</Property>

<Property name="CentrePersoKine">
<Type>Patientrecord.CentrePersoKine.Record</Type>
</Property>

<Property name="CentrePersoASocial">
<Type>Patientrecord.CentrePersoASocial.Record</Type>
</Property>

<Property name="CentrePersoSecretaire">
<Type>Patientrecord.CentrePersoSecretaire.Record</Type>
</Property>

<Property name="CentrePersoIDE">
<Type>Patientrecord.CentrePersoIDE.Record</Type>
</Property>

<Property name="CentrePersoARC">
<Type>Patientrecord.CentrePersoARC.Record</Type>
</Property>

<Property name="CentrePersoTEC">
<Type>Patientrecord.CentrePersoTEC.Record</Type>
</Property>

<Property name="CentrePersoAutre">
<Type>Patientrecord.CentrePersoAutre.Record</Type>
</Property>

<Property name="CentrePersoDescriptionAutre">
<Type>Patientrecord.CentrePersoDescriptionAutre.Record</Type>
</Property>

<Property name="CmrrPublications">
<Type>Patientrecord.CmrrPublications.Record</Type>
</Property>

<Property name="CmrrFormationsUniv">
<Type>Patientrecord.CmrrFormationsUniv.Record</Type>
</Property>

<Property name="enregistrement10">
<Type>Patientrecord.CmrrActiviteFormation.Record</Type>
</Property>

<Property name="CmrrActiviteAnimation">
<Type>Patientrecord.CmrrActiviteAnimation.Record</Type>
</Property>

<Property name="CmrrActiviteRecherche">
<Type>Patientrecord.CmrrActiviteRecherche.Record</Type>
</Property>

<Property name="CmrrActiviteEthique">
<Type>Patientrecord.CmrrActiviteEthique.Record</Type>
</Property>

<Property name="CmrrCmActiviteSoutien">
<Type>Patientrecord.CmrrCmActiviteSoutien.Record</Type>
</Property>

<Property name="CmrrCmActiviteStimul">
<Type>Patientrecord.CmrrCmActiviteStimul.Record</Type>
</Property>

<Property name="ClTypeSpecialiste">
<Type>Patientrecord.ClTypeSpecialiste.Record</Type>
</Property>

<Property name="ClCollabNeuroPsy">
<Type>Patientrecord.ClCollabNeuroPsy.Record</Type>
</Property>

<Property name="ClPratiqueETP">
<Type>Patientrecord.ClPratiqueETP.Record</Type>
</Property>

<Property name="ClActiviteConsultMemoire">
<Type>Patientrecord.ClActiviteConsultMemoire.Record</Type>
</Property>

<Property name="ClCollabCmCmrr">
<Type>Patientrecord.ClCollabCmCmrr.Record</Type>
</Property>

<Property name="ClActiviteReseau">
<Type>Patientrecord.ClActiviteReseau.Record</Type>
</Property>

<Property name="ClNbFormAn">
<Type>Patientrecord.ClNbFormAn.Record</Type>
</Property>

<Property name="PatientId">
<Type>Patientrecord.PatientId.Record</Type>
</Property>

<Property name="PatientSexe">
<Type>Patientrecord.PatientSexe.Record</Type>
</Property>

<Property name="PatientAnneeNaissance">
<Type>Patientrecord.PatientAnneeNaissance.Record</Type>
</Property>

<Property name="PatientNiveauEtudes">
<Type>Patientrecord.PatientNiveauEtudes.Record</Type>
</Property>

<Property name="PatientSituationGeo">
<Type>Patientrecord.PatientSituationGeo.Record</Type>
</Property>

<Property name="atientEnvoyePar">
<Type>Patientrecord.PatientEnvoyePar.Record</Type>
</Property>

<Property name="DclEtatDemence">
<Type>Patientrecord.DclEtatDemence.Record</Type>
</Property>

<Property name="DclAnneePremierDiag">
<Type>Patientrecord.DclAnneePremierDiag.Record</Type>
</Property>

<Property name="DclDiagnostic">
<Type>Patientrecord.DclDiagnostic.Record</Type>
</Property>

<Property name="DclTypeActe">
<Type>Patientrecord.DclTypeActe.Record</Type>
</Property>

<Property name="DclDateActe">
<Type>Patientrecord.DclDateActe.Record</Type>
</Property>

<Property name="DclMMSE">
<Type>Patientrecord.DclMMSE.Record</Type>
</Property>

<Property name="DclIADLDetection">
<Type>Patientrecord.DclIADLDetection.Record</Type>
</Property>

<Property name="DclIADLConsequence">
<Type>Patientrecord.DclIADLConsequence.Record</Type>
</Property>

<Property name="DclModeDeVie">
<Type>Patientrecord.DclModeDeVie.Record</Type>
</Property>

<Property name="DclAPA">
<Type>Patientrecord.DclAPA.Record</Type>
</Property>

<Property name="DclALD">
<Type>Patientrecord.DclALD.Record</Type>
</Property>

<Property name="DclMesureProtection">
<Type>Patientrecord.DclMesureProtection.Record</Type>
</Property>

<Property name="DclFinSuivi">
<Type>Patientrecord.DclFinSuivi.Record</Type>
</Property>

<Property name="DclDateFinSuivi">
<Type>Patientrecord.DclDateFinSuivi.Record</Type>
</Property>

<Property name="DclDateEntreeInstitution">
<Type>Patientrecord.DclDateEntreeInstitution.Record</Type>
</Property>

<Property name="DclDateDeces">
<Type>Patientrecord.DclDateDeces.Record</Type>
</Property>

<Property name="DclTPAucun">
<Type>Patientrecord.DclTPAucun.Record</Type>
</Property>

<Property name="DclTPInhibAcetyl">
<Type>Patientrecord.DclTPInhibAcetyl.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDA">
<Type>Patientrecord.DclTPAntagonisteNMDA.Record</Type>
</Property>

<Property name="DclTPAntidepresseurs">
<Type>Patientrecord.DclTPAntidepresseurs.Record</Type>
</Property>

<Property name="DclTPNeuroleptiques">
<Type>Patientrecord.DclTPNeuroleptiques.Record</Type>
</Property>

<Property name="DclTPAnxiolitiques">
<Type>Patientrecord.DclTPAnxiolitiques.Record</Type>
</Property>

<Property name="DclTPHypnotiques">
<Type>Patientrecord.DclTPHypnotiques.Record</Type>
</Property>

<Property name="DclTPNootropes">
<Type>Patientrecord.DclTPNootropes.Record</Type>
</Property>

<Property name="DclTPAutres">
<Type>Patientrecord.DclTPAutres.Record</Type>
</Property>

<Property name="DclTPAucunDansListe">
<Type>Patientrecord.DclTPAucunDansListe.Record</Type>
</Property>

<Property name="DclEffetIndesirable">
<Type>Patientrecord.DclEffetIndesirable.Record</Type>
</Property>

<Property name="DclIPSRAucun">
<Type>Patientrecord.DclIPSRAucun.Record</Type>
</Property>

<Property name="DclIPSROrthophoniste">
<Type>Patientrecord.DclIPSROrthophoniste.Record</Type>
</Property>

<Property name="DclIPSRPsychologue">
<Type>Patientrecord.DclIPSRPsychologue.Record</Type>
</Property>

<Property name="DclIPSRKinesitherapeute">
<Type>Patientrecord.DclIPSRKinesitherapeute.Record</Type>
</Property>

<Property name="DclIPSRErgotherapeute">
<Type>Patientrecord.DclIPSRErgotherapeute.Record</Type>
</Property>

<Property name="DclIPSRGroupe">
<Type>Patientrecord.DclIPSRGroupe.Record</Type>
</Property>

<Property name="DclIPSRAccueilJour">
<Type>Patientrecord.DclIPSRAccueilJour.Record</Type>
</Property>

<Property name="DclIPSRMaia">
<Type>Patientrecord.DclIPSRMaia.Record</Type>
</Property>

<Property name="DclIPSRClic">
<Type>Patientrecord.DclIPSRClic.Record</Type>
</Property>

<Property name="DclIPSRRepits">
<Type>Patientrecord.DclIPSRRepits.Record</Type>
</Property>

<Property name="DclIPSRSiad">
<Type>Patientrecord.DclIPSRSiad.Record</Type>
</Property>

<Property name="DclIPSRAutre">
<Type>Patientrecord.DclIPSRAutre.Record</Type>
</Property>

<Property name="DclPCAucun">
<Type>Patientrecord.DclPCAucun.Record</Type>
</Property>

<Property name="DclPCIRM">
<Type>Patientrecord.DclPCIRM.Record</Type>
</Property>

<Property name="DclPCScanner">
<Type>Patientrecord.DclPCScanner.Record</Type>
</Property>

<Property name="DclPCSPECT">
<Type>Patientrecord.DclPCSPECT.Record</Type>
</Property>

<Property name="DclPCPET">
<Type>Patientrecord.DclPCPET.Record</Type>
</Property>

<Property name="DclPCBioMarqueurs">
<Type>Patientrecord.DclPCBioMarqueurs.Record</Type>
</Property>

<Property name="DclPR">
<Type>Patientrecord.DclPR.Record</Type>
</Property>

<Property name="DclPRType">
<Type>Patientrecord.DclPRType.Record</Type>
</Property>

<Property name="DclPRVisite">
<Type>Patientrecord.DclPRVisite.Record</Type>
</Property>

<Property name="RetourMail">
<Type>Patientrecord.RetourMail.Record</Type>
</Property>

<Property name="PatientIdPrecedent">
<Type>Patientrecord.PatientIdPrecedent.Record</Type>
</Property>

<Property name="Application">
<Type>Patientrecord.Application.Record</Type>
</Property>

<Property name="CentreNumRmes">
<Type>Patientrecord.CentreNumRmes.Record</Type>
</Property>

<Property name="CentreNumFiness">
<Type>Patientrecord.CentreNumFiness.Record</Type>
</Property>

<Property name="CentreNumAdeli">
<Type>Patientrecord.CentreNumAdeli.Record</Type>
</Property>

<Property name="CentreNumRpps">
<Type>Patientrecord.CentreNumRpps.Record</Type>
</Property>

<Property name="DclCmrrRecours">
<Type>Patientrecord.DclCmrrRecours.Record</Type>
</Property>

<Property name="DclCmrrRecoursDiagDiff">
<Type>Patientrecord.DclCmrrRecoursDiagDiff.Record</Type>
</Property>

<Property name="DclCmrrRecoursSuivi">
<Type>Patientrecord.DclCmrrRecoursSuivi.Record</Type>
</Property>

<Property name="DclCmrrRecoursPTech">
<Type>Patientrecord.DclCmrrRecoursPTech.Record</Type>
</Property>

<Property name="DclCmrrRecoursSpExpert">
<Type>Patientrecord.DclCmrrRecoursSpExpert.Record</Type>
</Property>

<Property name="PatientProfession">
<Type>Patientrecord.PatientProfession.Record</Type>
</Property>

<Property name="PatientAccompagnant">
<Type>Patientrecord.PatientAccompagnant.Record</Type>
</Property>

<Property name="DclIPSREsad">
<Type>Patientrecord.DclIPSREsad.Record</Type>
</Property>

<Property name="DclIPSRHdj">
<Type>Patientrecord.DclIPSRHdj.Record</Type>
</Property>

<Property name="DclIPSRUcc">
<Type>Patientrecord.DclIPSRUcc.Record</Type>
</Property>

<Property name="DclRechPresDispo">
<Type>Patientrecord.DclRechPresDispo.Record</Type>
</Property>

<Property name="DclRechAutonom">
<Type>Patientrecord.DclRechAutonom.Record</Type>
</Property>

<Property name="DclRechContreIndic">
<Type>Patientrecord.DclRechContreIndic.Record</Type>
</Property>

<Property name="DclRechAcceptPlacebo">
<Type>Patientrecord.DclRechAcceptPlacebo.Record</Type>
</Property>

<Property name="DclDiagnosticN31">
<Type>Patientrecord.DclDiagnosticN31.Record</Type>
</Property>

<Property name="DclDiagnosticN32">
<Type>Patientrecord.DclDiagnosticN32.Record</Type>
</Property>

<Property name="DclDiagnosticN33">
<Type>Patientrecord.DclDiagnosticN33.Record</Type>
</Property>

<Property name="DclPECAidant">
<Type>Patientrecord.DclPECAidant.Record</Type>
</Property>

<Property name="DclIPSRGardeMalade">
<Type>Patientrecord.DclIPSRGardeMalade.Record</Type>
</Property>

<Property name="DclIPSRPAERPA">
<Type>Patientrecord.DclIPSRPAERPA.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiques">
<Type>Patientrecord.DclTPAntiEpileptiques.Record</Type>
</Property>

<Property name="DclTPThymoRegulateurs">
<Type>Patientrecord.DclTPThymoRegulateurs.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniens">
<Type>Patientrecord.DclTPAntiParkinsoniens.Record</Type>
</Property>

<Property name="DclTPAucunDebut">
<Type>Patientrecord.DclTPAucunDebut.Record</Type>
</Property>

<Property name="DclTPInhibAcetylDebut">
<Type>Patientrecord.DclTPInhibAcetylDebut.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDADebut">
<Type>Patientrecord.DclTPAntagonisteNMDADebut.Record</Type>
</Property>

<Property name="DclTPAntidepresseursDebut">
<Type>Patientrecord.DclTPAntidepresseursDebut.Record</Type>
</Property>

<Property name="DclTPNeuroleptiquesDebut">
<Type>Patientrecord.DclTPNeuroleptiquesDebut.Record</Type>
</Property>

<Property name="DclTPAnxiolitiquesDebut">
<Type>Patientrecord.DclTPAnxiolitiquesDebut.Record</Type>
</Property>

<Property name="DclTPHypnotiquesDebut">
<Type>Patientrecord.DclTPHypnotiquesDebut.Record</Type>
</Property>

<Property name="DclTPNootropesDebut">
<Type>Patientrecord.DclTPNootropesDebut.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiquesDebut">
<Type>Patientrecord.DclTPAntiEpileptiquesDebut.Record</Type>
</Property>

<Property name="DclTPThymoRegulateursDebut">
<Type>Patientrecord.DclTPThymoRegulateursDebut.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniensDebut">
<Type>Patientrecord.DclTPAntiParkinsoniensDebut.Record</Type>
</Property>

<Property name="DclTPAutresDebut">
<Type>Patientrecord.DclTPAutresDebut.Record</Type>
</Property>

<Property name="DclTPAucunDansListeDebut">
<Type>Patientrecord.DclTPAucunDansListeDebut.Record</Type>
</Property>

<Property name="DclTPAucunFin">
<Type>Patientrecord.DclTPAucunFin.Record</Type>
</Property>

<Property name="DclTPInhibAcetylFin">
<Type>Patientrecord.DclTPInhibAcetylFin.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDAFin">
<Type>Patientrecord.DclTPAntagonisteNMDAFin.Record</Type>
</Property>

<Property name="DclTPAntidepresseursFin">
<Type>Patientrecord.DclTPAntidepresseursFin.Record</Type>
</Property>

<Property name="DclTPNeuroleptiquesFin">
<Type>Patientrecord.DclTPNeuroleptiquesFin.Record</Type>
</Property>

<Property name="DclTPAnxiolitiquesFin">
<Type>Patientrecord.DclTPAnxiolitiquesFin.Record</Type>
</Property>

<Property name="DclTPHypnotiquesFin">
<Type>Patientrecord.DclTPHypnotiquesFin.Record</Type>
</Property>

<Property name="DclTPNootropesFin">
<Type>Patientrecord.DclTPNootropesFin.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiquesFin">
<Type>Patientrecord.DclTPAntiEpileptiquesFin.Record</Type>
</Property>

<Property name="DclTPThymoRegulateursFin">
<Type>Patientrecord.DclTPThymoRegulateursFin.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniensFin">
<Type>Patientrecord.DclTPAntiParkinsoniensFin.Record</Type>
</Property>

<Property name="DclTPAutresFin">
<Type>Patientrecord.DclTPAutresFin.Record</Type>
</Property>

<Property name="DclTPAucunDansListeFin">
<Type>Patientrecord.DclTPAucunDansListeFin.Record</Type>
</Property>

<Property name="DclTPAucunDebutPar">
<Type>Patientrecord.DclTPAucunDebutPar.Record</Type>
</Property>

<Property name="DclTPInhibAcetylDebutPar">
<Type>Patientrecord.DclTPInhibAcetylDebutPar.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDADebutPar">
<Type>Patientrecord.DclTPAntagonisteNMDADebutPar.Record</Type>
</Property>

<Property name="DclTPAntidepresseursDebutPar">
<Type>Patientrecord.DclTPAntidepresseursDebutPar.Record</Type>
</Property>

<Property name="DclTPNeuroleptiquesDebutPar">
<Type>Patientrecord.DclTPNeuroleptiquesDebutPar.Record</Type>
</Property>

<Property name="DclTPAnxiolitiquesDebutPar">
<Type>Patientrecord.DclTPAnxiolitiquesDebutPar.Record</Type>
</Property>

<Property name="DclTPHypnotiquesDebutPar">
<Type>Patientrecord.DclTPHypnotiquesDebutPar.Record</Type>
</Property>

<Property name="DclTPNootropesDebutPar">
<Type>Patientrecord.DclTPNootropesDebutPar.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiquesDebutPar">
<Type>Patientrecord.DclTPAntiEpileptiquesDebutPar.Record</Type>
</Property>

<Property name="DclTPThymoRegulateursDebutPar">
<Type>Patientrecord.DclTPThymoRegulateursDebutPar.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniensDebutPar">
<Type>Patientrecord.DclTPAntiParkinsoniensDebutPar.Record</Type>
</Property>

<Property name="DclTPAutresDebutPar">
<Type>Patientrecord.DclTPAutresDebutPar.Record</Type>
</Property>

<Property name="DclTPAucunDansListeDebutPar">
<Type>Patientrecord.DclTPAucunDansListeDebutPar.Record</Type>
</Property>

<Property name="DclTPAucunFinPar">
<Type>Patientrecord.DclTPAucunFinPar.Record</Type>
</Property>

<Property name="DclTPInhibAcetylFinPar">
<Type>Patientrecord.DclTPInhibAcetylFinPar.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDAFinPar">
<Type>Patientrecord.DclTPAntagonisteNMDAFinPar.Record</Type>
</Property>

<Property name="DclTPAntidepresseursFinPar">
<Type>Patientrecord.DclTPAntidepresseursFinPar.Record</Type>
</Property>

<Property name="DclTPNeuroleptiquesFinPar">
<Type>Patientrecord.DclTPNeuroleptiquesFinPar.Record</Type>
</Property>

<Property name="DclTPAnxiolitiquesFinPar">
<Type>Patientrecord.DclTPAnxiolitiquesFinPar.Record</Type>
</Property>

<Property name="DclTPHypnotiquesFinPar">
<Type>Patientrecord.DclTPHypnotiquesFinPar.Record</Type>
</Property>

<Property name="DclTPNootropesFinPar">
<Type>Patientrecord.DclTPNootropesFinPar.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiquesFinPar">
<Type>Patientrecord.DclTPAntiEpileptiquesFinPar.Record</Type>
</Property>

<Property name="DclTPThymoRegulateursFinPar">
<Type>Patientrecord.DclTPThymoRegulateursFinPar.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniensFinPar">
<Type>Patientrecord.DclTPAntiParkinsoniensFinPar.Record</Type>
</Property>

<Property name="DclTPAutresFinPar">
<Type>Patientrecord.DclTPAutresFinPar.Record</Type>
</Property>

<Property name="DclTPAucunDansListeFinPar">
<Type>Patientrecord.DclTPAucunDansListeFinPar.Record</Type>
</Property>

<Property name="DclTPAucunAvantPEC">
<Type>Patientrecord.DclTPAucunAvantPEC.Record</Type>
</Property>

<Property name="DclTPInhibAcetylAvantPEC">
<Type>Patientrecord.DclTPInhibAcetylAvantPEC.Record</Type>
</Property>

<Property name="DclTPAntagonisteNMDAAvantPEC">
<Type>Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record</Type>
</Property>

<Property name="DclTPAntidepresseursAvantPEC">
<Type>Patientrecord.DclTPAntidepresseursAvantPEC.Record</Type>
</Property>

<Property name="DclTPNeuroleptiquesAvantPEC">
<Type>Patientrecord.DclTPNeuroleptiquesAvantPEC.Record</Type>
</Property>

<Property name="DclTPAnxiolitiquesAvantPEC">
<Type>Patientrecord.DclTPAnxiolitiquesAvantPEC.Record</Type>
</Property>

<Property name="DclTPHypnotiquesAvantPEC">
<Type>Patientrecord.DclTPHypnotiquesAvantPEC.Record</Type>
</Property>

<Property name="DclTPNootropesAvantPEC">
<Type>Patientrecord.DclTPNootropesAvantPEC.Record</Type>
</Property>

<Property name="DclTPAntiEpileptiquesAvantPEC">
<Type>Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record</Type>
</Property>

<Property name="DclTPThymoRegulateursAvantPEC">
<Type>Patientrecord.DclTPThymoRegulateursAvantPEC.Record</Type>
</Property>

<Property name="DclTPAntiParkinsoniensAvantPEC">
<Type>Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record</Type>
</Property>

<Property name="DclTPAutresAvantPEC">
<Type>Patientrecord.DclTPAutresAvantPEC.Record</Type>
</Property>

<Property name="DclTPAucunDansListeAvantPEC">
<Type>Patientrecord.DclTPAucunDansListeAvantPEC.Record</Type>
</Property>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		Set tId = ..%Id()
		If ""=tId {
		}
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patien13CB.BatchD</DataLocation>
<DefaultData>BatchDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patien13CB.BatchD</IdLocation>
<IndexLocation>^Patientrecord.Patien13CB.BatchI</IndexLocation>
<StreamLocation>^Patientrecord.Patien13CB.BatchS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="BatchDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>CentreNom</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>CentreAdRue2</Value>
</Value>
<Value name="5">
<Value>CentreAdCp</Value>
</Value>
<Value name="6">
<Value>CentreAdVille</Value>
</Value>
<Value name="7">
<Value>CentreMail</Value>
</Value>
<Value name="8">
<Value>CentreType</Value>
</Value>
<Value name="9">
<Value>CentreNum</Value>
</Value>
<Value name="10">
<Value>CentreResponsable</Value>
</Value>
<Value name="11">
<Value>CentreLabel</Value>
</Value>
<Value name="12">
<Value>CentreLabelAnnee</Value>
</Value>
<Value name="13">
<Value>CentreReseau</Value>
</Value>
<Value name="14">
<Value>CentreNomReseau</Value>
</Value>
<Value name="15">
<Value>CentreInclusion</Value>
</Value>
<Value name="16">
<Value>CentreMultisite</Value>
</Value>
<Value name="17">
<Value>CentreHdj</Value>
</Value>
<Value name="18">
<Value>CentreOuvConsultation</Value>
</Value>
<Value name="19">
<Value>CentrePersoGeriatre</Value>
</Value>
<Value name="20">
<Value>CentrePersoNeurologue</Value>
</Value>
<Value name="21">
<Value>CentrePersoPsychiatre</Value>
</Value>
<Value name="22">
<Value>CentrePersoPsychologue</Value>
</Value>
<Value name="23">
<Value>CentrePersoOrthophoniste</Value>
</Value>
<Value name="24">
<Value>CentrePersoKine</Value>
</Value>
<Value name="25">
<Value>CentrePersoASocial</Value>
</Value>
<Value name="26">
<Value>CentrePersoSecretaire</Value>
</Value>
<Value name="27">
<Value>CentrePersoIDE</Value>
</Value>
<Value name="28">
<Value>CentrePersoARC</Value>
</Value>
<Value name="29">
<Value>CentrePersoTEC</Value>
</Value>
<Value name="30">
<Value>CentrePersoAutre</Value>
</Value>
<Value name="31">
<Value>CentrePersoDescriptionAutre</Value>
</Value>
<Value name="32">
<Value>CmrrPublications</Value>
</Value>
<Value name="33">
<Value>CmrrFormationsUniv</Value>
</Value>
<Value name="34">
<Value>enregistrement10</Value>
</Value>
<Value name="35">
<Value>CmrrActiviteAnimation</Value>
</Value>
<Value name="36">
<Value>CmrrActiviteRecherche</Value>
</Value>
<Value name="37">
<Value>CmrrActiviteEthique</Value>
</Value>
<Value name="38">
<Value>CmrrCmActiviteSoutien</Value>
</Value>
<Value name="39">
<Value>CmrrCmActiviteStimul</Value>
</Value>
<Value name="40">
<Value>ClTypeSpecialiste</Value>
</Value>
<Value name="41">
<Value>ClCollabNeuroPsy</Value>
</Value>
<Value name="42">
<Value>ClPratiqueETP</Value>
</Value>
<Value name="43">
<Value>ClActiviteConsultMemoire</Value>
</Value>
<Value name="44">
<Value>ClCollabCmCmrr</Value>
</Value>
<Value name="45">
<Value>ClActiviteReseau</Value>
</Value>
<Value name="46">
<Value>ClNbFormAn</Value>
</Value>
<Value name="47">
<Value>PatientId</Value>
</Value>
<Value name="48">
<Value>PatientSexe</Value>
</Value>
<Value name="49">
<Value>PatientAnneeNaissance</Value>
</Value>
<Value name="50">
<Value>PatientNiveauEtudes</Value>
</Value>
<Value name="51">
<Value>PatientSituationGeo</Value>
</Value>
<Value name="52">
<Value>atientEnvoyePar</Value>
</Value>
<Value name="53">
<Value>DclEtatDemence</Value>
</Value>
<Value name="54">
<Value>DclAnneePremierDiag</Value>
</Value>
<Value name="55">
<Value>DclDiagnostic</Value>
</Value>
<Value name="56">
<Value>DclTypeActe</Value>
</Value>
<Value name="57">
<Value>DclDateActe</Value>
</Value>
<Value name="58">
<Value>DclMMSE</Value>
</Value>
<Value name="59">
<Value>DclIADLDetection</Value>
</Value>
<Value name="60">
<Value>DclIADLConsequence</Value>
</Value>
<Value name="61">
<Value>DclModeDeVie</Value>
</Value>
<Value name="62">
<Value>DclAPA</Value>
</Value>
<Value name="63">
<Value>DclALD</Value>
</Value>
<Value name="64">
<Value>DclMesureProtection</Value>
</Value>
<Value name="65">
<Value>DclFinSuivi</Value>
</Value>
<Value name="66">
<Value>DclDateFinSuivi</Value>
</Value>
<Value name="67">
<Value>DclDateEntreeInstitution</Value>
</Value>
<Value name="68">
<Value>DclDateDeces</Value>
</Value>
<Value name="69">
<Value>DclTPAucun</Value>
</Value>
<Value name="70">
<Value>DclTPInhibAcetyl</Value>
</Value>
<Value name="71">
<Value>DclTPAntagonisteNMDA</Value>
</Value>
<Value name="72">
<Value>DclTPAntidepresseurs</Value>
</Value>
<Value name="73">
<Value>DclTPNeuroleptiques</Value>
</Value>
<Value name="74">
<Value>DclTPAnxiolitiques</Value>
</Value>
<Value name="75">
<Value>DclTPHypnotiques</Value>
</Value>
<Value name="76">
<Value>DclTPNootropes</Value>
</Value>
<Value name="77">
<Value>DclTPAutres</Value>
</Value>
<Value name="78">
<Value>DclTPAucunDansListe</Value>
</Value>
<Value name="79">
<Value>DclEffetIndesirable</Value>
</Value>
<Value name="80">
<Value>DclIPSRAucun</Value>
</Value>
<Value name="81">
<Value>DclIPSROrthophoniste</Value>
</Value>
<Value name="82">
<Value>DclIPSRPsychologue</Value>
</Value>
<Value name="83">
<Value>DclIPSRKinesitherapeute</Value>
</Value>
<Value name="84">
<Value>DclIPSRErgotherapeute</Value>
</Value>
<Value name="85">
<Value>DclIPSRGroupe</Value>
</Value>
<Value name="86">
<Value>DclIPSRAccueilJour</Value>
</Value>
<Value name="87">
<Value>DclIPSRMaia</Value>
</Value>
<Value name="88">
<Value>DclIPSRClic</Value>
</Value>
<Value name="89">
<Value>DclIPSRRepits</Value>
</Value>
<Value name="90">
<Value>DclIPSRSiad</Value>
</Value>
<Value name="91">
<Value>DclIPSRAutre</Value>
</Value>
<Value name="92">
<Value>DclPCAucun</Value>
</Value>
<Value name="93">
<Value>DclPCIRM</Value>
</Value>
<Value name="94">
<Value>DclPCScanner</Value>
</Value>
<Value name="95">
<Value>DclPCSPECT</Value>
</Value>
<Value name="96">
<Value>DclPCPET</Value>
</Value>
<Value name="97">
<Value>DclPCBioMarqueurs</Value>
</Value>
<Value name="98">
<Value>DclPR</Value>
</Value>
<Value name="99">
<Value>DclPRType</Value>
</Value>
<Value name="100">
<Value>DclPRVisite</Value>
</Value>
<Value name="101">
<Value>RetourMail</Value>
</Value>
<Value name="102">
<Value>PatientIdPrecedent</Value>
</Value>
<Value name="103">
<Value>Application</Value>
</Value>
<Value name="104">
<Value>CentreNumRmes</Value>
</Value>
<Value name="105">
<Value>CentreNumFiness</Value>
</Value>
<Value name="106">
<Value>CentreNumAdeli</Value>
</Value>
<Value name="107">
<Value>CentreNumRpps</Value>
</Value>
<Value name="108">
<Value>DclCmrrRecours</Value>
</Value>
<Value name="109">
<Value>DclCmrrRecoursDiagDiff</Value>
</Value>
<Value name="110">
<Value>DclCmrrRecoursSuivi</Value>
</Value>
<Value name="111">
<Value>DclCmrrRecoursPTech</Value>
</Value>
<Value name="112">
<Value>DclCmrrRecoursSpExpert</Value>
</Value>
<Value name="113">
<Value>PatientProfession</Value>
</Value>
<Value name="114">
<Value>PatientAccompagnant</Value>
</Value>
<Value name="115">
<Value>DclIPSREsad</Value>
</Value>
<Value name="116">
<Value>DclIPSRHdj</Value>
</Value>
<Value name="117">
<Value>DclIPSRUcc</Value>
</Value>
<Value name="118">
<Value>DclRechPresDispo</Value>
</Value>
<Value name="119">
<Value>DclRechAutonom</Value>
</Value>
<Value name="120">
<Value>DclRechContreIndic</Value>
</Value>
<Value name="121">
<Value>DclRechAcceptPlacebo</Value>
</Value>
<Value name="122">
<Value>DclDiagnosticN31</Value>
</Value>
<Value name="123">
<Value>DclDiagnosticN32</Value>
</Value>
<Value name="124">
<Value>DclDiagnosticN33</Value>
</Value>
<Value name="125">
<Value>DclPECAidant</Value>
</Value>
<Value name="126">
<Value>DclIPSRGardeMalade</Value>
</Value>
<Value name="127">
<Value>DclIPSRPAERPA</Value>
</Value>
<Value name="128">
<Value>DclTPAntiEpileptiques</Value>
</Value>
<Value name="129">
<Value>DclTPThymoRegulateurs</Value>
</Value>
<Value name="130">
<Value>DclTPAntiParkinsoniens</Value>
</Value>
<Value name="131">
<Value>DclTPAucunDebut</Value>
</Value>
<Value name="132">
<Value>DclTPInhibAcetylDebut</Value>
</Value>
<Value name="133">
<Value>DclTPAntagonisteNMDADebut</Value>
</Value>
<Value name="134">
<Value>DclTPAntidepresseursDebut</Value>
</Value>
<Value name="135">
<Value>DclTPNeuroleptiquesDebut</Value>
</Value>
<Value name="136">
<Value>DclTPAnxiolitiquesDebut</Value>
</Value>
<Value name="137">
<Value>DclTPHypnotiquesDebut</Value>
</Value>
<Value name="138">
<Value>DclTPNootropesDebut</Value>
</Value>
<Value name="139">
<Value>DclTPAntiEpileptiquesDebut</Value>
</Value>
<Value name="140">
<Value>DclTPThymoRegulateursDebut</Value>
</Value>
<Value name="141">
<Value>DclTPAntiParkinsoniensDebut</Value>
</Value>
<Value name="142">
<Value>DclTPAutresDebut</Value>
</Value>
<Value name="143">
<Value>DclTPAucunDansListeDebut</Value>
</Value>
<Value name="144">
<Value>DclTPAucunFin</Value>
</Value>
<Value name="145">
<Value>DclTPInhibAcetylFin</Value>
</Value>
<Value name="146">
<Value>DclTPAntagonisteNMDAFin</Value>
</Value>
<Value name="147">
<Value>DclTPAntidepresseursFin</Value>
</Value>
<Value name="148">
<Value>DclTPNeuroleptiquesFin</Value>
</Value>
<Value name="149">
<Value>DclTPAnxiolitiquesFin</Value>
</Value>
<Value name="150">
<Value>DclTPHypnotiquesFin</Value>
</Value>
<Value name="151">
<Value>DclTPNootropesFin</Value>
</Value>
<Value name="152">
<Value>DclTPAntiEpileptiquesFin</Value>
</Value>
<Value name="153">
<Value>DclTPThymoRegulateursFin</Value>
</Value>
<Value name="154">
<Value>DclTPAntiParkinsoniensFin</Value>
</Value>
<Value name="155">
<Value>DclTPAutresFin</Value>
</Value>
<Value name="156">
<Value>DclTPAucunDansListeFin</Value>
</Value>
<Value name="157">
<Value>DclTPAucunDebutPar</Value>
</Value>
<Value name="158">
<Value>DclTPInhibAcetylDebutPar</Value>
</Value>
<Value name="159">
<Value>DclTPAntagonisteNMDADebutPar</Value>
</Value>
<Value name="160">
<Value>DclTPAntidepresseursDebutPar</Value>
</Value>
<Value name="161">
<Value>DclTPNeuroleptiquesDebutPar</Value>
</Value>
<Value name="162">
<Value>DclTPAnxiolitiquesDebutPar</Value>
</Value>
<Value name="163">
<Value>DclTPHypnotiquesDebutPar</Value>
</Value>
<Value name="164">
<Value>DclTPNootropesDebutPar</Value>
</Value>
<Value name="165">
<Value>DclTPAntiEpileptiquesDebutPar</Value>
</Value>
<Value name="166">
<Value>DclTPThymoRegulateursDebutPar</Value>
</Value>
<Value name="167">
<Value>DclTPAntiParkinsoniensDebutPar</Value>
</Value>
<Value name="168">
<Value>DclTPAutresDebutPar</Value>
</Value>
<Value name="169">
<Value>DclTPAucunDansListeDebutPar</Value>
</Value>
<Value name="170">
<Value>DclTPAucunFinPar</Value>
</Value>
<Value name="171">
<Value>DclTPInhibAcetylFinPar</Value>
</Value>
<Value name="172">
<Value>DclTPAntagonisteNMDAFinPar</Value>
</Value>
<Value name="173">
<Value>DclTPAntidepresseursFinPar</Value>
</Value>
<Value name="174">
<Value>DclTPNeuroleptiquesFinPar</Value>
</Value>
<Value name="175">
<Value>DclTPAnxiolitiquesFinPar</Value>
</Value>
<Value name="176">
<Value>DclTPHypnotiquesFinPar</Value>
</Value>
<Value name="177">
<Value>DclTPNootropesFinPar</Value>
</Value>
<Value name="178">
<Value>DclTPAntiEpileptiquesFinPar</Value>
</Value>
<Value name="179">
<Value>DclTPThymoRegulateursFinPar</Value>
</Value>
<Value name="180">
<Value>DclTPAntiParkinsoniensFinPar</Value>
</Value>
<Value name="181">
<Value>DclTPAutresFinPar</Value>
</Value>
<Value name="182">
<Value>DclTPAucunDansListeFinPar</Value>
</Value>
<Value name="183">
<Value>DclTPAucunAvantPEC</Value>
</Value>
<Value name="184">
<Value>DclTPInhibAcetylAvantPEC</Value>
</Value>
<Value name="185">
<Value>DclTPAntagonisteNMDAAvantPEC</Value>
</Value>
<Value name="186">
<Value>DclTPAntidepresseursAvantPEC</Value>
</Value>
<Value name="187">
<Value>DclTPNeuroleptiquesAvantPEC</Value>
</Value>
<Value name="188">
<Value>DclTPAnxiolitiquesAvantPEC</Value>
</Value>
<Value name="189">
<Value>DclTPHypnotiquesAvantPEC</Value>
</Value>
<Value name="190">
<Value>DclTPNootropesAvantPEC</Value>
</Value>
<Value name="191">
<Value>DclTPAntiEpileptiquesAvantPEC</Value>
</Value>
<Value name="192">
<Value>DclTPThymoRegulateursAvantPEC</Value>
</Value>
<Value name="193">
<Value>DclTPAntiParkinsoniensAvantPEC</Value>
</Value>
<Value name="194">
<Value>DclTPAutresAvantPEC</Value>
</Value>
<Value name="195">
<Value>DclTPAucunDansListeAvantPEC</Value>
</Value>
<Value name="196">
<Value>CentreAdRue1</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientComplexeRecord">
<Description>
</Description>
<Super>EnsLib.RecordMap.ComplexMap</Super>
<TimeChanged>66541,49675.802954672</TimeChanged>
<TimeCreated>66477,48004.691290994</TimeCreated>

<Parameter name="BATCHCLASS">
<Default>Patientrecord.PatientComplexeRecord.Batch</Default>
</Parameter>

<Method name="PutBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pIOStream:%IO.DeviceStream,pBatch:EnsLib.RecordMap.ComplexBatch</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject($get(pBatch)) Set tStatus = $$$ERROR($$$ObjectInstanceRequired) Quit
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,"WAE",,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNom) {
			Set tStatus = ##class(Patientrecord.CentreNom).PutObject(pIOStream,pBatch.CentreNom,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreAdRue1) {
			Set tStatus = ##class(Patientrecord.CentreAdRue1).PutObject(pIOStream,pBatch.CentreAdRue1,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreAdRue2) {
			Set tStatus = ##class(Patientrecord.CentreAdRue2).PutObject(pIOStream,pBatch.CentreAdRue2,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreAdCp) {
			Set tStatus = ##class(Patientrecord.CentreAdCp).PutObject(pIOStream,pBatch.CentreAdCp,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreAdVille) {
			Set tStatus = ##class(Patientrecord.CentreAdVille).PutObject(pIOStream,pBatch.CentreAdVille,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreMail) {
			Set tStatus = ##class(Patientrecord.CentreMail).PutObject(pIOStream,pBatch.CentreMail,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreType) {
			Set tStatus = ##class(Patientrecord.CentreType).PutObject(pIOStream,pBatch.CentreType,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNum) {
			Set tStatus = ##class(Patientrecord.CentreNum).PutObject(pIOStream,pBatch.CentreNum,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreResponsable) {
			Set tStatus = ##class(Patientrecord.CentreResponsable).PutObject(pIOStream,pBatch.CentreResponsable,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreLabel) {
			Set tStatus = ##class(Patientrecord.CentreLabel).PutObject(pIOStream,pBatch.CentreLabel,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreLabelAnnee) {
			Set tStatus = ##class(Patientrecord.CentreLabelAnnee).PutObject(pIOStream,pBatch.CentreLabelAnnee,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreReseau) {
			Set tStatus = ##class(Patientrecord.CentreReseau).PutObject(pIOStream,pBatch.CentreReseau,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNomReseau) {
			Set tStatus = ##class(Patientrecord.CentreNomReseau).PutObject(pIOStream,pBatch.CentreNomReseau,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreInclusion) {
			Set tStatus = ##class(Patientrecord.CentreInclusion).PutObject(pIOStream,pBatch.CentreInclusion,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreMultisite) {
			Set tStatus = ##class(Patientrecord.CentreMultisite).PutObject(pIOStream,pBatch.CentreMultisite,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreHdj) {
			Set tStatus = ##class(Patientrecord.CentreHdj).PutObject(pIOStream,pBatch.CentreHdj,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreOuvConsultation) {
			Set tStatus = ##class(Patientrecord.CentreOuvConsultation).PutObject(pIOStream,pBatch.CentreOuvConsultation,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoGeriatre) {
			Set tStatus = ##class(Patientrecord.CentrePersoGeriatre).PutObject(pIOStream,pBatch.CentrePersoGeriatre,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoNeurologue) {
			Set tStatus = ##class(Patientrecord.CentrePersoNeurologue).PutObject(pIOStream,pBatch.CentrePersoNeurologue,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoPsychiatre) {
			Set tStatus = ##class(Patientrecord.CentrePersoPsychiatre).PutObject(pIOStream,pBatch.CentrePersoPsychiatre,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoPsychologue) {
			Set tStatus = ##class(Patientrecord.CentrePersoPsychologue).PutObject(pIOStream,pBatch.CentrePersoPsychologue,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoOrthophoniste) {
			Set tStatus = ##class(Patientrecord.CentrePersoOrthophoniste).PutObject(pIOStream,pBatch.CentrePersoOrthophoniste,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoKine) {
			Set tStatus = ##class(Patientrecord.CentrePersoKine).PutObject(pIOStream,pBatch.CentrePersoKine,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoASocial) {
			Set tStatus = ##class(Patientrecord.CentrePersoASocial).PutObject(pIOStream,pBatch.CentrePersoASocial,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoSecretaire) {
			Set tStatus = ##class(Patientrecord.CentrePersoSecretaire).PutObject(pIOStream,pBatch.CentrePersoSecretaire,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoIDE) {
			Set tStatus = ##class(Patientrecord.CentrePersoIDE).PutObject(pIOStream,pBatch.CentrePersoIDE,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoARC) {
			Set tStatus = ##class(Patientrecord.CentrePersoARC).PutObject(pIOStream,pBatch.CentrePersoARC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoTEC) {
			Set tStatus = ##class(Patientrecord.CentrePersoTEC).PutObject(pIOStream,pBatch.CentrePersoTEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoAutre) {
			Set tStatus = ##class(Patientrecord.CentrePersoAutre).PutObject(pIOStream,pBatch.CentrePersoAutre,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentrePersoDescriptionAutre) {
			Set tStatus = ##class(Patientrecord.CentrePersoDescriptionAutre).PutObject(pIOStream,pBatch.CentrePersoDescriptionAutre,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrPublications) {
			Set tStatus = ##class(Patientrecord.CmrrPublications).PutObject(pIOStream,pBatch.CmrrPublications,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrFormationsUniv) {
			Set tStatus = ##class(Patientrecord.CmrrFormationsUniv).PutObject(pIOStream,pBatch.CmrrFormationsUniv,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.enregistrement10) {
			Set tStatus = ##class(Patientrecord.CmrrActiviteFormation).PutObject(pIOStream,pBatch.enregistrement10,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrActiviteAnimation) {
			Set tStatus = ##class(Patientrecord.CmrrActiviteAnimation).PutObject(pIOStream,pBatch.CmrrActiviteAnimation,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrActiviteRecherche) {
			Set tStatus = ##class(Patientrecord.CmrrActiviteRecherche).PutObject(pIOStream,pBatch.CmrrActiviteRecherche,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrActiviteEthique) {
			Set tStatus = ##class(Patientrecord.CmrrActiviteEthique).PutObject(pIOStream,pBatch.CmrrActiviteEthique,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrCmActiviteSoutien) {
			Set tStatus = ##class(Patientrecord.CmrrCmActiviteSoutien).PutObject(pIOStream,pBatch.CmrrCmActiviteSoutien,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CmrrCmActiviteStimul) {
			Set tStatus = ##class(Patientrecord.CmrrCmActiviteStimul).PutObject(pIOStream,pBatch.CmrrCmActiviteStimul,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClTypeSpecialiste) {
			Set tStatus = ##class(Patientrecord.ClTypeSpecialiste).PutObject(pIOStream,pBatch.ClTypeSpecialiste,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClCollabNeuroPsy) {
			Set tStatus = ##class(Patientrecord.ClCollabNeuroPsy).PutObject(pIOStream,pBatch.ClCollabNeuroPsy,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClPratiqueETP) {
			Set tStatus = ##class(Patientrecord.ClPratiqueETP).PutObject(pIOStream,pBatch.ClPratiqueETP,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClActiviteConsultMemoire) {
			Set tStatus = ##class(Patientrecord.ClActiviteConsultMemoire).PutObject(pIOStream,pBatch.ClActiviteConsultMemoire,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClCollabCmCmrr) {
			Set tStatus = ##class(Patientrecord.ClCollabCmCmrr).PutObject(pIOStream,pBatch.ClCollabCmCmrr,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClActiviteReseau) {
			Set tStatus = ##class(Patientrecord.ClActiviteReseau).PutObject(pIOStream,pBatch.ClActiviteReseau,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.ClNbFormAn) {
			Set tStatus = ##class(Patientrecord.ClNbFormAn).PutObject(pIOStream,pBatch.ClNbFormAn,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientId) {
			Set tStatus = ##class(Patientrecord.PatientId).PutObject(pIOStream,pBatch.PatientId,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientSexe) {
			Set tStatus = ##class(Patientrecord.PatientSexe).PutObject(pIOStream,pBatch.PatientSexe,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientAnneeNaissance) {
			Set tStatus = ##class(Patientrecord.PatientAnneeNaissance).PutObject(pIOStream,pBatch.PatientAnneeNaissance,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientNiveauEtudes) {
			Set tStatus = ##class(Patientrecord.PatientNiveauEtudes).PutObject(pIOStream,pBatch.PatientNiveauEtudes,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientSituationGeo) {
			Set tStatus = ##class(Patientrecord.PatientSituationGeo).PutObject(pIOStream,pBatch.PatientSituationGeo,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.atientEnvoyePar) {
			Set tStatus = ##class(Patientrecord.PatientEnvoyePar).PutObject(pIOStream,pBatch.atientEnvoyePar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclEtatDemence) {
			Set tStatus = ##class(Patientrecord.DclEtatDemence).PutObject(pIOStream,pBatch.DclEtatDemence,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclAnneePremierDiag) {
			Set tStatus = ##class(Patientrecord.DclAnneePremierDiag).PutObject(pIOStream,pBatch.DclAnneePremierDiag,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDiagnostic) {
			Set tStatus = ##class(Patientrecord.DclDiagnostic).PutObject(pIOStream,pBatch.DclDiagnostic,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTypeActe) {
			Set tStatus = ##class(Patientrecord.DclTypeActe).PutObject(pIOStream,pBatch.DclTypeActe,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDateActe) {
			Set tStatus = ##class(Patientrecord.DclDateActe).PutObject(pIOStream,pBatch.DclDateActe,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclMMSE) {
			Set tStatus = ##class(Patientrecord.DclMMSE).PutObject(pIOStream,pBatch.DclMMSE,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIADLDetection) {
			Set tStatus = ##class(Patientrecord.DclIADLDetection).PutObject(pIOStream,pBatch.DclIADLDetection,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIADLConsequence) {
			Set tStatus = ##class(Patientrecord.DclIADLConsequence).PutObject(pIOStream,pBatch.DclIADLConsequence,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclModeDeVie) {
			Set tStatus = ##class(Patientrecord.DclModeDeVie).PutObject(pIOStream,pBatch.DclModeDeVie,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclAPA) {
			Set tStatus = ##class(Patientrecord.DclAPA).PutObject(pIOStream,pBatch.DclAPA,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclALD) {
			Set tStatus = ##class(Patientrecord.DclALD).PutObject(pIOStream,pBatch.DclALD,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclMesureProtection) {
			Set tStatus = ##class(Patientrecord.DclMesureProtection).PutObject(pIOStream,pBatch.DclMesureProtection,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclFinSuivi) {
			Set tStatus = ##class(Patientrecord.DclFinSuivi).PutObject(pIOStream,pBatch.DclFinSuivi,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDateFinSuivi) {
			Set tStatus = ##class(Patientrecord.DclDateFinSuivi).PutObject(pIOStream,pBatch.DclDateFinSuivi,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDateEntreeInstitution) {
			Set tStatus = ##class(Patientrecord.DclDateEntreeInstitution).PutObject(pIOStream,pBatch.DclDateEntreeInstitution,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDateDeces) {
			Set tStatus = ##class(Patientrecord.DclDateDeces).PutObject(pIOStream,pBatch.DclDateDeces,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucun) {
			Set tStatus = ##class(Patientrecord.DclTPAucun).PutObject(pIOStream,pBatch.DclTPAucun,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetyl) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetyl).PutObject(pIOStream,pBatch.DclTPInhibAcetyl,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDA) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDA).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDA,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseurs) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseurs).PutObject(pIOStream,pBatch.DclTPAntidepresseurs,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiques) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiques).PutObject(pIOStream,pBatch.DclTPNeuroleptiques,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiques) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiques).PutObject(pIOStream,pBatch.DclTPAnxiolitiques,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiques) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiques).PutObject(pIOStream,pBatch.DclTPHypnotiques,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropes) {
			Set tStatus = ##class(Patientrecord.DclTPNootropes).PutObject(pIOStream,pBatch.DclTPNootropes,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutres) {
			Set tStatus = ##class(Patientrecord.DclTPAutres).PutObject(pIOStream,pBatch.DclTPAutres,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListe) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListe).PutObject(pIOStream,pBatch.DclTPAucunDansListe,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclEffetIndesirable) {
			Set tStatus = ##class(Patientrecord.DclEffetIndesirable).PutObject(pIOStream,pBatch.DclEffetIndesirable,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRAucun) {
			Set tStatus = ##class(Patientrecord.DclIPSRAucun).PutObject(pIOStream,pBatch.DclIPSRAucun,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSROrthophoniste) {
			Set tStatus = ##class(Patientrecord.DclIPSROrthophoniste).PutObject(pIOStream,pBatch.DclIPSROrthophoniste,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRPsychologue) {
			Set tStatus = ##class(Patientrecord.DclIPSRPsychologue).PutObject(pIOStream,pBatch.DclIPSRPsychologue,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRKinesitherapeute) {
			Set tStatus = ##class(Patientrecord.DclIPSRKinesitherapeute).PutObject(pIOStream,pBatch.DclIPSRKinesitherapeute,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRErgotherapeute) {
			Set tStatus = ##class(Patientrecord.DclIPSRErgotherapeute).PutObject(pIOStream,pBatch.DclIPSRErgotherapeute,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRGroupe) {
			Set tStatus = ##class(Patientrecord.DclIPSRGroupe).PutObject(pIOStream,pBatch.DclIPSRGroupe,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRAccueilJour) {
			Set tStatus = ##class(Patientrecord.DclIPSRAccueilJour).PutObject(pIOStream,pBatch.DclIPSRAccueilJour,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRMaia) {
			Set tStatus = ##class(Patientrecord.DclIPSRMaia).PutObject(pIOStream,pBatch.DclIPSRMaia,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRClic) {
			Set tStatus = ##class(Patientrecord.DclIPSRClic).PutObject(pIOStream,pBatch.DclIPSRClic,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRRepits) {
			Set tStatus = ##class(Patientrecord.DclIPSRRepits).PutObject(pIOStream,pBatch.DclIPSRRepits,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRSiad) {
			Set tStatus = ##class(Patientrecord.DclIPSRSiad).PutObject(pIOStream,pBatch.DclIPSRSiad,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRAutre) {
			Set tStatus = ##class(Patientrecord.DclIPSRAutre).PutObject(pIOStream,pBatch.DclIPSRAutre,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCAucun) {
			Set tStatus = ##class(Patientrecord.DclPCAucun).PutObject(pIOStream,pBatch.DclPCAucun,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCIRM) {
			Set tStatus = ##class(Patientrecord.DclPCIRM).PutObject(pIOStream,pBatch.DclPCIRM,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCScanner) {
			Set tStatus = ##class(Patientrecord.DclPCScanner).PutObject(pIOStream,pBatch.DclPCScanner,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCSPECT) {
			Set tStatus = ##class(Patientrecord.DclPCSPECT).PutObject(pIOStream,pBatch.DclPCSPECT,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCPET) {
			Set tStatus = ##class(Patientrecord.DclPCPET).PutObject(pIOStream,pBatch.DclPCPET,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPCBioMarqueurs) {
			Set tStatus = ##class(Patientrecord.DclPCBioMarqueurs).PutObject(pIOStream,pBatch.DclPCBioMarqueurs,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPR) {
			Set tStatus = ##class(Patientrecord.DclPR).PutObject(pIOStream,pBatch.DclPR,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPRType) {
			Set tStatus = ##class(Patientrecord.DclPRType).PutObject(pIOStream,pBatch.DclPRType,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPRVisite) {
			Set tStatus = ##class(Patientrecord.DclPRVisite).PutObject(pIOStream,pBatch.DclPRVisite,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.RetourMail) {
			Set tStatus = ##class(Patientrecord.RetourMail).PutObject(pIOStream,pBatch.RetourMail,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientIdPrecedent) {
			Set tStatus = ##class(Patientrecord.PatientIdPrecedent).PutObject(pIOStream,pBatch.PatientIdPrecedent,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.Application) {
			Set tStatus = ##class(Patientrecord.Application).PutObject(pIOStream,pBatch.Application,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNumRmes) {
			Set tStatus = ##class(Patientrecord.CentreNumRmes).PutObject(pIOStream,pBatch.CentreNumRmes,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNumFiness) {
			Set tStatus = ##class(Patientrecord.CentreNumFiness).PutObject(pIOStream,pBatch.CentreNumFiness,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNumAdeli) {
			Set tStatus = ##class(Patientrecord.CentreNumAdeli).PutObject(pIOStream,pBatch.CentreNumAdeli,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.CentreNumRpps) {
			Set tStatus = ##class(Patientrecord.CentreNumRpps).PutObject(pIOStream,pBatch.CentreNumRpps,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclCmrrRecours) {
			Set tStatus = ##class(Patientrecord.DclCmrrRecours).PutObject(pIOStream,pBatch.DclCmrrRecours,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclCmrrRecoursDiagDiff) {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursDiagDiff).PutObject(pIOStream,pBatch.DclCmrrRecoursDiagDiff,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclCmrrRecoursSuivi) {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursSuivi).PutObject(pIOStream,pBatch.DclCmrrRecoursSuivi,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclCmrrRecoursPTech) {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursPTech).PutObject(pIOStream,pBatch.DclCmrrRecoursPTech,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclCmrrRecoursSpExpert) {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursSpExpert).PutObject(pIOStream,pBatch.DclCmrrRecoursSpExpert,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientProfession) {
			Set tStatus = ##class(Patientrecord.PatientProfession).PutObject(pIOStream,pBatch.PatientProfession,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.PatientAccompagnant) {
			Set tStatus = ##class(Patientrecord.PatientAccompagnant).PutObject(pIOStream,pBatch.PatientAccompagnant,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSREsad) {
			Set tStatus = ##class(Patientrecord.DclIPSREsad).PutObject(pIOStream,pBatch.DclIPSREsad,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRHdj) {
			Set tStatus = ##class(Patientrecord.DclIPSRHdj).PutObject(pIOStream,pBatch.DclIPSRHdj,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRUcc) {
			Set tStatus = ##class(Patientrecord.DclIPSRUcc).PutObject(pIOStream,pBatch.DclIPSRUcc,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclRechPresDispo) {
			Set tStatus = ##class(Patientrecord.DclRechPresDispo).PutObject(pIOStream,pBatch.DclRechPresDispo,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclRechAutonom) {
			Set tStatus = ##class(Patientrecord.DclRechAutonom).PutObject(pIOStream,pBatch.DclRechAutonom,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclRechContreIndic) {
			Set tStatus = ##class(Patientrecord.DclRechContreIndic).PutObject(pIOStream,pBatch.DclRechContreIndic,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclRechAcceptPlacebo) {
			Set tStatus = ##class(Patientrecord.DclRechAcceptPlacebo).PutObject(pIOStream,pBatch.DclRechAcceptPlacebo,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDiagnosticN31) {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN31).PutObject(pIOStream,pBatch.DclDiagnosticN31,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDiagnosticN32) {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN32).PutObject(pIOStream,pBatch.DclDiagnosticN32,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclDiagnosticN33) {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN33).PutObject(pIOStream,pBatch.DclDiagnosticN33,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclPECAidant) {
			Set tStatus = ##class(Patientrecord.DclPECAidant).PutObject(pIOStream,pBatch.DclPECAidant,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRGardeMalade) {
			Set tStatus = ##class(Patientrecord.DclIPSRGardeMalade).PutObject(pIOStream,pBatch.DclIPSRGardeMalade,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclIPSRPAERPA) {
			Set tStatus = ##class(Patientrecord.DclIPSRPAERPA).PutObject(pIOStream,pBatch.DclIPSRPAERPA,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiques) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiques).PutObject(pIOStream,pBatch.DclTPAntiEpileptiques,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateurs) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateurs).PutObject(pIOStream,pBatch.DclTPThymoRegulateurs,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniens) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniens).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniens,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDebut).PutObject(pIOStream,pBatch.DclTPAucunDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetylDebut) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylDebut).PutObject(pIOStream,pBatch.DclTPInhibAcetylDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDADebut) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDADebut).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDADebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseursDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursDebut).PutObject(pIOStream,pBatch.DclTPAntidepresseursDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiquesDebut) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesDebut).PutObject(pIOStream,pBatch.DclTPNeuroleptiquesDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiquesDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesDebut).PutObject(pIOStream,pBatch.DclTPAnxiolitiquesDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiquesDebut) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesDebut).PutObject(pIOStream,pBatch.DclTPHypnotiquesDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropesDebut) {
			Set tStatus = ##class(Patientrecord.DclTPNootropesDebut).PutObject(pIOStream,pBatch.DclTPNootropesDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiquesDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesDebut).PutObject(pIOStream,pBatch.DclTPAntiEpileptiquesDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateursDebut) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursDebut).PutObject(pIOStream,pBatch.DclTPThymoRegulateursDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniensDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensDebut).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniensDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutresDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAutresDebut).PutObject(pIOStream,pBatch.DclTPAutresDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListeDebut) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeDebut).PutObject(pIOStream,pBatch.DclTPAucunDansListeDebut,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunFin) {
			Set tStatus = ##class(Patientrecord.DclTPAucunFin).PutObject(pIOStream,pBatch.DclTPAucunFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetylFin) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylFin).PutObject(pIOStream,pBatch.DclTPInhibAcetylFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDAFin) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAFin).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDAFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseursFin) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursFin).PutObject(pIOStream,pBatch.DclTPAntidepresseursFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiquesFin) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesFin).PutObject(pIOStream,pBatch.DclTPNeuroleptiquesFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiquesFin) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesFin).PutObject(pIOStream,pBatch.DclTPAnxiolitiquesFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiquesFin) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesFin).PutObject(pIOStream,pBatch.DclTPHypnotiquesFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropesFin) {
			Set tStatus = ##class(Patientrecord.DclTPNootropesFin).PutObject(pIOStream,pBatch.DclTPNootropesFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiquesFin) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesFin).PutObject(pIOStream,pBatch.DclTPAntiEpileptiquesFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateursFin) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursFin).PutObject(pIOStream,pBatch.DclTPThymoRegulateursFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniensFin) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensFin).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniensFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutresFin) {
			Set tStatus = ##class(Patientrecord.DclTPAutresFin).PutObject(pIOStream,pBatch.DclTPAutresFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListeFin) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeFin).PutObject(pIOStream,pBatch.DclTPAucunDansListeFin,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDebutPar).PutObject(pIOStream,pBatch.DclTPAucunDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetylDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylDebutPar).PutObject(pIOStream,pBatch.DclTPInhibAcetylDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDADebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDADebutPar).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDADebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseursDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursDebutPar).PutObject(pIOStream,pBatch.DclTPAntidepresseursDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiquesDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesDebutPar).PutObject(pIOStream,pBatch.DclTPNeuroleptiquesDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiquesDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesDebutPar).PutObject(pIOStream,pBatch.DclTPAnxiolitiquesDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiquesDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesDebutPar).PutObject(pIOStream,pBatch.DclTPHypnotiquesDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropesDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPNootropesDebutPar).PutObject(pIOStream,pBatch.DclTPNootropesDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiquesDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesDebutPar).PutObject(pIOStream,pBatch.DclTPAntiEpileptiquesDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateursDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursDebutPar).PutObject(pIOStream,pBatch.DclTPThymoRegulateursDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniensDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensDebutPar).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniensDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutresDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAutresDebutPar).PutObject(pIOStream,pBatch.DclTPAutresDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListeDebutPar) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeDebutPar).PutObject(pIOStream,pBatch.DclTPAucunDansListeDebutPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAucunFinPar).PutObject(pIOStream,pBatch.DclTPAucunFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetylFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylFinPar).PutObject(pIOStream,pBatch.DclTPInhibAcetylFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDAFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAFinPar).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDAFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseursFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursFinPar).PutObject(pIOStream,pBatch.DclTPAntidepresseursFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiquesFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesFinPar).PutObject(pIOStream,pBatch.DclTPNeuroleptiquesFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiquesFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesFinPar).PutObject(pIOStream,pBatch.DclTPAnxiolitiquesFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiquesFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesFinPar).PutObject(pIOStream,pBatch.DclTPHypnotiquesFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropesFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPNootropesFinPar).PutObject(pIOStream,pBatch.DclTPNootropesFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiquesFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesFinPar).PutObject(pIOStream,pBatch.DclTPAntiEpileptiquesFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateursFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursFinPar).PutObject(pIOStream,pBatch.DclTPThymoRegulateursFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniensFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensFinPar).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniensFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutresFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAutresFinPar).PutObject(pIOStream,pBatch.DclTPAutresFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListeFinPar) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeFinPar).PutObject(pIOStream,pBatch.DclTPAucunDansListeFinPar,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAucunAvantPEC).PutObject(pIOStream,pBatch.DclTPAucunAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPInhibAcetylAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylAvantPEC).PutObject(pIOStream,pBatch.DclTPInhibAcetylAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntagonisteNMDAAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAAvantPEC).PutObject(pIOStream,pBatch.DclTPAntagonisteNMDAAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntidepresseursAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursAvantPEC).PutObject(pIOStream,pBatch.DclTPAntidepresseursAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNeuroleptiquesAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesAvantPEC).PutObject(pIOStream,pBatch.DclTPNeuroleptiquesAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAnxiolitiquesAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesAvantPEC).PutObject(pIOStream,pBatch.DclTPAnxiolitiquesAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPHypnotiquesAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesAvantPEC).PutObject(pIOStream,pBatch.DclTPHypnotiquesAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPNootropesAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPNootropesAvantPEC).PutObject(pIOStream,pBatch.DclTPNootropesAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiEpileptiquesAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesAvantPEC).PutObject(pIOStream,pBatch.DclTPAntiEpileptiquesAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPThymoRegulateursAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursAvantPEC).PutObject(pIOStream,pBatch.DclTPThymoRegulateursAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAntiParkinsoniensAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensAvantPEC).PutObject(pIOStream,pBatch.DclTPAntiParkinsoniensAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAutresAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAutresAvantPEC).PutObject(pIOStream,pBatch.DclTPAutresAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		If $IsObject(pBatch.DclTPAucunDansListeAvantPEC) {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeAvantPEC).PutObject(pIOStream,pBatch.DclTPAucunDansListeAvantPEC,0)
			If $$$ISERR(tStatus) Quit
		}
		Do pIOStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	} Catch ex {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetBatch">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIOStream:%IO.DeviceStream,pTimeout:%Numeric=-1,*pBatch:EnsLib.RecordMap.ComplexBatch,&pLookAhead:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Try {
		If '$IsObject(pIOStream) {
			Set tFilename = pIOStream
			Set pIOStream = ##class(%IO.FileStream).%New()
			Do pIOStream.Open(tFilename,,pTimeout,"UTF-8",.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set pIOStream.CharEncoding = "UTF-8"
		Set pBatch = ##class(Patientrecord.PatientComplexeRecord.Batch).%New()
		Set pBatch.%Source = pIOStream.Name
		Set pLookAhead = $get(pLookAhead)
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "001-") {
			Set tStatus = ##class(Patientrecord.CentreNom).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNom","Patientrecord.CentreNom",$classname()),tStatus) Quit
			Set pBatch.CentreNom = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "002-") {
			Set tStatus = ##class(Patientrecord.CentreAdRue1).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreAdRue1","Patientrecord.CentreAdRue1",$classname()),tStatus) Quit
			Set pBatch.CentreAdRue1 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "003-") {
			Set tStatus = ##class(Patientrecord.CentreAdRue2).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreAdRue2","Patientrecord.CentreAdRue2",$classname()),tStatus) Quit
			Set pBatch.CentreAdRue2 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "004-") {
			Set tStatus = ##class(Patientrecord.CentreAdCp).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreAdCp","Patientrecord.CentreAdCp",$classname()),tStatus) Quit
			Set pBatch.CentreAdCp = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "005-") {
			Set tStatus = ##class(Patientrecord.CentreAdVille).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreAdVille","Patientrecord.CentreAdVille",$classname()),tStatus) Quit
			Set pBatch.CentreAdVille = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "006-") {
			Set tStatus = ##class(Patientrecord.CentreMail).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreMail","Patientrecord.CentreMail",$classname()),tStatus) Quit
			Set pBatch.CentreMail = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "007-") {
			Set tStatus = ##class(Patientrecord.CentreType).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreType","Patientrecord.CentreType",$classname()),tStatus) Quit
			Set pBatch.CentreType = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "008-") {
			Set tStatus = ##class(Patientrecord.CentreNum).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNum","Patientrecord.CentreNum",$classname()),tStatus) Quit
			Set pBatch.CentreNum = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "009-") {
			Set tStatus = ##class(Patientrecord.CentreResponsable).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreResponsable","Patientrecord.CentreResponsable",$classname()),tStatus) Quit
			Set pBatch.CentreResponsable = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "010-") {
			Set tStatus = ##class(Patientrecord.CentreLabel).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreLabel","Patientrecord.CentreLabel",$classname()),tStatus) Quit
			Set pBatch.CentreLabel = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "011-") {
			Set tStatus = ##class(Patientrecord.CentreLabelAnnee).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreLabelAnnee","Patientrecord.CentreLabelAnnee",$classname()),tStatus) Quit
			Set pBatch.CentreLabelAnnee = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "012-") {
			Set tStatus = ##class(Patientrecord.CentreReseau).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreReseau","Patientrecord.CentreReseau",$classname()),tStatus) Quit
			Set pBatch.CentreReseau = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "013-") {
			Set tStatus = ##class(Patientrecord.CentreNomReseau).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNomReseau","Patientrecord.CentreNomReseau",$classname()),tStatus) Quit
			Set pBatch.CentreNomReseau = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "014-") {
			Set tStatus = ##class(Patientrecord.CentreInclusion).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreInclusion","Patientrecord.CentreInclusion",$classname()),tStatus) Quit
			Set pBatch.CentreInclusion = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "015-") {
			Set tStatus = ##class(Patientrecord.CentreMultisite).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreMultisite","Patientrecord.CentreMultisite",$classname()),tStatus) Quit
			Set pBatch.CentreMultisite = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "016-") {
			Set tStatus = ##class(Patientrecord.CentreHdj).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreHdj","Patientrecord.CentreHdj",$classname()),tStatus) Quit
			Set pBatch.CentreHdj = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "017-") {
			Set tStatus = ##class(Patientrecord.CentreOuvConsultation).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreOuvConsultation","Patientrecord.CentreOuvConsultation",$classname()),tStatus) Quit
			Set pBatch.CentreOuvConsultation = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "018-") {
			Set tStatus = ##class(Patientrecord.CentrePersoGeriatre).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoGeriatre","Patientrecord.CentrePersoGeriatre",$classname()),tStatus) Quit
			Set pBatch.CentrePersoGeriatre = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "019-") {
			Set tStatus = ##class(Patientrecord.CentrePersoNeurologue).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoNeurologue","Patientrecord.CentrePersoNeurologue",$classname()),tStatus) Quit
			Set pBatch.CentrePersoNeurologue = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "020-") {
			Set tStatus = ##class(Patientrecord.CentrePersoPsychiatre).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoPsychiatre","Patientrecord.CentrePersoPsychiatre",$classname()),tStatus) Quit
			Set pBatch.CentrePersoPsychiatre = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "021-") {
			Set tStatus = ##class(Patientrecord.CentrePersoPsychologue).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoPsychologue","Patientrecord.CentrePersoPsychologue",$classname()),tStatus) Quit
			Set pBatch.CentrePersoPsychologue = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "022-") {
			Set tStatus = ##class(Patientrecord.CentrePersoOrthophoniste).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoOrthophoniste","Patientrecord.CentrePersoOrthophoniste",$classname()),tStatus) Quit
			Set pBatch.CentrePersoOrthophoniste = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "023-") {
			Set tStatus = ##class(Patientrecord.CentrePersoKine).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoKine","Patientrecord.CentrePersoKine",$classname()),tStatus) Quit
			Set pBatch.CentrePersoKine = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "024-") {
			Set tStatus = ##class(Patientrecord.CentrePersoASocial).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoASocial","Patientrecord.CentrePersoASocial",$classname()),tStatus) Quit
			Set pBatch.CentrePersoASocial = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "025-") {
			Set tStatus = ##class(Patientrecord.CentrePersoSecretaire).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoSecretaire","Patientrecord.CentrePersoSecretaire",$classname()),tStatus) Quit
			Set pBatch.CentrePersoSecretaire = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "026-") {
			Set tStatus = ##class(Patientrecord.CentrePersoIDE).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoIDE","Patientrecord.CentrePersoIDE",$classname()),tStatus) Quit
			Set pBatch.CentrePersoIDE = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "027-") {
			Set tStatus = ##class(Patientrecord.CentrePersoARC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoARC","Patientrecord.CentrePersoARC",$classname()),tStatus) Quit
			Set pBatch.CentrePersoARC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "028-") {
			Set tStatus = ##class(Patientrecord.CentrePersoTEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoTEC","Patientrecord.CentrePersoTEC",$classname()),tStatus) Quit
			Set pBatch.CentrePersoTEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "029-") {
			Set tStatus = ##class(Patientrecord.CentrePersoAutre).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoAutre","Patientrecord.CentrePersoAutre",$classname()),tStatus) Quit
			Set pBatch.CentrePersoAutre = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "030-") {
			Set tStatus = ##class(Patientrecord.CentrePersoDescriptionAutre).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentrePersoDescriptionAutre","Patientrecord.CentrePersoDescriptionAutre",$classname()),tStatus) Quit
			Set pBatch.CentrePersoDescriptionAutre = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "031-") {
			Set tStatus = ##class(Patientrecord.CmrrPublications).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrPublications","Patientrecord.CmrrPublications",$classname()),tStatus) Quit
			Set pBatch.CmrrPublications = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "032-") {
			Set tStatus = ##class(Patientrecord.CmrrFormationsUniv).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrFormationsUniv","Patientrecord.CmrrFormationsUniv",$classname()),tStatus) Quit
			Set pBatch.CmrrFormationsUniv = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "033-") {
			Set tStatus = ##class(Patientrecord.CmrrActiviteFormation).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"enregistrement10","Patientrecord.CmrrActiviteFormation",$classname()),tStatus) Quit
			Set pBatch.enregistrement10 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "034-") {
			Set tStatus = ##class(Patientrecord.CmrrActiviteAnimation).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrActiviteAnimation","Patientrecord.CmrrActiviteAnimation",$classname()),tStatus) Quit
			Set pBatch.CmrrActiviteAnimation = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "035-") {
			Set tStatus = ##class(Patientrecord.CmrrActiviteRecherche).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrActiviteRecherche","Patientrecord.CmrrActiviteRecherche",$classname()),tStatus) Quit
			Set pBatch.CmrrActiviteRecherche = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "036-") {
			Set tStatus = ##class(Patientrecord.CmrrActiviteEthique).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrActiviteEthique","Patientrecord.CmrrActiviteEthique",$classname()),tStatus) Quit
			Set pBatch.CmrrActiviteEthique = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "037-") {
			Set tStatus = ##class(Patientrecord.CmrrCmActiviteSoutien).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrCmActiviteSoutien","Patientrecord.CmrrCmActiviteSoutien",$classname()),tStatus) Quit
			Set pBatch.CmrrCmActiviteSoutien = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "038-") {
			Set tStatus = ##class(Patientrecord.CmrrCmActiviteStimul).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CmrrCmActiviteStimul","Patientrecord.CmrrCmActiviteStimul",$classname()),tStatus) Quit
			Set pBatch.CmrrCmActiviteStimul = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "039-") {
			Set tStatus = ##class(Patientrecord.ClTypeSpecialiste).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClTypeSpecialiste","Patientrecord.ClTypeSpecialiste",$classname()),tStatus) Quit
			Set pBatch.ClTypeSpecialiste = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "040-") {
			Set tStatus = ##class(Patientrecord.ClCollabNeuroPsy).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClCollabNeuroPsy","Patientrecord.ClCollabNeuroPsy",$classname()),tStatus) Quit
			Set pBatch.ClCollabNeuroPsy = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "041-") {
			Set tStatus = ##class(Patientrecord.ClPratiqueETP).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClPratiqueETP","Patientrecord.ClPratiqueETP",$classname()),tStatus) Quit
			Set pBatch.ClPratiqueETP = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "042-") {
			Set tStatus = ##class(Patientrecord.ClActiviteConsultMemoire).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClActiviteConsultMemoire","Patientrecord.ClActiviteConsultMemoire",$classname()),tStatus) Quit
			Set pBatch.ClActiviteConsultMemoire = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "043-") {
			Set tStatus = ##class(Patientrecord.ClCollabCmCmrr).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClCollabCmCmrr","Patientrecord.ClCollabCmCmrr",$classname()),tStatus) Quit
			Set pBatch.ClCollabCmCmrr = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "044-") {
			Set tStatus = ##class(Patientrecord.ClActiviteReseau).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClActiviteReseau","Patientrecord.ClActiviteReseau",$classname()),tStatus) Quit
			Set pBatch.ClActiviteReseau = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "045-") {
			Set tStatus = ##class(Patientrecord.ClNbFormAn).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"ClNbFormAn","Patientrecord.ClNbFormAn",$classname()),tStatus) Quit
			Set pBatch.ClNbFormAn = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "046-") {
			Set tStatus = ##class(Patientrecord.PatientId).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientId","Patientrecord.PatientId",$classname()),tStatus) Quit
			Set pBatch.PatientId = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "047-") {
			Set tStatus = ##class(Patientrecord.PatientSexe).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientSexe","Patientrecord.PatientSexe",$classname()),tStatus) Quit
			Set pBatch.PatientSexe = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "048-") {
			Set tStatus = ##class(Patientrecord.PatientAnneeNaissance).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientAnneeNaissance","Patientrecord.PatientAnneeNaissance",$classname()),tStatus) Quit
			Set pBatch.PatientAnneeNaissance = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "049-") {
			Set tStatus = ##class(Patientrecord.PatientNiveauEtudes).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientNiveauEtudes","Patientrecord.PatientNiveauEtudes",$classname()),tStatus) Quit
			Set pBatch.PatientNiveauEtudes = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "050-") {
			Set tStatus = ##class(Patientrecord.PatientSituationGeo).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientSituationGeo","Patientrecord.PatientSituationGeo",$classname()),tStatus) Quit
			Set pBatch.PatientSituationGeo = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "051-") {
			Set tStatus = ##class(Patientrecord.PatientEnvoyePar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"atientEnvoyePar","Patientrecord.PatientEnvoyePar",$classname()),tStatus) Quit
			Set pBatch.atientEnvoyePar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "052-") {
			Set tStatus = ##class(Patientrecord.DclEtatDemence).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclEtatDemence","Patientrecord.DclEtatDemence",$classname()),tStatus) Quit
			Set pBatch.DclEtatDemence = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "053-") {
			Set tStatus = ##class(Patientrecord.DclAnneePremierDiag).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclAnneePremierDiag","Patientrecord.DclAnneePremierDiag",$classname()),tStatus) Quit
			Set pBatch.DclAnneePremierDiag = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "054-") {
			Set tStatus = ##class(Patientrecord.DclDiagnostic).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDiagnostic","Patientrecord.DclDiagnostic",$classname()),tStatus) Quit
			Set pBatch.DclDiagnostic = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "055-") {
			Set tStatus = ##class(Patientrecord.DclTypeActe).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTypeActe","Patientrecord.DclTypeActe",$classname()),tStatus) Quit
			Set pBatch.DclTypeActe = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "056-") {
			Set tStatus = ##class(Patientrecord.DclDateActe).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDateActe","Patientrecord.DclDateActe",$classname()),tStatus) Quit
			Set pBatch.DclDateActe = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "057-") {
			Set tStatus = ##class(Patientrecord.DclMMSE).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclMMSE","Patientrecord.DclMMSE",$classname()),tStatus) Quit
			Set pBatch.DclMMSE = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "058-") {
			Set tStatus = ##class(Patientrecord.DclIADLDetection).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIADLDetection","Patientrecord.DclIADLDetection",$classname()),tStatus) Quit
			Set pBatch.DclIADLDetection = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "059-") {
			Set tStatus = ##class(Patientrecord.DclIADLConsequence).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIADLConsequence","Patientrecord.DclIADLConsequence",$classname()),tStatus) Quit
			Set pBatch.DclIADLConsequence = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "060-") {
			Set tStatus = ##class(Patientrecord.DclModeDeVie).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclModeDeVie","Patientrecord.DclModeDeVie",$classname()),tStatus) Quit
			Set pBatch.DclModeDeVie = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "061-") {
			Set tStatus = ##class(Patientrecord.DclAPA).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclAPA","Patientrecord.DclAPA",$classname()),tStatus) Quit
			Set pBatch.DclAPA = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "062-") {
			Set tStatus = ##class(Patientrecord.DclALD).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclALD","Patientrecord.DclALD",$classname()),tStatus) Quit
			Set pBatch.DclALD = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "063-") {
			Set tStatus = ##class(Patientrecord.DclMesureProtection).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclMesureProtection","Patientrecord.DclMesureProtection",$classname()),tStatus) Quit
			Set pBatch.DclMesureProtection = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "064-") {
			Set tStatus = ##class(Patientrecord.DclFinSuivi).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclFinSuivi","Patientrecord.DclFinSuivi",$classname()),tStatus) Quit
			Set pBatch.DclFinSuivi = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "065-") {
			Set tStatus = ##class(Patientrecord.DclDateFinSuivi).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDateFinSuivi","Patientrecord.DclDateFinSuivi",$classname()),tStatus) Quit
			Set pBatch.DclDateFinSuivi = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "066-") {
			Set tStatus = ##class(Patientrecord.DclDateEntreeInstitution).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDateEntreeInstitution","Patientrecord.DclDateEntreeInstitution",$classname()),tStatus) Quit
			Set pBatch.DclDateEntreeInstitution = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "067-") {
			Set tStatus = ##class(Patientrecord.DclDateDeces).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDateDeces","Patientrecord.DclDateDeces",$classname()),tStatus) Quit
			Set pBatch.DclDateDeces = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "068-") {
			Set tStatus = ##class(Patientrecord.DclTPAucun).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucun","Patientrecord.DclTPAucun",$classname()),tStatus) Quit
			Set pBatch.DclTPAucun = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "069-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetyl).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetyl","Patientrecord.DclTPInhibAcetyl",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetyl = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "070-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDA).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDA","Patientrecord.DclTPAntagonisteNMDA",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDA = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "071-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseurs).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseurs","Patientrecord.DclTPAntidepresseurs",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseurs = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "072-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiques).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiques","Patientrecord.DclTPNeuroleptiques",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiques = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "073-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiques).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiques","Patientrecord.DclTPAnxiolitiques",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiques = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "074-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiques).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiques","Patientrecord.DclTPHypnotiques",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiques = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "075-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropes).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropes","Patientrecord.DclTPNootropes",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropes = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "076-") {
			Set tStatus = ##class(Patientrecord.DclTPAutres).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutres","Patientrecord.DclTPAutres",$classname()),tStatus) Quit
			Set pBatch.DclTPAutres = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "077-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListe).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListe","Patientrecord.DclTPAucunDansListe",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListe = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "078-") {
			Set tStatus = ##class(Patientrecord.DclEffetIndesirable).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclEffetIndesirable","Patientrecord.DclEffetIndesirable",$classname()),tStatus) Quit
			Set pBatch.DclEffetIndesirable = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "079-") {
			Set tStatus = ##class(Patientrecord.DclIPSRAucun).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRAucun","Patientrecord.DclIPSRAucun",$classname()),tStatus) Quit
			Set pBatch.DclIPSRAucun = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "080-") {
			Set tStatus = ##class(Patientrecord.DclIPSROrthophoniste).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSROrthophoniste","Patientrecord.DclIPSROrthophoniste",$classname()),tStatus) Quit
			Set pBatch.DclIPSROrthophoniste = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "081-") {
			Set tStatus = ##class(Patientrecord.DclIPSRPsychologue).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRPsychologue","Patientrecord.DclIPSRPsychologue",$classname()),tStatus) Quit
			Set pBatch.DclIPSRPsychologue = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "082-") {
			Set tStatus = ##class(Patientrecord.DclIPSRKinesitherapeute).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRKinesitherapeute","Patientrecord.DclIPSRKinesitherapeute",$classname()),tStatus) Quit
			Set pBatch.DclIPSRKinesitherapeute = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "083-") {
			Set tStatus = ##class(Patientrecord.DclIPSRErgotherapeute).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRErgotherapeute","Patientrecord.DclIPSRErgotherapeute",$classname()),tStatus) Quit
			Set pBatch.DclIPSRErgotherapeute = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "084-") {
			Set tStatus = ##class(Patientrecord.DclIPSRGroupe).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRGroupe","Patientrecord.DclIPSRGroupe",$classname()),tStatus) Quit
			Set pBatch.DclIPSRGroupe = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "085-") {
			Set tStatus = ##class(Patientrecord.DclIPSRAccueilJour).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRAccueilJour","Patientrecord.DclIPSRAccueilJour",$classname()),tStatus) Quit
			Set pBatch.DclIPSRAccueilJour = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "086-") {
			Set tStatus = ##class(Patientrecord.DclIPSRMaia).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRMaia","Patientrecord.DclIPSRMaia",$classname()),tStatus) Quit
			Set pBatch.DclIPSRMaia = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "087-") {
			Set tStatus = ##class(Patientrecord.DclIPSRClic).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRClic","Patientrecord.DclIPSRClic",$classname()),tStatus) Quit
			Set pBatch.DclIPSRClic = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "088-") {
			Set tStatus = ##class(Patientrecord.DclIPSRRepits).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRRepits","Patientrecord.DclIPSRRepits",$classname()),tStatus) Quit
			Set pBatch.DclIPSRRepits = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "089-") {
			Set tStatus = ##class(Patientrecord.DclIPSRSiad).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRSiad","Patientrecord.DclIPSRSiad",$classname()),tStatus) Quit
			Set pBatch.DclIPSRSiad = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "090-") {
			Set tStatus = ##class(Patientrecord.DclIPSRAutre).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRAutre","Patientrecord.DclIPSRAutre",$classname()),tStatus) Quit
			Set pBatch.DclIPSRAutre = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "091-") {
			Set tStatus = ##class(Patientrecord.DclPCAucun).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCAucun","Patientrecord.DclPCAucun",$classname()),tStatus) Quit
			Set pBatch.DclPCAucun = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "092-") {
			Set tStatus = ##class(Patientrecord.DclPCIRM).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCIRM","Patientrecord.DclPCIRM",$classname()),tStatus) Quit
			Set pBatch.DclPCIRM = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "093-") {
			Set tStatus = ##class(Patientrecord.DclPCScanner).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCScanner","Patientrecord.DclPCScanner",$classname()),tStatus) Quit
			Set pBatch.DclPCScanner = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "094-") {
			Set tStatus = ##class(Patientrecord.DclPCSPECT).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCSPECT","Patientrecord.DclPCSPECT",$classname()),tStatus) Quit
			Set pBatch.DclPCSPECT = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "095-") {
			Set tStatus = ##class(Patientrecord.DclPCPET).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCPET","Patientrecord.DclPCPET",$classname()),tStatus) Quit
			Set pBatch.DclPCPET = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "096-") {
			Set tStatus = ##class(Patientrecord.DclPCBioMarqueurs).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPCBioMarqueurs","Patientrecord.DclPCBioMarqueurs",$classname()),tStatus) Quit
			Set pBatch.DclPCBioMarqueurs = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "097-") {
			Set tStatus = ##class(Patientrecord.DclPR).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPR","Patientrecord.DclPR",$classname()),tStatus) Quit
			Set pBatch.DclPR = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "098-") {
			Set tStatus = ##class(Patientrecord.DclPRType).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPRType","Patientrecord.DclPRType",$classname()),tStatus) Quit
			Set pBatch.DclPRType = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "099-") {
			Set tStatus = ##class(Patientrecord.DclPRVisite).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPRVisite","Patientrecord.DclPRVisite",$classname()),tStatus) Quit
			Set pBatch.DclPRVisite = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "100-") {
			Set tStatus = ##class(Patientrecord.RetourMail).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"RetourMail","Patientrecord.RetourMail",$classname()),tStatus) Quit
			Set pBatch.RetourMail = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "101-") {
			Set tStatus = ##class(Patientrecord.PatientIdPrecedent).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientIdPrecedent","Patientrecord.PatientIdPrecedent",$classname()),tStatus) Quit
			Set pBatch.PatientIdPrecedent = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "102-") {
			Set tStatus = ##class(Patientrecord.Application).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"Application","Patientrecord.Application",$classname()),tStatus) Quit
			Set pBatch.Application = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "103-") {
			Set tStatus = ##class(Patientrecord.CentreNumRmes).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNumRmes","Patientrecord.CentreNumRmes",$classname()),tStatus) Quit
			Set pBatch.CentreNumRmes = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "104-") {
			Set tStatus = ##class(Patientrecord.CentreNumFiness).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNumFiness","Patientrecord.CentreNumFiness",$classname()),tStatus) Quit
			Set pBatch.CentreNumFiness = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "105-") {
			Set tStatus = ##class(Patientrecord.CentreNumAdeli).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNumAdeli","Patientrecord.CentreNumAdeli",$classname()),tStatus) Quit
			Set pBatch.CentreNumAdeli = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "106-") {
			Set tStatus = ##class(Patientrecord.CentreNumRpps).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"CentreNumRpps","Patientrecord.CentreNumRpps",$classname()),tStatus) Quit
			Set pBatch.CentreNumRpps = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "107-") {
			Set tStatus = ##class(Patientrecord.DclCmrrRecours).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclCmrrRecours","Patientrecord.DclCmrrRecours",$classname()),tStatus) Quit
			Set pBatch.DclCmrrRecours = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "108-") {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursDiagDiff).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclCmrrRecoursDiagDiff","Patientrecord.DclCmrrRecoursDiagDiff",$classname()),tStatus) Quit
			Set pBatch.DclCmrrRecoursDiagDiff = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "109-") {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursSuivi).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclCmrrRecoursSuivi","Patientrecord.DclCmrrRecoursSuivi",$classname()),tStatus) Quit
			Set pBatch.DclCmrrRecoursSuivi = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "110-") {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursPTech).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclCmrrRecoursPTech","Patientrecord.DclCmrrRecoursPTech",$classname()),tStatus) Quit
			Set pBatch.DclCmrrRecoursPTech = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "111-") {
			Set tStatus = ##class(Patientrecord.DclCmrrRecoursSpExpert).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclCmrrRecoursSpExpert","Patientrecord.DclCmrrRecoursSpExpert",$classname()),tStatus) Quit
			Set pBatch.DclCmrrRecoursSpExpert = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "112-") {
			Set tStatus = ##class(Patientrecord.PatientProfession).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientProfession","Patientrecord.PatientProfession",$classname()),tStatus) Quit
			Set pBatch.PatientProfession = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "113-") {
			Set tStatus = ##class(Patientrecord.PatientAccompagnant).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"PatientAccompagnant","Patientrecord.PatientAccompagnant",$classname()),tStatus) Quit
			Set pBatch.PatientAccompagnant = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "114-") {
			Set tStatus = ##class(Patientrecord.DclIPSREsad).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSREsad","Patientrecord.DclIPSREsad",$classname()),tStatus) Quit
			Set pBatch.DclIPSREsad = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "115-") {
			Set tStatus = ##class(Patientrecord.DclIPSRHdj).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRHdj","Patientrecord.DclIPSRHdj",$classname()),tStatus) Quit
			Set pBatch.DclIPSRHdj = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "116-") {
			Set tStatus = ##class(Patientrecord.DclIPSRUcc).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRUcc","Patientrecord.DclIPSRUcc",$classname()),tStatus) Quit
			Set pBatch.DclIPSRUcc = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "117-") {
			Set tStatus = ##class(Patientrecord.DclRechPresDispo).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclRechPresDispo","Patientrecord.DclRechPresDispo",$classname()),tStatus) Quit
			Set pBatch.DclRechPresDispo = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "118-") {
			Set tStatus = ##class(Patientrecord.DclRechAutonom).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclRechAutonom","Patientrecord.DclRechAutonom",$classname()),tStatus) Quit
			Set pBatch.DclRechAutonom = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "119-") {
			Set tStatus = ##class(Patientrecord.DclRechContreIndic).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclRechContreIndic","Patientrecord.DclRechContreIndic",$classname()),tStatus) Quit
			Set pBatch.DclRechContreIndic = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "120-") {
			Set tStatus = ##class(Patientrecord.DclRechAcceptPlacebo).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclRechAcceptPlacebo","Patientrecord.DclRechAcceptPlacebo",$classname()),tStatus) Quit
			Set pBatch.DclRechAcceptPlacebo = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "121-") {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN31).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDiagnosticN31","Patientrecord.DclDiagnosticN31",$classname()),tStatus) Quit
			Set pBatch.DclDiagnosticN31 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "122-") {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN32).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDiagnosticN32","Patientrecord.DclDiagnosticN32",$classname()),tStatus) Quit
			Set pBatch.DclDiagnosticN32 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "123-") {
			Set tStatus = ##class(Patientrecord.DclDiagnosticN33).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclDiagnosticN33","Patientrecord.DclDiagnosticN33",$classname()),tStatus) Quit
			Set pBatch.DclDiagnosticN33 = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "124-") {
			Set tStatus = ##class(Patientrecord.DclPECAidant).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclPECAidant","Patientrecord.DclPECAidant",$classname()),tStatus) Quit
			Set pBatch.DclPECAidant = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "125-") {
			Set tStatus = ##class(Patientrecord.DclIPSRGardeMalade).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRGardeMalade","Patientrecord.DclIPSRGardeMalade",$classname()),tStatus) Quit
			Set pBatch.DclIPSRGardeMalade = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "126-") {
			Set tStatus = ##class(Patientrecord.DclIPSRPAERPA).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclIPSRPAERPA","Patientrecord.DclIPSRPAERPA",$classname()),tStatus) Quit
			Set pBatch.DclIPSRPAERPA = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "127-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiques).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiques","Patientrecord.DclTPAntiEpileptiques",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiques = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "128-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateurs).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateurs","Patientrecord.DclTPThymoRegulateurs",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateurs = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "129-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniens).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniens","Patientrecord.DclTPAntiParkinsoniens",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniens = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "130-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDebut","Patientrecord.DclTPAucunDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "131-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetylDebut","Patientrecord.DclTPInhibAcetylDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetylDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "132-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDADebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDADebut","Patientrecord.DclTPAntagonisteNMDADebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDADebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "133-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseursDebut","Patientrecord.DclTPAntidepresseursDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseursDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "134-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiquesDebut","Patientrecord.DclTPNeuroleptiquesDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiquesDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "135-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiquesDebut","Patientrecord.DclTPAnxiolitiquesDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiquesDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "136-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiquesDebut","Patientrecord.DclTPHypnotiquesDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiquesDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "137-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropesDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropesDebut","Patientrecord.DclTPNootropesDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropesDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "138-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiquesDebut","Patientrecord.DclTPAntiEpileptiquesDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiquesDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "139-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateursDebut","Patientrecord.DclTPThymoRegulateursDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateursDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "140-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniensDebut","Patientrecord.DclTPAntiParkinsoniensDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniensDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "141-") {
			Set tStatus = ##class(Patientrecord.DclTPAutresDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutresDebut","Patientrecord.DclTPAutresDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAutresDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "142-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeDebut).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListeDebut","Patientrecord.DclTPAucunDansListeDebut",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListeDebut = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "143-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunFin","Patientrecord.DclTPAucunFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "144-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetylFin","Patientrecord.DclTPInhibAcetylFin",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetylFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "145-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDAFin","Patientrecord.DclTPAntagonisteNMDAFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDAFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "146-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseursFin","Patientrecord.DclTPAntidepresseursFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseursFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "147-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiquesFin","Patientrecord.DclTPNeuroleptiquesFin",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiquesFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "148-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiquesFin","Patientrecord.DclTPAnxiolitiquesFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiquesFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "149-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiquesFin","Patientrecord.DclTPHypnotiquesFin",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiquesFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "150-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropesFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropesFin","Patientrecord.DclTPNootropesFin",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropesFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "151-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiquesFin","Patientrecord.DclTPAntiEpileptiquesFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiquesFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "152-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateursFin","Patientrecord.DclTPThymoRegulateursFin",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateursFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "153-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniensFin","Patientrecord.DclTPAntiParkinsoniensFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniensFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "154-") {
			Set tStatus = ##class(Patientrecord.DclTPAutresFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutresFin","Patientrecord.DclTPAutresFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAutresFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "155-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeFin).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListeFin","Patientrecord.DclTPAucunDansListeFin",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListeFin = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "156-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDebutPar","Patientrecord.DclTPAucunDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "157-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetylDebutPar","Patientrecord.DclTPInhibAcetylDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetylDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "158-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDADebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDADebutPar","Patientrecord.DclTPAntagonisteNMDADebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDADebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "159-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseursDebutPar","Patientrecord.DclTPAntidepresseursDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseursDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "160-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiquesDebutPar","Patientrecord.DclTPNeuroleptiquesDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiquesDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "161-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiquesDebutPar","Patientrecord.DclTPAnxiolitiquesDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiquesDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "162-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiquesDebutPar","Patientrecord.DclTPHypnotiquesDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiquesDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "163-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropesDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropesDebutPar","Patientrecord.DclTPNootropesDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropesDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "164-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiquesDebutPar","Patientrecord.DclTPAntiEpileptiquesDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiquesDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "165-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateursDebutPar","Patientrecord.DclTPThymoRegulateursDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateursDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "166-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniensDebutPar","Patientrecord.DclTPAntiParkinsoniensDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniensDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "167-") {
			Set tStatus = ##class(Patientrecord.DclTPAutresDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutresDebutPar","Patientrecord.DclTPAutresDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAutresDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "168-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeDebutPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListeDebutPar","Patientrecord.DclTPAucunDansListeDebutPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListeDebutPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "169-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunFinPar","Patientrecord.DclTPAucunFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "170-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetylFinPar","Patientrecord.DclTPInhibAcetylFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetylFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "171-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDAFinPar","Patientrecord.DclTPAntagonisteNMDAFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDAFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "172-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseursFinPar","Patientrecord.DclTPAntidepresseursFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseursFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "173-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiquesFinPar","Patientrecord.DclTPNeuroleptiquesFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiquesFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "174-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiquesFinPar","Patientrecord.DclTPAnxiolitiquesFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiquesFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "175-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiquesFinPar","Patientrecord.DclTPHypnotiquesFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiquesFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "176-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropesFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropesFinPar","Patientrecord.DclTPNootropesFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropesFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "177-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiquesFinPar","Patientrecord.DclTPAntiEpileptiquesFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiquesFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "178-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateursFinPar","Patientrecord.DclTPThymoRegulateursFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateursFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "179-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniensFinPar","Patientrecord.DclTPAntiParkinsoniensFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniensFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "180-") {
			Set tStatus = ##class(Patientrecord.DclTPAutresFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutresFinPar","Patientrecord.DclTPAutresFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAutresFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "181-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeFinPar).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListeFinPar","Patientrecord.DclTPAucunDansListeFinPar",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListeFinPar = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "182-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunAvantPEC","Patientrecord.DclTPAucunAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "183-") {
			Set tStatus = ##class(Patientrecord.DclTPInhibAcetylAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPInhibAcetylAvantPEC","Patientrecord.DclTPInhibAcetylAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPInhibAcetylAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "184-") {
			Set tStatus = ##class(Patientrecord.DclTPAntagonisteNMDAAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntagonisteNMDAAvantPEC","Patientrecord.DclTPAntagonisteNMDAAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAntagonisteNMDAAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "185-") {
			Set tStatus = ##class(Patientrecord.DclTPAntidepresseursAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntidepresseursAvantPEC","Patientrecord.DclTPAntidepresseursAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAntidepresseursAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "186-") {
			Set tStatus = ##class(Patientrecord.DclTPNeuroleptiquesAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNeuroleptiquesAvantPEC","Patientrecord.DclTPNeuroleptiquesAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPNeuroleptiquesAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "187-") {
			Set tStatus = ##class(Patientrecord.DclTPAnxiolitiquesAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAnxiolitiquesAvantPEC","Patientrecord.DclTPAnxiolitiquesAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAnxiolitiquesAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "188-") {
			Set tStatus = ##class(Patientrecord.DclTPHypnotiquesAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPHypnotiquesAvantPEC","Patientrecord.DclTPHypnotiquesAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPHypnotiquesAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "189-") {
			Set tStatus = ##class(Patientrecord.DclTPNootropesAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPNootropesAvantPEC","Patientrecord.DclTPNootropesAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPNootropesAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "190-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiEpileptiquesAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiEpileptiquesAvantPEC","Patientrecord.DclTPAntiEpileptiquesAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiEpileptiquesAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "191-") {
			Set tStatus = ##class(Patientrecord.DclTPThymoRegulateursAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPThymoRegulateursAvantPEC","Patientrecord.DclTPThymoRegulateursAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPThymoRegulateursAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "192-") {
			Set tStatus = ##class(Patientrecord.DclTPAntiParkinsoniensAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAntiParkinsoniensAvantPEC","Patientrecord.DclTPAntiParkinsoniensAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAntiParkinsoniensAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "193-") {
			Set tStatus = ##class(Patientrecord.DclTPAutresAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAutresAvantPEC","Patientrecord.DclTPAutresAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAutresAvantPEC = tObject
		}
		If (4 > $length(pLookAhead)) {
			Set pLookAhead = pLookAhead _ pIOStream.Read(4-$length(pLookAhead),pTimeout,.tStatus)
			If $$$ISERR(tStatus) Quit
		}
		If ($extract(pLookAhead,1,4) = "194-") {
			Set tStatus = ##class(Patientrecord.DclTPAucunDansListeAvantPEC).GetObject(pIOStream,.tObject,pTimeout,.pLookAhead)
			If $$$ISERR(tStatus) Set tStatus = $system.Status.AppendStatus($$$ERROR($$$EnsRecordMapErrComplexBasic,"DclTPAucunDansListeAvantPEC","Patientrecord.DclTPAucunDansListeAvantPEC",$classname()),tStatus) Quit
			Set pBatch.DclTPAucunDansListeAvantPEC = tObject
		}
	} Catch {
		Set tStatus = $$$SystemError
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<XData name="ComplexBatch">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<ComplexBatch xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientComplexeRecord" char_encoding="UTF-8" targetClassname="Patientrecord.PatientComplexeRecord.Batch">
  <RecordReference name="CentreNom" required="0" repeating="0" recordMap="Patientrecord.CentreNom">
  </RecordReference>
  <RecordReference name="CentreAdRue1" required="0" repeating="0" recordMap="Patientrecord.CentreAdRue1">
  </RecordReference>
  <RecordReference name="CentreAdRue2" required="0" repeating="0" recordMap="Patientrecord.CentreAdRue2">
  </RecordReference>
  <RecordReference name="CentreAdCp" required="0" repeating="0" recordMap="Patientrecord.CentreAdCp">
  </RecordReference>
  <RecordReference name="CentreAdVille" required="0" repeating="0" recordMap="Patientrecord.CentreAdVille">
  </RecordReference>
  <RecordReference name="CentreMail" required="0" repeating="0" recordMap="Patientrecord.CentreMail">
  </RecordReference>
  <RecordReference name="CentreType" required="0" repeating="0" recordMap="Patientrecord.CentreType">
  </RecordReference>
  <RecordReference name="CentreNum" required="0" repeating="0" recordMap="Patientrecord.CentreNum">
  </RecordReference>
  <RecordReference name="CentreResponsable" required="0" repeating="0" recordMap="Patientrecord.CentreResponsable">
  </RecordReference>
  <RecordReference name="CentreLabel" required="0" repeating="0" recordMap="Patientrecord.CentreLabel">
  </RecordReference>
  <RecordReference name="CentreLabelAnnee" required="0" repeating="0" recordMap="Patientrecord.CentreLabelAnnee">
  </RecordReference>
  <RecordReference name="CentreReseau" required="0" repeating="0" recordMap="Patientrecord.CentreReseau">
  </RecordReference>
  <RecordReference name="CentreNomReseau" required="0" repeating="0" recordMap="Patientrecord.CentreNomReseau">
  </RecordReference>
  <RecordReference name="CentreInclusion" required="0" repeating="0" recordMap="Patientrecord.CentreInclusion">
  </RecordReference>
  <RecordReference name="CentreMultisite" required="0" repeating="0" recordMap="Patientrecord.CentreMultisite">
  </RecordReference>
  <RecordReference name="CentreHdj" required="0" repeating="0" recordMap="Patientrecord.CentreHdj">
  </RecordReference>
  <RecordReference name="CentreOuvConsultation" required="0" repeating="0" recordMap="Patientrecord.CentreOuvConsultation">
  </RecordReference>
  <RecordReference name="CentrePersoGeriatre" required="0" repeating="0" recordMap="Patientrecord.CentrePersoGeriatre">
  </RecordReference>
  <RecordReference name="CentrePersoNeurologue" required="0" repeating="0" recordMap="Patientrecord.CentrePersoNeurologue">
  </RecordReference>
  <RecordReference name="CentrePersoPsychiatre" required="0" repeating="0" recordMap="Patientrecord.CentrePersoPsychiatre">
  </RecordReference>
  <RecordReference name="CentrePersoPsychologue" required="0" repeating="0" recordMap="Patientrecord.CentrePersoPsychologue">
  </RecordReference>
  <RecordReference name="CentrePersoOrthophoniste" required="0" repeating="0" recordMap="Patientrecord.CentrePersoOrthophoniste">
  </RecordReference>
  <RecordReference name="CentrePersoKine" required="0" repeating="0" recordMap="Patientrecord.CentrePersoKine">
  </RecordReference>
  <RecordReference name="CentrePersoASocial" required="0" repeating="0" recordMap="Patientrecord.CentrePersoASocial">
  </RecordReference>
  <RecordReference name="CentrePersoSecretaire" required="0" repeating="0" recordMap="Patientrecord.CentrePersoSecretaire">
  </RecordReference>
  <RecordReference name="CentrePersoIDE" required="0" repeating="0" recordMap="Patientrecord.CentrePersoIDE">
  </RecordReference>
  <RecordReference name="CentrePersoARC" required="0" repeating="0" recordMap="Patientrecord.CentrePersoARC">
  </RecordReference>
  <RecordReference name="CentrePersoTEC" required="0" repeating="0" recordMap="Patientrecord.CentrePersoTEC">
  </RecordReference>
  <RecordReference name="CentrePersoAutre" required="0" repeating="0" recordMap="Patientrecord.CentrePersoAutre">
  </RecordReference>
  <RecordReference name="CentrePersoDescriptionAutre" required="0" repeating="0" recordMap="Patientrecord.CentrePersoDescriptionAutre">
  </RecordReference>
  <RecordReference name="CmrrPublications" required="0" repeating="0" recordMap="Patientrecord.CmrrPublications">
  </RecordReference>
  <RecordReference name="CmrrFormationsUniv" required="0" repeating="0" recordMap="Patientrecord.CmrrFormationsUniv">
  </RecordReference>
  <RecordReference name="enregistrement10" required="0" repeating="0" recordMap="Patientrecord.CmrrActiviteFormation">
  </RecordReference>
  <RecordReference name="CmrrActiviteAnimation" required="0" repeating="0" recordMap="Patientrecord.CmrrActiviteAnimation">
  </RecordReference>
  <RecordReference name="CmrrActiviteRecherche" required="0" repeating="0" recordMap="Patientrecord.CmrrActiviteRecherche">
  </RecordReference>
  <RecordReference name="CmrrActiviteEthique" required="0" repeating="0" recordMap="Patientrecord.CmrrActiviteEthique">
  </RecordReference>
  <RecordReference name="CmrrCmActiviteSoutien" required="0" repeating="0" recordMap="Patientrecord.CmrrCmActiviteSoutien">
  </RecordReference>
  <RecordReference name="CmrrCmActiviteStimul" required="0" repeating="0" recordMap="Patientrecord.CmrrCmActiviteStimul">
  </RecordReference>
  <RecordReference name="ClTypeSpecialiste" required="0" repeating="0" recordMap="Patientrecord.ClTypeSpecialiste">
  </RecordReference>
  <RecordReference name="ClCollabNeuroPsy" required="0" repeating="0" recordMap="Patientrecord.ClCollabNeuroPsy">
  </RecordReference>
  <RecordReference name="ClPratiqueETP" required="0" repeating="0" recordMap="Patientrecord.ClPratiqueETP">
  </RecordReference>
  <RecordReference name="ClActiviteConsultMemoire" required="0" repeating="0" recordMap="Patientrecord.ClActiviteConsultMemoire">
  </RecordReference>
  <RecordReference name="ClCollabCmCmrr" required="0" repeating="0" recordMap="Patientrecord.ClCollabCmCmrr">
  </RecordReference>
  <RecordReference name="ClActiviteReseau" required="0" repeating="0" recordMap="Patientrecord.ClActiviteReseau">
  </RecordReference>
  <RecordReference name="ClNbFormAn" required="0" repeating="0" recordMap="Patientrecord.ClNbFormAn">
  </RecordReference>
  <RecordReference name="PatientId" required="0" repeating="0" recordMap="Patientrecord.PatientId">
  </RecordReference>
  <RecordReference name="PatientSexe" required="0" repeating="0" recordMap="Patientrecord.PatientSexe">
  </RecordReference>
  <RecordReference name="PatientAnneeNaissance" required="0" repeating="0" recordMap="Patientrecord.PatientAnneeNaissance">
  </RecordReference>
  <RecordReference name="PatientNiveauEtudes" required="0" repeating="0" recordMap="Patientrecord.PatientNiveauEtudes">
  </RecordReference>
  <RecordReference name="PatientSituationGeo" required="0" repeating="0" recordMap="Patientrecord.PatientSituationGeo">
  </RecordReference>
  <RecordReference name="atientEnvoyePar" required="0" repeating="0" recordMap="Patientrecord.PatientEnvoyePar">
  </RecordReference>
  <RecordReference name="DclEtatDemence" required="0" repeating="0" recordMap="Patientrecord.DclEtatDemence">
  </RecordReference>
  <RecordReference name="DclAnneePremierDiag" required="0" repeating="0" recordMap="Patientrecord.DclAnneePremierDiag">
  </RecordReference>
  <RecordReference name="DclDiagnostic" required="0" repeating="0" recordMap="Patientrecord.DclDiagnostic">
  </RecordReference>
  <RecordReference name="DclTypeActe" required="0" repeating="0" recordMap="Patientrecord.DclTypeActe">
  </RecordReference>
  <RecordReference name="DclDateActe" required="0" repeating="0" recordMap="Patientrecord.DclDateActe">
  </RecordReference>
  <RecordReference name="DclMMSE" required="0" repeating="0" recordMap="Patientrecord.DclMMSE">
  </RecordReference>
  <RecordReference name="DclIADLDetection" required="0" repeating="0" recordMap="Patientrecord.DclIADLDetection">
  </RecordReference>
  <RecordReference name="DclIADLConsequence" required="0" repeating="0" recordMap="Patientrecord.DclIADLConsequence">
  </RecordReference>
  <RecordReference name="DclModeDeVie" required="0" repeating="0" recordMap="Patientrecord.DclModeDeVie">
  </RecordReference>
  <RecordReference name="DclAPA" required="0" repeating="0" recordMap="Patientrecord.DclAPA">
  </RecordReference>
  <RecordReference name="DclALD" required="0" repeating="0" recordMap="Patientrecord.DclALD">
  </RecordReference>
  <RecordReference name="DclMesureProtection" required="0" repeating="0" recordMap="Patientrecord.DclMesureProtection">
  </RecordReference>
  <RecordReference name="DclFinSuivi" required="0" repeating="0" recordMap="Patientrecord.DclFinSuivi">
  </RecordReference>
  <RecordReference name="DclDateFinSuivi" required="0" repeating="0" recordMap="Patientrecord.DclDateFinSuivi">
  </RecordReference>
  <RecordReference name="DclDateEntreeInstitution" required="0" repeating="0" recordMap="Patientrecord.DclDateEntreeInstitution">
  </RecordReference>
  <RecordReference name="DclDateDeces" required="0" repeating="0" recordMap="Patientrecord.DclDateDeces">
  </RecordReference>
  <RecordReference name="DclTPAucun" required="0" repeating="0" recordMap="Patientrecord.DclTPAucun">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetyl" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetyl">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDA" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDA">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseurs" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseurs">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiques" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiques">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiques" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiques">
  </RecordReference>
  <RecordReference name="DclTPHypnotiques" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiques">
  </RecordReference>
  <RecordReference name="DclTPNootropes" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropes">
  </RecordReference>
  <RecordReference name="DclTPAutres" required="0" repeating="0" recordMap="Patientrecord.DclTPAutres">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListe" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListe">
  </RecordReference>
  <RecordReference name="DclEffetIndesirable" required="0" repeating="0" recordMap="Patientrecord.DclEffetIndesirable">
  </RecordReference>
  <RecordReference name="DclIPSRAucun" required="0" repeating="0" recordMap="Patientrecord.DclIPSRAucun">
  </RecordReference>
  <RecordReference name="DclIPSROrthophoniste" required="0" repeating="0" recordMap="Patientrecord.DclIPSROrthophoniste">
  </RecordReference>
  <RecordReference name="DclIPSRPsychologue" required="0" repeating="0" recordMap="Patientrecord.DclIPSRPsychologue">
  </RecordReference>
  <RecordReference name="DclIPSRKinesitherapeute" required="0" repeating="0" recordMap="Patientrecord.DclIPSRKinesitherapeute">
  </RecordReference>
  <RecordReference name="DclIPSRErgotherapeute" required="0" repeating="0" recordMap="Patientrecord.DclIPSRErgotherapeute">
  </RecordReference>
  <RecordReference name="DclIPSRGroupe" required="0" repeating="0" recordMap="Patientrecord.DclIPSRGroupe">
  </RecordReference>
  <RecordReference name="DclIPSRAccueilJour" required="0" repeating="0" recordMap="Patientrecord.DclIPSRAccueilJour">
  </RecordReference>
  <RecordReference name="DclIPSRMaia" required="0" repeating="0" recordMap="Patientrecord.DclIPSRMaia">
  </RecordReference>
  <RecordReference name="DclIPSRClic" required="0" repeating="0" recordMap="Patientrecord.DclIPSRClic">
  </RecordReference>
  <RecordReference name="DclIPSRRepits" required="0" repeating="0" recordMap="Patientrecord.DclIPSRRepits">
  </RecordReference>
  <RecordReference name="DclIPSRSiad" required="0" repeating="0" recordMap="Patientrecord.DclIPSRSiad">
  </RecordReference>
  <RecordReference name="DclIPSRAutre" required="0" repeating="0" recordMap="Patientrecord.DclIPSRAutre">
  </RecordReference>
  <RecordReference name="DclPCAucun" required="0" repeating="0" recordMap="Patientrecord.DclPCAucun">
  </RecordReference>
  <RecordReference name="DclPCIRM" required="0" repeating="0" recordMap="Patientrecord.DclPCIRM">
  </RecordReference>
  <RecordReference name="DclPCScanner" required="0" repeating="0" recordMap="Patientrecord.DclPCScanner">
  </RecordReference>
  <RecordReference name="DclPCSPECT" required="0" repeating="0" recordMap="Patientrecord.DclPCSPECT">
  </RecordReference>
  <RecordReference name="DclPCPET" required="0" repeating="0" recordMap="Patientrecord.DclPCPET">
  </RecordReference>
  <RecordReference name="DclPCBioMarqueurs" required="0" repeating="0" recordMap="Patientrecord.DclPCBioMarqueurs">
  </RecordReference>
  <RecordReference name="DclPR" required="0" repeating="0" recordMap="Patientrecord.DclPR">
  </RecordReference>
  <RecordReference name="DclPRType" required="0" repeating="0" recordMap="Patientrecord.DclPRType">
  </RecordReference>
  <RecordReference name="DclPRVisite" required="0" repeating="0" recordMap="Patientrecord.DclPRVisite">
  </RecordReference>
  <RecordReference name="RetourMail" required="0" repeating="0" recordMap="Patientrecord.RetourMail">
  </RecordReference>
  <RecordReference name="PatientIdPrecedent" required="0" repeating="0" recordMap="Patientrecord.PatientIdPrecedent">
  </RecordReference>
  <RecordReference name="Application" required="0" repeating="0" recordMap="Patientrecord.Application">
  </RecordReference>
  <RecordReference name="CentreNumRmes" required="0" repeating="0" recordMap="Patientrecord.CentreNumRmes">
  </RecordReference>
  <RecordReference name="CentreNumFiness" required="0" repeating="0" recordMap="Patientrecord.CentreNumFiness">
  </RecordReference>
  <RecordReference name="CentreNumAdeli" required="0" repeating="0" recordMap="Patientrecord.CentreNumAdeli">
  </RecordReference>
  <RecordReference name="CentreNumRpps" required="0" repeating="0" recordMap="Patientrecord.CentreNumRpps">
  </RecordReference>
  <RecordReference name="DclCmrrRecours" required="0" repeating="0" recordMap="Patientrecord.DclCmrrRecours">
  </RecordReference>
  <RecordReference name="DclCmrrRecoursDiagDiff" required="0" repeating="0" recordMap="Patientrecord.DclCmrrRecoursDiagDiff">
  </RecordReference>
  <RecordReference name="DclCmrrRecoursSuivi" required="0" repeating="0" recordMap="Patientrecord.DclCmrrRecoursSuivi">
  </RecordReference>
  <RecordReference name="DclCmrrRecoursPTech" required="0" repeating="0" recordMap="Patientrecord.DclCmrrRecoursPTech">
  </RecordReference>
  <RecordReference name="DclCmrrRecoursSpExpert" required="0" repeating="0" recordMap="Patientrecord.DclCmrrRecoursSpExpert">
  </RecordReference>
  <RecordReference name="PatientProfession" required="0" repeating="0" recordMap="Patientrecord.PatientProfession">
  </RecordReference>
  <RecordReference name="PatientAccompagnant" required="0" repeating="0" recordMap="Patientrecord.PatientAccompagnant">
  </RecordReference>
  <RecordReference name="DclIPSREsad" required="0" repeating="0" recordMap="Patientrecord.DclIPSREsad">
  </RecordReference>
  <RecordReference name="DclIPSRHdj" required="0" repeating="0" recordMap="Patientrecord.DclIPSRHdj">
  </RecordReference>
  <RecordReference name="DclIPSRUcc" required="0" repeating="0" recordMap="Patientrecord.DclIPSRUcc">
  </RecordReference>
  <RecordReference name="DclRechPresDispo" required="0" repeating="0" recordMap="Patientrecord.DclRechPresDispo">
  </RecordReference>
  <RecordReference name="DclRechAutonom" required="0" repeating="0" recordMap="Patientrecord.DclRechAutonom">
  </RecordReference>
  <RecordReference name="DclRechContreIndic" required="0" repeating="0" recordMap="Patientrecord.DclRechContreIndic">
  </RecordReference>
  <RecordReference name="DclRechAcceptPlacebo" required="0" repeating="0" recordMap="Patientrecord.DclRechAcceptPlacebo">
  </RecordReference>
  <RecordReference name="DclDiagnosticN31" required="0" repeating="0" recordMap="Patientrecord.DclDiagnosticN31">
  </RecordReference>
  <RecordReference name="DclDiagnosticN32" required="0" repeating="0" recordMap="Patientrecord.DclDiagnosticN32">
  </RecordReference>
  <RecordReference name="DclDiagnosticN33" required="0" repeating="0" recordMap="Patientrecord.DclDiagnosticN33">
  </RecordReference>
  <RecordReference name="DclPECAidant" required="0" repeating="0" recordMap="Patientrecord.DclPECAidant">
  </RecordReference>
  <RecordReference name="DclIPSRGardeMalade" required="0" repeating="0" recordMap="Patientrecord.DclIPSRGardeMalade">
  </RecordReference>
  <RecordReference name="DclIPSRPAERPA" required="0" repeating="0" recordMap="Patientrecord.DclIPSRPAERPA">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiques" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiques">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateurs" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateurs">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniens" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniens">
  </RecordReference>
  <RecordReference name="DclTPAucunDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDebut">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetylDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetylDebut">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDADebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDADebut">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseursDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseursDebut">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiquesDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiquesDebut">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiquesDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiquesDebut">
  </RecordReference>
  <RecordReference name="DclTPHypnotiquesDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiquesDebut">
  </RecordReference>
  <RecordReference name="DclTPNootropesDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropesDebut">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiquesDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiquesDebut">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateursDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateursDebut">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniensDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniensDebut">
  </RecordReference>
  <RecordReference name="DclTPAutresDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAutresDebut">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListeDebut" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListeDebut">
  </RecordReference>
  <RecordReference name="DclTPAucunFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunFin">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetylFin" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetylFin">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDAFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDAFin">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseursFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseursFin">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiquesFin" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiquesFin">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiquesFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiquesFin">
  </RecordReference>
  <RecordReference name="DclTPHypnotiquesFin" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiquesFin">
  </RecordReference>
  <RecordReference name="DclTPNootropesFin" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropesFin">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiquesFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiquesFin">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateursFin" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateursFin">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniensFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniensFin">
  </RecordReference>
  <RecordReference name="DclTPAutresFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAutresFin">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListeFin" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListeFin">
  </RecordReference>
  <RecordReference name="DclTPAucunDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDebutPar">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetylDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetylDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDADebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDADebutPar">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseursDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseursDebutPar">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiquesDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiquesDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiquesDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiquesDebutPar">
  </RecordReference>
  <RecordReference name="DclTPHypnotiquesDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiquesDebutPar">
  </RecordReference>
  <RecordReference name="DclTPNootropesDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropesDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiquesDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiquesDebutPar">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateursDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateursDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniensDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniensDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAutresDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAutresDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListeDebutPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListeDebutPar">
  </RecordReference>
  <RecordReference name="DclTPAucunFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunFinPar">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetylFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetylFinPar">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDAFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDAFinPar">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseursFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseursFinPar">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiquesFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiquesFinPar">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiquesFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiquesFinPar">
  </RecordReference>
  <RecordReference name="DclTPHypnotiquesFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiquesFinPar">
  </RecordReference>
  <RecordReference name="DclTPNootropesFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropesFinPar">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiquesFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiquesFinPar">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateursFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateursFinPar">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniensFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniensFinPar">
  </RecordReference>
  <RecordReference name="DclTPAutresFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAutresFinPar">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListeFinPar" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListeFinPar">
  </RecordReference>
  <RecordReference name="DclTPAucunAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPInhibAcetylAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPInhibAcetylAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAntagonisteNMDAAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAntagonisteNMDAAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAntidepresseursAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAntidepresseursAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPNeuroleptiquesAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPNeuroleptiquesAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAnxiolitiquesAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAnxiolitiquesAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPHypnotiquesAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPHypnotiquesAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPNootropesAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPNootropesAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAntiEpileptiquesAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiEpileptiquesAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPThymoRegulateursAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPThymoRegulateursAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAntiParkinsoniensAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAntiParkinsoniensAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAutresAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAutresAvantPEC">
  </RecordReference>
  <RecordReference name="DclTPAucunDansListeAvantPEC" required="0" repeating="0" recordMap="Patientrecord.DclTPAucunDansListeAvantPEC">
  </RecordReference>
</ComplexBatch>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientEnvoyePar">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientEnvoyePar'
on 2023-03-08 at 13:47:33.584 [2023-03-08 13:47:33.584 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.585091118</TimeChanged>
<TimeCreated>66527,35332.642661497</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientEnvoyePar.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "051-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("051-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientEnvoyePar.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["051-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientEnvoyePar" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientEnvoyePar.Record" complexBatchManaged="1" label="051-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientEnvoyePar.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientEnvoyePar'
on 2023-03-08 at 13:47:33.579 [2023-03-08 13:47:33.579 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.60644131</TimeChanged>
<TimeCreated>66541,49653.579247821</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientEnvoyePar.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patie44F5.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patie44F5.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patie44F5.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patie44F5.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientId">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientId'
on 2023-03-08 at 13:47:32.818 [2023-03-08 13:47:32.818 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.818793222</TimeChanged>
<TimeCreated>66526,51600.541394875</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientId.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "046-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.PatientId = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("046-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.PatientId,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientId.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["046-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientId" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientId.Record" complexBatchManaged="1" label="046-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="PatientId" required="1" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="1" ignored="0" datatype="%String" params="MAXLEN=999" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientId.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientId'
on 2023-03-08 at 13:47:32.813 [2023-03-08 13:47:32.813 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.839592214</TimeChanged>
<TimeCreated>66541,49652.813019225</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PatientId">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="NewField2">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="999"/>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientId.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patie5989.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patie5989.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patie5989.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patie5989.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientId</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientIdPrecedent">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientIdPrecedent'
on 2023-03-08 at 13:47:41.264 [2023-03-08 13:47:41.264 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.265333998</TimeChanged>
<TimeCreated>66527,40571.627419983</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientIdPrecedent.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "101-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("101-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientIdPrecedent.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["101-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientIdPrecedent" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientIdPrecedent.Record" complexBatchManaged="1" label="101-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientIdPrecedent.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientIdPrecedent'
on 2023-03-08 at 13:47:41.259 [2023-03-08 13:47:41.259 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.286600403</TimeChanged>
<TimeCreated>66541,49661.259542597</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientIdPrecedent.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.PatieCBE7.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.PatieCBE7.RecordD</IdLocation>
<IndexLocation>^Patientrecord.PatieCBE7.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.PatieCBE7.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientNiveauEtudes">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientNiveauEtudes'
on 2023-03-08 at 13:47:33.277 [2023-03-08 13:47:33.277 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.27804684</TimeChanged>
<TimeCreated>66526,51761.023250365</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientNiveauEtudes.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "049-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.PatientNiveauEtudes = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("049-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.PatientNiveauEtudes,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientNiveauEtudes.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["049-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientNiveauEtudes" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientNiveauEtudes.Record" complexBatchManaged="1" label="049-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="PatientNiveauEtudes" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientNiveauEtudes.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientNiveauEtudes'
on 2023-03-08 at 13:47:33.272 [2023-03-08 13:47:33.272 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.299288232</TimeChanged>
<TimeCreated>66541,49653.272186242</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PatientNiveauEtudes">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientNiveauEtudes.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patie4E96.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patie4E96.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patie4E96.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patie4E96.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientNiveauEtudes</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientProfession">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientProfession'
on 2023-03-08 at 13:47:42.968 [2023-03-08 13:47:42.968 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49662.969602721</TimeChanged>
<TimeCreated>66527,49345.888914894</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientProfession.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "112-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("112-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientProfession.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["112-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientProfession" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientProfession.Record" complexBatchManaged="1" label="112-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientProfession.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientProfession'
on 2023-03-08 at 13:47:42.963 [2023-03-08 13:47:42.963 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49662.990480426</TimeChanged>
<TimeCreated>66541,49662.963807919</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientProfession.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patien11C.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patien11C.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patien11C.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patien11C.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientSexe">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientSexe'
on 2023-03-08 at 13:47:32.970 [2023-03-08 13:47:32.970 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49652.971652962</TimeChanged>
<TimeCreated>66526,51647.697947292</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientSexe.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "047-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.PatientSexe = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("047-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.PatientSexe,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientSexe.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["047-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientSexe" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientSexe.Record" complexBatchManaged="1" label="047-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="PatientSexe" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientSexe.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientSexe'
on 2023-03-08 at 13:47:32.965 [2023-03-08 13:47:32.965 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49652.992880653</TimeChanged>
<TimeCreated>66541,49652.965877464</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PatientSexe">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientSexe.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.Patie5913.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.Patie5913.RecordD</IdLocation>
<IndexLocation>^Patientrecord.Patie5913.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.Patie5913.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientSexe</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.PatientSituationGeo">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.PatientSituationGeo'
on 2023-03-08 at 13:47:33.430 [2023-03-08 13:47:33.430 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49653.431367579</TimeChanged>
<TimeCreated>66526,51846.272030176</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.PatientSituationGeo.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "050-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.PatientSituationGeo = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("050-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.PatientSituationGeo,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.PatientSituationGeo.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["050-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.PatientSituationGeo" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.PatientSituationGeo.Record" complexBatchManaged="1" label="050-" padFromLeft="0" recordTerminator="\x0a" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="PatientSituationGeo" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String" repeating="0">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.PatientSituationGeo.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.PatientSituationGeo'
on 2023-03-08 at 13:47:33.425 [2023-03-08 13:47:33.425 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49653.452748871</TimeChanged>
<TimeCreated>66541,49653.425539682</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="PatientSituationGeo">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.PatientSituationGeo.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.PatieE153.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.PatieE153.RecordD</IdLocation>
<IndexLocation>^Patientrecord.PatieE153.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.PatieE153.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>PatientSituationGeo</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Patientrecord.RetourMail">
<Description>
RECORDMAP: Modified during compilation of RecordMap 'Patientrecord.RetourMail'
on 2023-03-08 at 13:47:41.112 [2023-03-08 13:47:41.112 UTC]
by user WafikMA_IRIS</Description>
<Super>EnsLib.RecordMap.RecordMap</Super>
<TimeChanged>66541,49661.11333236</TimeChanged>
<TimeCreated>66527,40507.009513711</TimeCreated>

<Method name="GetObject">
<Description>
Method to retrieve a record from a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,*pObject:%RegisteredObject,pTimeout:%Numeric=-1,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		Set pObject = $$$NULLOREF
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,,pTimeout,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tObjectName = $parameter($this,"OBJECTNAME")
		Set tObject = $classmethod(tObjectName,"%New")
		If '$IsObject(tObject) {
			Set tStatus = $$$ERROR($$$CannotCreateObject,tObjectName)
			Quit
		}
		Set tObject.%Source = pStream.Name
		Set tGetTopFields = $parameter(tObject,"INCLUDETOPFIELDS")
		If pStream.AtEnd && (""=pLookAhead) {
			Set tStatus = $$$ERROR($$$EnsRecordMapErrStreamAtEnd, pStream.Name)
			Quit
		}
		Set pStream.CharEncoding = "UTF-8"

		#; Parse incoming stream
		Set tStatus = ..GetRecord(pStream, tObject, tGetTopFields, pTimeout, .pLookAhead, pLabelFound)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	If $$$ISERR(tStatus) { Set pObject = $$$NULLOREF }
	Else { Set pObject = tObject }
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutObject">
<Description>
Method to write a record to a stream or device. This method will be generated based on the
structure of the RecordMap. For testing purposes, a file name may be passed in the pStream argument.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pFlush:%Boolean=1,&pPadArray:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tStatus = $$$OK
		If '$IsObject(pStream) {
			Set tFilename = pStream
			Set pStream = ##class(%IO.FileStream).%New()
			Do pStream.Open(tFilename,"WAE",,"UTF-8", .tStatus)
			If $$$ISERR(tStatus) Quit
		}
		Set tHasTopFields = $parameter(pObject,"INCLUDETOPFIELDS")
		Set pStream.CharEncoding = "UTF-8"

		Set tStatus = ..PutRecord(pStream, pObject, tHasTopFields, .pPadArray)
		If $$$ISERR(tStatus) Quit
		If pFlush Do pStream.Flush(.tStatus)
		If $$$ISERR(tStatus) Quit
	}
	Catch ex {
		Set tStatus = ex.AsStatus()
	}
	Quit tStatus
]]></Implementation>
</Method>

<Parameter name="OBJECTNAME">
<Default>Patientrecord.RetourMail.Record</Default>
</Parameter>

<Method name="GetRecord">
<Description>
Internal helper method to perform parse of incoming data</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pGetTopFields:%Boolean,pTimeout:%Numeric,&pLookAhead:%String="",pLabelFound:%Boolean=0]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	If pLabelFound { Set tRecLabel = "" } 
	Else { Set tRecLabel = "100-" } 
	Set tStatus = ..chunkRecord(pStream, .tRecordData, .tCharCount, "", pTimeout, $char(10), tRecLabel, .pLookAhead, "")
	If $$$ISERR(tStatus) Quit tStatus
	Set tMaxLocal = $$$MaxLocalLength
	Set tRecordData("charcount") = +$get(tCharCount)
	Set tCurrChunk = 1
	Set tTopPiece = 1
	Set tCurrSep = 1
	Set tStrings = 1
	Set tCurrString = ""
	Set tSeps = $listbuild($char(58))
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Else {
		Set tCurrString = tRecordData(tCurrChunk)
		Set tCurrPiece = 1
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField1 = tCurrString
	}
	If '$data(tRecordData(tCurrChunk, "block")) {
		Set tCurrString = $piece(tRecordData(tCurrChunk), $char(58), tTopPiece)
	}
	Do ..checkMerge(.tCurrChunk, .tRecordData, .tCurrString, $char(58), .tTopPiece)
	If pGetTopFields {
		Set pObject.NewField2 = tCurrString
	}
	Quit tStatus
]]></Implementation>
</Method>

<Method name="PutRecord">
<Description>
Internal helper method to output object to a stream</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStream:%IO.DeviceStream,pObject:%RegisteredObject,pHasTopFields:%Boolean,&pPadArray:%String]]></FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tStatus = $$$OK
	Set tmpStream=##class(%Stream.TmpBinary).%New()
	Set tStatus = tmpStream.Write("100-")
	If $$$ISERR(tStatus) Quit tStatus
	Do tmpStream.Write($select(pHasTopFields: pObject.NewField1,1: ""))
	Do tmpStream.Write($char(58) _ $select(pHasTopFields: pObject.NewField2,1: ""))
	Set tStatus = tmpStream.Write($char(10))
	If $$$ISERR(tStatus) Quit tStatus
	Do pStream.CopyFrom(tmpStream,,0,.tStatus)
	Quit tStatus
]]></Implementation>
</Method>

<Method name="GetGeneratedClasses">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pClasses:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill pClasses
	Set pClasses("Patientrecord.RetourMail.Record")=""
	Set pClasses($classname())=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="getIdentifier">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA["100-"
]]></Implementation>
</Method>

<Method name="getType">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec/>
<ReturnType>EnsLib.RecordMap.Model.DataType.RecordType</ReturnType>
<Implementation><![CDATA["delimited"
]]></Implementation>
</Method>

<XData name="RecordMap">
<XMLNamespace>http://www.intersystems.com/Ensemble/RecordMap</XMLNamespace>
<Data><![CDATA[
<Record xmlns="http://www.intersystems.com/Ensemble/RecordMap" name="Patientrecord.RetourMail" type="delimited" char_encoding="UTF-8" targetClassname="Patientrecord.RetourMail.Record" complexBatchManaged="1" label="100-" padFromLeft="0" recordTerminator="\x0a" allowEmbeddedRecordTerminator="0" allowEarlyTerminator="0">
  <Separators>
    <Separator>:</Separator>
  </Separators>
  <Field name="NewField1" required="0" ignored="0" datatype="%String">
  </Field>
  <Field name="NewField2" required="0" ignored="0" datatype="%String">
  </Field>
</Record>
]]></Data>
</XData>
</Class>


<Class name="Patientrecord.RetourMail.Record">
<Description>
RECORDMAP: Generated from RecordMap 'Patientrecord.RetourMail'
on 2023-03-08 at 13:47:41.107 [2023-03-08 13:47:41.107 UTC]
by user WafikMA_IRIS</Description>
<ProcedureBlock>1</ProcedureBlock>
<Super>EnsLib.RecordMap.ComplexChild,%XML.Adaptor,Ens.Request,EnsLib.RecordMap.Base</Super>
<TimeChanged>66541,49661.134148566</TimeChanged>
<TimeCreated>66541,49661.107620259</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INCLUDETOPFIELDS">
<Default>1</Default>
</Parameter>

<Property name="NewField1">
<Type>%String</Type>
</Property>

<Property name="NewField2">
<Type>%String</Type>
</Property>

<Trigger name="OnDelete">
<Code>	Set %ok = ##class(Patientrecord.RetourMail.Record).%OnDelete($$$oidForm({ID})) If $$$ISERR(%ok) Quit
</Code>
<Event>DELETE</Event>
</Trigger>

<Parameter name="RECORDMAPGENERATED">
<Default>1</Default>
</Parameter>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^Patientrecord.RetouD736.RecordD</DataLocation>
<DefaultData>RecordDefaultData</DefaultData>
<IdLocation>^Patientrecord.RetouD736.RecordD</IdLocation>
<IndexLocation>^Patientrecord.RetouD736.RecordI</IndexLocation>
<StreamLocation>^Patientrecord.RetouD736.RecordS</StreamLocation>
<ExtentSize>2000000</ExtentSize>
<Data name="RecordDefaultData">
<Structure>listnode</Structure>
<Subscript/>
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>NewField1</Value>
</Value>
<Value name="3">
<Value>%Source</Value>
</Value>
<Value name="4">
<Value>NewField2</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="user.ListesItems">
<ClassType>persistent</ClassType>
<Super>Ens.Request</Super>
<TimeChanged>66478,38350.627799287</TimeChanged>
<TimeCreated>66478,38187.168139755</TimeCreated>

<Property name="ItemNom">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100000"/>
</Property>

<Property name="ItemNomCourt">
<Type>%String</Type>
<Parameter name="MAXLEN" value="3000000"/>
</Property>

<Property name="ItemOrdre">
<Type>%String</Type>
<Parameter name="MAXLEN" value="30000000"/>
</Property>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DefaultData>ListesItemsDefaultData</DefaultData>
<Data name="ListesItemsDefaultData">
<Structure>listnode</Structure>
<Subscript>"ListesItems"</Subscript>
<Value name="1">
<Value>ItemNom</Value>
</Value>
<Value name="2">
<Value>ItemNomCourt</Value>
</Value>
<Value name="3">
<Value>ItemOrdre</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="user.patientlist">
<Super>Ens.BusinessService</Super>
<TimeChanged>66478,38854.754628649</TimeChanged>
<TimeCreated>66478,35989.369463428</TimeCreated>

<Parameter name="ADAPTER">
<Default>Ens.InboundAdapter</Default>
</Parameter>

<Method name="OnProcessInput">
<FormalSpec>pInput:%RegisteredObject,pOutput:%RegisteredObject</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
     $$$LOGINFO("wafik")
   SET myquery =" SELECT ID, ItemNom, ItemNomCourt, ItemOrdre, ItemParent, ItemTip, Liste FROM Bna.ListesItems where Liste= 15 "
   set statement=##class(%SQL.Statement).%New()
   set status=statement.%Prepare(myquery)
   
   set rset=statement.%Execute()
   set pr=##class(user.ListesItems).%New()
   set xx = 12345678
    While rset.%Next()
    {
            
            set pr.ItemNom = rset.%Get("ItemNom")
            set pr.ItemNomCourt = rset.%Get("ItemNomCourt")
            set pr.ItemOrdre = xx


            $$$LOGINFO("pr.ItemNom : "_pr.ItemNom)
             
              Set tSC = ..SendRequestSync("BPL.patienttofhir", pr, .pResponse)
              set xx =xx+1
            }
   QUIT 1
]]></Implementation>
</Method>
</Class>


<Document name="EnsExportNotes.EnsExportProduction_2023-03-08 14-12-18_144+0.PTD"><ProjectTextDocument name="EnsExportNotes.EnsExportProduction_2023-03-08 14-12-18_144+0" description="Export Notes for export EnsExportProduction_2023-03-08 14-12-18_144+0">
<![CDATA[<Deployment>
<Creation>
<Machine>DDA7AC4469D3</Machine>
<Instance>IRIS</Instance>
<Namespace>BNATEST</Namespace>
<SourceProduction>BNATESTPKG.FoundationProduction</SourceProduction>
<Username>WafikMA_IRIS</Username>
<UTC>2023-03-08 14:14:44.934</UTC>
</Creation>
<Notes>
</Notes>
<Contents>
<ExportProject>EnsExportProduction_2023-03-08 14-12-18_144+0</ExportProject>
<Item num="1">BNATESTPKG.FoundationProduction.CLS</Item>
<Item num="2">BNAsql.ajouttableActes.CLS</Item>
<Item num="3">BNAsql.ajouttablePatientPravite.CLS</Item>
<Item num="4">BNAsql.insertintotableIntermidiare.CLS</Item>
<Item num="5">BNAsql.testinsertdanstabledetest2.CLS</Item>
<Item num="6">BNAtest.TBNAFHIRtestpractionner.CLS</Item>
<Item num="7">BPL.patienttofhir.CLS</Item>
<Item num="8">BPLBNA.BPLCSVBNA.CLS</Item>
<Item num="9">BPLBNA.ajoutdanssql.CLS</Item>
<Item num="10">Bna.Actes.CLS</Item>
<Item num="11">Bna.Centres.CLS</Item>
<Item num="12">Bna.CentresAnnuels.CLS</Item>
<Item num="13">Bna.Listes.CLS</Item>
<Item num="14">Bna.ListesItems.CLS</Item>
<Item num="15">Bna.Patients.CLS</Item>
<Item num="16">Bna.PatientsPrivate.CLS</Item>
<Item num="17">Bna.TraceActions.CLS</Item>
<Item num="18">Bna.TraceMessages.CLS</Item>
<Item num="19">Bna.Traitements.CLS</Item>
<Item num="20">Bna.TraitementsActes.CLS</Item>
<Item num="21">Bna.tableSQLintermidiare.CLS</Item>
<Item num="22">Bna.testtableinsert.CLS</Item>
<Item num="23">DTL.patienttofhirdtl.CLS</Item>
<Item num="24">Patientrecord.Application.CLS</Item>
<Item num="25">Patientrecord.Application.Record.CLS</Item>
<Item num="26">Patientrecord.CentreAdCp.CLS</Item>
<Item num="27">Patientrecord.CentreAdCp.Record.CLS</Item>
<Item num="28">Patientrecord.CentreAdRue1.CLS</Item>
<Item num="29">Patientrecord.CentreAdRue1.Record.CLS</Item>
<Item num="30">Patientrecord.CentreAdRue2.CLS</Item>
<Item num="31">Patientrecord.CentreAdRue2.Record.CLS</Item>
<Item num="32">Patientrecord.CentreAdVille.CLS</Item>
<Item num="33">Patientrecord.CentreAdVille.Record.CLS</Item>
<Item num="34">Patientrecord.CentreHdj.CLS</Item>
<Item num="35">Patientrecord.CentreHdj.Record.CLS</Item>
<Item num="36">Patientrecord.CentreInclusion.CLS</Item>
<Item num="37">Patientrecord.CentreInclusion.Record.CLS</Item>
<Item num="38">Patientrecord.CentreLabel.CLS</Item>
<Item num="39">Patientrecord.CentreLabel.Record.CLS</Item>
<Item num="40">Patientrecord.CentreLabelAnnee.CLS</Item>
<Item num="41">Patientrecord.CentreLabelAnnee.Record.CLS</Item>
<Item num="42">Patientrecord.CentreMail.CLS</Item>
<Item num="43">Patientrecord.CentreMail.Record.CLS</Item>
<Item num="44">Patientrecord.CentreMultisite.CLS</Item>
<Item num="45">Patientrecord.CentreMultisite.Record.CLS</Item>
<Item num="46">Patientrecord.CentreNom.CLS</Item>
<Item num="47">Patientrecord.CentreNom.Record.CLS</Item>
<Item num="48">Patientrecord.CentreNomReseau.CLS</Item>
<Item num="49">Patientrecord.CentreNomReseau.Record.CLS</Item>
<Item num="50">Patientrecord.CentreNum.CLS</Item>
<Item num="51">Patientrecord.CentreNum.Record.CLS</Item>
<Item num="52">Patientrecord.CentreNumAdeli.CLS</Item>
<Item num="53">Patientrecord.CentreNumAdeli.Record.CLS</Item>
<Item num="54">Patientrecord.CentreNumFiness.CLS</Item>
<Item num="55">Patientrecord.CentreNumFiness.Record.CLS</Item>
<Item num="56">Patientrecord.CentreNumRmes.CLS</Item>
<Item num="57">Patientrecord.CentreNumRmes.Record.CLS</Item>
<Item num="58">Patientrecord.CentreNumRpps.CLS</Item>
<Item num="59">Patientrecord.CentreNumRpps.Record.CLS</Item>
<Item num="60">Patientrecord.CentreOuvConsultation.CLS</Item>
<Item num="61">Patientrecord.CentreOuvConsultation.Record.CLS</Item>
<Item num="62">Patientrecord.CentrePersoARC.CLS</Item>
<Item num="63">Patientrecord.CentrePersoARC.Record.CLS</Item>
<Item num="64">Patientrecord.CentrePersoASocial.CLS</Item>
<Item num="65">Patientrecord.CentrePersoASocial.Record.CLS</Item>
<Item num="66">Patientrecord.CentrePersoAutre.CLS</Item>
<Item num="67">Patientrecord.CentrePersoAutre.Record.CLS</Item>
<Item num="68">Patientrecord.CentrePersoDescriptionAutre.CLS</Item>
<Item num="69">Patientrecord.CentrePersoDescriptionAutre.Record.CLS</Item>
<Item num="70">Patientrecord.CentrePersoGeriatre.CLS</Item>
<Item num="71">Patientrecord.CentrePersoGeriatre.Record.CLS</Item>
<Item num="72">Patientrecord.CentrePersoIDE.CLS</Item>
<Item num="73">Patientrecord.CentrePersoIDE.Record.CLS</Item>
<Item num="74">Patientrecord.CentrePersoKine.CLS</Item>
<Item num="75">Patientrecord.CentrePersoKine.Record.CLS</Item>
<Item num="76">Patientrecord.CentrePersoNeurologue.CLS</Item>
<Item num="77">Patientrecord.CentrePersoNeurologue.Record.CLS</Item>
<Item num="78">Patientrecord.CentrePersoOrthophoniste.CLS</Item>
<Item num="79">Patientrecord.CentrePersoOrthophoniste.Record.CLS</Item>
<Item num="80">Patientrecord.CentrePersoPsychiatre.CLS</Item>
<Item num="81">Patientrecord.CentrePersoPsychiatre.Record.CLS</Item>
<Item num="82">Patientrecord.CentrePersoPsychologue.CLS</Item>
<Item num="83">Patientrecord.CentrePersoPsychologue.Record.CLS</Item>
<Item num="84">Patientrecord.CentrePersoSecretaire.CLS</Item>
<Item num="85">Patientrecord.CentrePersoSecretaire.Record.CLS</Item>
<Item num="86">Patientrecord.CentrePersoTEC.CLS</Item>
<Item num="87">Patientrecord.CentrePersoTEC.Record.CLS</Item>
<Item num="88">Patientrecord.CentreReseau.CLS</Item>
<Item num="89">Patientrecord.CentreReseau.Record.CLS</Item>
<Item num="90">Patientrecord.CentreResponsable.CLS</Item>
<Item num="91">Patientrecord.CentreResponsable.Record.CLS</Item>
<Item num="92">Patientrecord.CentreType.CLS</Item>
<Item num="93">Patientrecord.CentreType.Record.CLS</Item>
<Item num="94">Patientrecord.ClActiviteConsultMemoire.CLS</Item>
<Item num="95">Patientrecord.ClActiviteConsultMemoire.Record.CLS</Item>
<Item num="96">Patientrecord.ClActiviteReseau.CLS</Item>
<Item num="97">Patientrecord.ClActiviteReseau.Record.CLS</Item>
<Item num="98">Patientrecord.ClCollabCmCmrr.CLS</Item>
<Item num="99">Patientrecord.ClCollabCmCmrr.Record.CLS</Item>
<Item num="100">Patientrecord.ClCollabNeuroPsy.CLS</Item>
<Item num="101">Patientrecord.ClCollabNeuroPsy.Record.CLS</Item>
<Item num="102">Patientrecord.ClNbFormAn.CLS</Item>
<Item num="103">Patientrecord.ClNbFormAn.Record.CLS</Item>
<Item num="104">Patientrecord.ClPratiqueETP.CLS</Item>
<Item num="105">Patientrecord.ClPratiqueETP.Record.CLS</Item>
<Item num="106">Patientrecord.ClTypeSpecialiste.CLS</Item>
<Item num="107">Patientrecord.ClTypeSpecialiste.Record.CLS</Item>
<Item num="108">Patientrecord.CmrrActiviteAnimation.CLS</Item>
<Item num="109">Patientrecord.CmrrActiviteAnimation.Record.CLS</Item>
<Item num="110">Patientrecord.CmrrActiviteEthique.CLS</Item>
<Item num="111">Patientrecord.CmrrActiviteEthique.Record.CLS</Item>
<Item num="112">Patientrecord.CmrrActiviteFormation.CLS</Item>
<Item num="113">Patientrecord.CmrrActiviteFormation.Record.CLS</Item>
<Item num="114">Patientrecord.CmrrActiviteRecherche.CLS</Item>
<Item num="115">Patientrecord.CmrrActiviteRecherche.Record.CLS</Item>
<Item num="116">Patientrecord.CmrrCmActiviteSoutien.CLS</Item>
<Item num="117">Patientrecord.CmrrCmActiviteSoutien.Record.CLS</Item>
<Item num="118">Patientrecord.CmrrCmActiviteStimul.CLS</Item>
<Item num="119">Patientrecord.CmrrCmActiviteStimul.Record.CLS</Item>
<Item num="120">Patientrecord.CmrrFormationsUniv.CLS</Item>
<Item num="121">Patientrecord.CmrrFormationsUniv.Record.CLS</Item>
<Item num="122">Patientrecord.CmrrPublications.CLS</Item>
<Item num="123">Patientrecord.CmrrPublications.Record.CLS</Item>
<Item num="124">Patientrecord.DclALD.CLS</Item>
<Item num="125">Patientrecord.DclALD.Record.CLS</Item>
<Item num="126">Patientrecord.DclAPA.CLS</Item>
<Item num="127">Patientrecord.DclAPA.Record.CLS</Item>
<Item num="128">Patientrecord.DclAnneePremierDiag.CLS</Item>
<Item num="129">Patientrecord.DclAnneePremierDiag.Record.CLS</Item>
<Item num="130">Patientrecord.DclCmrrRecours.CLS</Item>
<Item num="131">Patientrecord.DclCmrrRecours.Record.CLS</Item>
<Item num="132">Patientrecord.DclCmrrRecoursDiagDiff.CLS</Item>
<Item num="133">Patientrecord.DclCmrrRecoursDiagDiff.Record.CLS</Item>
<Item num="134">Patientrecord.DclCmrrRecoursPTech.CLS</Item>
<Item num="135">Patientrecord.DclCmrrRecoursPTech.Record.CLS</Item>
<Item num="136">Patientrecord.DclCmrrRecoursSpExpert.CLS</Item>
<Item num="137">Patientrecord.DclCmrrRecoursSpExpert.Record.CLS</Item>
<Item num="138">Patientrecord.DclCmrrRecoursSuivi.CLS</Item>
<Item num="139">Patientrecord.DclCmrrRecoursSuivi.Record.CLS</Item>
<Item num="140">Patientrecord.DclDateActe.CLS</Item>
<Item num="141">Patientrecord.DclDateActe.Record.CLS</Item>
<Item num="142">Patientrecord.DclDateDeces.CLS</Item>
<Item num="143">Patientrecord.DclDateDeces.Record.CLS</Item>
<Item num="144">Patientrecord.DclDateEntreeInstitution.CLS</Item>
<Item num="145">Patientrecord.DclDateEntreeInstitution.Record.CLS</Item>
<Item num="146">Patientrecord.DclDateFinSuivi.CLS</Item>
<Item num="147">Patientrecord.DclDateFinSuivi.Record.CLS</Item>
<Item num="148">Patientrecord.DclDiagnostic.CLS</Item>
<Item num="149">Patientrecord.DclDiagnostic.Record.CLS</Item>
<Item num="150">Patientrecord.DclDiagnosticN31.CLS</Item>
<Item num="151">Patientrecord.DclDiagnosticN31.Record.CLS</Item>
<Item num="152">Patientrecord.DclDiagnosticN32.CLS</Item>
<Item num="153">Patientrecord.DclDiagnosticN32.Record.CLS</Item>
<Item num="154">Patientrecord.DclDiagnosticN33.CLS</Item>
<Item num="155">Patientrecord.DclDiagnosticN33.Record.CLS</Item>
<Item num="156">Patientrecord.DclEffetIndesirable.CLS</Item>
<Item num="157">Patientrecord.DclEffetIndesirable.Record.CLS</Item>
<Item num="158">Patientrecord.DclEtatDemence.CLS</Item>
<Item num="159">Patientrecord.DclEtatDemence.Record.CLS</Item>
<Item num="160">Patientrecord.DclFinSuivi.CLS</Item>
<Item num="161">Patientrecord.DclFinSuivi.Record.CLS</Item>
<Item num="162">Patientrecord.DclIADLConsequence.CLS</Item>
<Item num="163">Patientrecord.DclIADLConsequence.Record.CLS</Item>
<Item num="164">Patientrecord.DclIADLDetection.CLS</Item>
<Item num="165">Patientrecord.DclIADLDetection.Record.CLS</Item>
<Item num="166">Patientrecord.DclIPSRAccueilJour.CLS</Item>
<Item num="167">Patientrecord.DclIPSRAccueilJour.Record.CLS</Item>
<Item num="168">Patientrecord.DclIPSRAucun.CLS</Item>
<Item num="169">Patientrecord.DclIPSRAucun.Record.CLS</Item>
<Item num="170">Patientrecord.DclIPSRAutre.CLS</Item>
<Item num="171">Patientrecord.DclIPSRAutre.Record.CLS</Item>
<Item num="172">Patientrecord.DclIPSRClic.CLS</Item>
<Item num="173">Patientrecord.DclIPSRClic.Record.CLS</Item>
<Item num="174">Patientrecord.DclIPSRErgotherapeute.CLS</Item>
<Item num="175">Patientrecord.DclIPSRErgotherapeute.Record.CLS</Item>
<Item num="176">Patientrecord.DclIPSREsad.CLS</Item>
<Item num="177">Patientrecord.DclIPSREsad.Record.CLS</Item>
<Item num="178">Patientrecord.DclIPSRGardeMalade.CLS</Item>
<Item num="179">Patientrecord.DclIPSRGardeMalade.Record.CLS</Item>
<Item num="180">Patientrecord.DclIPSRGroupe.CLS</Item>
<Item num="181">Patientrecord.DclIPSRGroupe.Record.CLS</Item>
<Item num="182">Patientrecord.DclIPSRHdj.CLS</Item>
<Item num="183">Patientrecord.DclIPSRHdj.Record.CLS</Item>
<Item num="184">Patientrecord.DclIPSRKinesitherapeute.CLS</Item>
<Item num="185">Patientrecord.DclIPSRKinesitherapeute.Record.CLS</Item>
<Item num="186">Patientrecord.DclIPSRMaia.CLS</Item>
<Item num="187">Patientrecord.DclIPSRMaia.Record.CLS</Item>
<Item num="188">Patientrecord.DclIPSROrthophoniste.CLS</Item>
<Item num="189">Patientrecord.DclIPSROrthophoniste.Record.CLS</Item>
<Item num="190">Patientrecord.DclIPSRPAERPA.CLS</Item>
<Item num="191">Patientrecord.DclIPSRPAERPA.Record.CLS</Item>
<Item num="192">Patientrecord.DclIPSRPsychologue.CLS</Item>
<Item num="193">Patientrecord.DclIPSRPsychologue.Record.CLS</Item>
<Item num="194">Patientrecord.DclIPSRRepits.CLS</Item>
<Item num="195">Patientrecord.DclIPSRRepits.Record.CLS</Item>
<Item num="196">Patientrecord.DclIPSRSiad.CLS</Item>
<Item num="197">Patientrecord.DclIPSRSiad.Record.CLS</Item>
<Item num="198">Patientrecord.DclIPSRUcc.CLS</Item>
<Item num="199">Patientrecord.DclIPSRUcc.Record.CLS</Item>
<Item num="200">Patientrecord.DclMMSE.CLS</Item>
<Item num="201">Patientrecord.DclMMSE.Record.CLS</Item>
<Item num="202">Patientrecord.DclMesureProtection.CLS</Item>
<Item num="203">Patientrecord.DclMesureProtection.Record.CLS</Item>
<Item num="204">Patientrecord.DclModeDeVie.CLS</Item>
<Item num="205">Patientrecord.DclModeDeVie.Record.CLS</Item>
<Item num="206">Patientrecord.DclPCAucun.CLS</Item>
<Item num="207">Patientrecord.DclPCAucun.Record.CLS</Item>
<Item num="208">Patientrecord.DclPCBioMarqueurs.CLS</Item>
<Item num="209">Patientrecord.DclPCBioMarqueurs.Record.CLS</Item>
<Item num="210">Patientrecord.DclPCIRM.CLS</Item>
<Item num="211">Patientrecord.DclPCIRM.Record.CLS</Item>
<Item num="212">Patientrecord.DclPCPET.CLS</Item>
<Item num="213">Patientrecord.DclPCPET.Record.CLS</Item>
<Item num="214">Patientrecord.DclPCSPECT.CLS</Item>
<Item num="215">Patientrecord.DclPCSPECT.Record.CLS</Item>
<Item num="216">Patientrecord.DclPCScanner.CLS</Item>
<Item num="217">Patientrecord.DclPCScanner.Record.CLS</Item>
<Item num="218">Patientrecord.DclPECAidant.CLS</Item>
<Item num="219">Patientrecord.DclPECAidant.Record.CLS</Item>
<Item num="220">Patientrecord.DclPR.CLS</Item>
<Item num="221">Patientrecord.DclPR.Record.CLS</Item>
<Item num="222">Patientrecord.DclPRType.CLS</Item>
<Item num="223">Patientrecord.DclPRType.Record.CLS</Item>
<Item num="224">Patientrecord.DclPRVisite.CLS</Item>
<Item num="225">Patientrecord.DclPRVisite.Record.CLS</Item>
<Item num="226">Patientrecord.DclRechAcceptPlacebo.CLS</Item>
<Item num="227">Patientrecord.DclRechAcceptPlacebo.Record.CLS</Item>
<Item num="228">Patientrecord.DclRechAutonom.CLS</Item>
<Item num="229">Patientrecord.DclRechAutonom.Record.CLS</Item>
<Item num="230">Patientrecord.DclRechContreIndic.CLS</Item>
<Item num="231">Patientrecord.DclRechContreIndic.Record.CLS</Item>
<Item num="232">Patientrecord.DclRechPresDispo.CLS</Item>
<Item num="233">Patientrecord.DclRechPresDispo.Record.CLS</Item>
<Item num="234">Patientrecord.DclTPAntagonisteNMDA.CLS</Item>
<Item num="235">Patientrecord.DclTPAntagonisteNMDA.Record.CLS</Item>
<Item num="236">Patientrecord.DclTPAntagonisteNMDAAvantPEC.CLS</Item>
<Item num="237">Patientrecord.DclTPAntagonisteNMDAAvantPEC.Record.CLS</Item>
<Item num="238">Patientrecord.DclTPAntagonisteNMDADebut.CLS</Item>
<Item num="239">Patientrecord.DclTPAntagonisteNMDADebut.Record.CLS</Item>
<Item num="240">Patientrecord.DclTPAntagonisteNMDADebutPar.CLS</Item>
<Item num="241">Patientrecord.DclTPAntagonisteNMDADebutPar.Record.CLS</Item>
<Item num="242">Patientrecord.DclTPAntagonisteNMDAFin.CLS</Item>
<Item num="243">Patientrecord.DclTPAntagonisteNMDAFin.Record.CLS</Item>
<Item num="244">Patientrecord.DclTPAntagonisteNMDAFinPar.CLS</Item>
<Item num="245">Patientrecord.DclTPAntagonisteNMDAFinPar.Record.CLS</Item>
<Item num="246">Patientrecord.DclTPAntiEpileptiques.CLS</Item>
<Item num="247">Patientrecord.DclTPAntiEpileptiques.Record.CLS</Item>
<Item num="248">Patientrecord.DclTPAntiEpileptiquesAvantPEC.CLS</Item>
<Item num="249">Patientrecord.DclTPAntiEpileptiquesAvantPEC.Record.CLS</Item>
<Item num="250">Patientrecord.DclTPAntiEpileptiquesDebut.CLS</Item>
<Item num="251">Patientrecord.DclTPAntiEpileptiquesDebut.Record.CLS</Item>
<Item num="252">Patientrecord.DclTPAntiEpileptiquesDebutPar.CLS</Item>
<Item num="253">Patientrecord.DclTPAntiEpileptiquesDebutPar.Record.CLS</Item>
<Item num="254">Patientrecord.DclTPAntiEpileptiquesFin.CLS</Item>
<Item num="255">Patientrecord.DclTPAntiEpileptiquesFin.Record.CLS</Item>
<Item num="256">Patientrecord.DclTPAntiEpileptiquesFinPar.CLS</Item>
<Item num="257">Patientrecord.DclTPAntiEpileptiquesFinPar.Record.CLS</Item>
<Item num="258">Patientrecord.DclTPAntiParkinsoniens.CLS</Item>
<Item num="259">Patientrecord.DclTPAntiParkinsoniens.Record.CLS</Item>
<Item num="260">Patientrecord.DclTPAntiParkinsoniensAvantPEC.CLS</Item>
<Item num="261">Patientrecord.DclTPAntiParkinsoniensAvantPEC.Record.CLS</Item>
<Item num="262">Patientrecord.DclTPAntiParkinsoniensDebut.CLS</Item>
<Item num="263">Patientrecord.DclTPAntiParkinsoniensDebut.Record.CLS</Item>
<Item num="264">Patientrecord.DclTPAntiParkinsoniensDebutPar.CLS</Item>
<Item num="265">Patientrecord.DclTPAntiParkinsoniensDebutPar.Record.CLS</Item>
<Item num="266">Patientrecord.DclTPAntiParkinsoniensFin.CLS</Item>
<Item num="267">Patientrecord.DclTPAntiParkinsoniensFin.Record.CLS</Item>
<Item num="268">Patientrecord.DclTPAntiParkinsoniensFinPar.CLS</Item>
<Item num="269">Patientrecord.DclTPAntiParkinsoniensFinPar.Record.CLS</Item>
<Item num="270">Patientrecord.DclTPAntidepresseurs.CLS</Item>
<Item num="271">Patientrecord.DclTPAntidepresseurs.Record.CLS</Item>
<Item num="272">Patientrecord.DclTPAntidepresseursAvantPEC.CLS</Item>
<Item num="273">Patientrecord.DclTPAntidepresseursAvantPEC.Record.CLS</Item>
<Item num="274">Patientrecord.DclTPAntidepresseursDebut.CLS</Item>
<Item num="275">Patientrecord.DclTPAntidepresseursDebut.Record.CLS</Item>
<Item num="276">Patientrecord.DclTPAntidepresseursDebutPar.CLS</Item>
<Item num="277">Patientrecord.DclTPAntidepresseursDebutPar.Record.CLS</Item>
<Item num="278">Patientrecord.DclTPAntidepresseursFin.CLS</Item>
<Item num="279">Patientrecord.DclTPAntidepresseursFin.Record.CLS</Item>
<Item num="280">Patientrecord.DclTPAntidepresseursFinPar.CLS</Item>
<Item num="281">Patientrecord.DclTPAntidepresseursFinPar.Record.CLS</Item>
<Item num="282">Patientrecord.DclTPAnxiolitiques.CLS</Item>
<Item num="283">Patientrecord.DclTPAnxiolitiques.Record.CLS</Item>
<Item num="284">Patientrecord.DclTPAnxiolitiquesAvantPEC.CLS</Item>
<Item num="285">Patientrecord.DclTPAnxiolitiquesAvantPEC.Record.CLS</Item>
<Item num="286">Patientrecord.DclTPAnxiolitiquesDebut.CLS</Item>
<Item num="287">Patientrecord.DclTPAnxiolitiquesDebut.Record.CLS</Item>
<Item num="288">Patientrecord.DclTPAnxiolitiquesDebutPar.CLS</Item>
<Item num="289">Patientrecord.DclTPAnxiolitiquesDebutPar.Record.CLS</Item>
<Item num="290">Patientrecord.DclTPAnxiolitiquesFin.CLS</Item>
<Item num="291">Patientrecord.DclTPAnxiolitiquesFin.Record.CLS</Item>
<Item num="292">Patientrecord.DclTPAnxiolitiquesFinPar.CLS</Item>
<Item num="293">Patientrecord.DclTPAnxiolitiquesFinPar.Record.CLS</Item>
<Item num="294">Patientrecord.DclTPAucun.CLS</Item>
<Item num="295">Patientrecord.DclTPAucun.Record.CLS</Item>
<Item num="296">Patientrecord.DclTPAucunAvantPEC.CLS</Item>
<Item num="297">Patientrecord.DclTPAucunAvantPEC.Record.CLS</Item>
<Item num="298">Patientrecord.DclTPAucunDansListe.CLS</Item>
<Item num="299">Patientrecord.DclTPAucunDansListe.Record.CLS</Item>
<Item num="300">Patientrecord.DclTPAucunDansListeAvantPEC.CLS</Item>
<Item num="301">Patientrecord.DclTPAucunDansListeAvantPEC.Record.CLS</Item>
<Item num="302">Patientrecord.DclTPAucunDansListeDebut.CLS</Item>
<Item num="303">Patientrecord.DclTPAucunDansListeDebut.Record.CLS</Item>
<Item num="304">Patientrecord.DclTPAucunDansListeDebutPar.CLS</Item>
<Item num="305">Patientrecord.DclTPAucunDansListeDebutPar.Record.CLS</Item>
<Item num="306">Patientrecord.DclTPAucunDansListeFin.CLS</Item>
<Item num="307">Patientrecord.DclTPAucunDansListeFin.Record.CLS</Item>
<Item num="308">Patientrecord.DclTPAucunDansListeFinPar.CLS</Item>
<Item num="309">Patientrecord.DclTPAucunDansListeFinPar.Record.CLS</Item>
<Item num="310">Patientrecord.DclTPAucunDebut.CLS</Item>
<Item num="311">Patientrecord.DclTPAucunDebut.Record.CLS</Item>
<Item num="312">Patientrecord.DclTPAucunDebutPar.CLS</Item>
<Item num="313">Patientrecord.DclTPAucunDebutPar.Record.CLS</Item>
<Item num="314">Patientrecord.DclTPAucunFin.CLS</Item>
<Item num="315">Patientrecord.DclTPAucunFin.Record.CLS</Item>
<Item num="316">Patientrecord.DclTPAucunFinPar.CLS</Item>
<Item num="317">Patientrecord.DclTPAucunFinPar.Record.CLS</Item>
<Item num="318">Patientrecord.DclTPAutres.CLS</Item>
<Item num="319">Patientrecord.DclTPAutres.Record.CLS</Item>
<Item num="320">Patientrecord.DclTPAutresAvantPEC.CLS</Item>
<Item num="321">Patientrecord.DclTPAutresAvantPEC.Record.CLS</Item>
<Item num="322">Patientrecord.DclTPAutresDebut.CLS</Item>
<Item num="323">Patientrecord.DclTPAutresDebut.Record.CLS</Item>
<Item num="324">Patientrecord.DclTPAutresDebutPar.CLS</Item>
<Item num="325">Patientrecord.DclTPAutresDebutPar.Record.CLS</Item>
<Item num="326">Patientrecord.DclTPAutresFin.CLS</Item>
<Item num="327">Patientrecord.DclTPAutresFin.Record.CLS</Item>
<Item num="328">Patientrecord.DclTPAutresFinPar.CLS</Item>
<Item num="329">Patientrecord.DclTPAutresFinPar.Record.CLS</Item>
<Item num="330">Patientrecord.DclTPHypnotiques.CLS</Item>
<Item num="331">Patientrecord.DclTPHypnotiques.Record.CLS</Item>
<Item num="332">Patientrecord.DclTPHypnotiquesAvantPEC.CLS</Item>
<Item num="333">Patientrecord.DclTPHypnotiquesAvantPEC.Record.CLS</Item>
<Item num="334">Patientrecord.DclTPHypnotiquesDebut.CLS</Item>
<Item num="335">Patientrecord.DclTPHypnotiquesDebut.Record.CLS</Item>
<Item num="336">Patientrecord.DclTPHypnotiquesDebutPar.CLS</Item>
<Item num="337">Patientrecord.DclTPHypnotiquesDebutPar.Record.CLS</Item>
<Item num="338">Patientrecord.DclTPHypnotiquesFin.CLS</Item>
<Item num="339">Patientrecord.DclTPHypnotiquesFin.Record.CLS</Item>
<Item num="340">Patientrecord.DclTPHypnotiquesFinPar.CLS</Item>
<Item num="341">Patientrecord.DclTPHypnotiquesFinPar.Record.CLS</Item>
<Item num="342">Patientrecord.DclTPInhibAcetyl.CLS</Item>
<Item num="343">Patientrecord.DclTPInhibAcetyl.Record.CLS</Item>
<Item num="344">Patientrecord.DclTPInhibAcetylAvantPEC.CLS</Item>
<Item num="345">Patientrecord.DclTPInhibAcetylAvantPEC.Record.CLS</Item>
<Item num="346">Patientrecord.DclTPInhibAcetylDebut.CLS</Item>
<Item num="347">Patientrecord.DclTPInhibAcetylDebut.Record.CLS</Item>
<Item num="348">Patientrecord.DclTPInhibAcetylDebutPar.CLS</Item>
<Item num="349">Patientrecord.DclTPInhibAcetylDebutPar.Record.CLS</Item>
<Item num="350">Patientrecord.DclTPInhibAcetylFin.CLS</Item>
<Item num="351">Patientrecord.DclTPInhibAcetylFin.Record.CLS</Item>
<Item num="352">Patientrecord.DclTPInhibAcetylFinPar.CLS</Item>
<Item num="353">Patientrecord.DclTPInhibAcetylFinPar.Record.CLS</Item>
<Item num="354">Patientrecord.DclTPNeuroleptiques.CLS</Item>
<Item num="355">Patientrecord.DclTPNeuroleptiques.Record.CLS</Item>
<Item num="356">Patientrecord.DclTPNeuroleptiquesAvantPEC.CLS</Item>
<Item num="357">Patientrecord.DclTPNeuroleptiquesAvantPEC.Record.CLS</Item>
<Item num="358">Patientrecord.DclTPNeuroleptiquesDebut.CLS</Item>
<Item num="359">Patientrecord.DclTPNeuroleptiquesDebut.Record.CLS</Item>
<Item num="360">Patientrecord.DclTPNeuroleptiquesDebutPar.CLS</Item>
<Item num="361">Patientrecord.DclTPNeuroleptiquesDebutPar.Record.CLS</Item>
<Item num="362">Patientrecord.DclTPNeuroleptiquesFin.CLS</Item>
<Item num="363">Patientrecord.DclTPNeuroleptiquesFin.Record.CLS</Item>
<Item num="364">Patientrecord.DclTPNeuroleptiquesFinPar.CLS</Item>
<Item num="365">Patientrecord.DclTPNeuroleptiquesFinPar.Record.CLS</Item>
<Item num="366">Patientrecord.DclTPNootropes.CLS</Item>
<Item num="367">Patientrecord.DclTPNootropes.Record.CLS</Item>
<Item num="368">Patientrecord.DclTPNootropesAvantPEC.CLS</Item>
<Item num="369">Patientrecord.DclTPNootropesAvantPEC.Record.CLS</Item>
<Item num="370">Patientrecord.DclTPNootropesDebut.CLS</Item>
<Item num="371">Patientrecord.DclTPNootropesDebut.Record.CLS</Item>
<Item num="372">Patientrecord.DclTPNootropesDebutPar.CLS</Item>
<Item num="373">Patientrecord.DclTPNootropesDebutPar.Record.CLS</Item>
<Item num="374">Patientrecord.DclTPNootropesFin.CLS</Item>
<Item num="375">Patientrecord.DclTPNootropesFin.Record.CLS</Item>
<Item num="376">Patientrecord.DclTPNootropesFinPar.CLS</Item>
<Item num="377">Patientrecord.DclTPNootropesFinPar.Record.CLS</Item>
<Item num="378">Patientrecord.DclTPThymoRegulateurs.CLS</Item>
<Item num="379">Patientrecord.DclTPThymoRegulateurs.Record.CLS</Item>
<Item num="380">Patientrecord.DclTPThymoRegulateursAvantPEC.CLS</Item>
<Item num="381">Patientrecord.DclTPThymoRegulateursAvantPEC.Record.CLS</Item>
<Item num="382">Patientrecord.DclTPThymoRegulateursDebut.CLS</Item>
<Item num="383">Patientrecord.DclTPThymoRegulateursDebut.Record.CLS</Item>
<Item num="384">Patientrecord.DclTPThymoRegulateursDebutPar.CLS</Item>
<Item num="385">Patientrecord.DclTPThymoRegulateursDebutPar.Record.CLS</Item>
<Item num="386">Patientrecord.DclTPThymoRegulateursFin.CLS</Item>
<Item num="387">Patientrecord.DclTPThymoRegulateursFin.Record.CLS</Item>
<Item num="388">Patientrecord.DclTPThymoRegulateursFinPar.CLS</Item>
<Item num="389">Patientrecord.DclTPThymoRegulateursFinPar.Record.CLS</Item>
<Item num="390">Patientrecord.DclTypeActe.CLS</Item>
<Item num="391">Patientrecord.DclTypeActe.Record.CLS</Item>
<Item num="392">Patientrecord.PatientAccompagnant.CLS</Item>
<Item num="393">Patientrecord.PatientAccompagnant.Record.CLS</Item>
<Item num="394">Patientrecord.PatientAnneeNaissance.CLS</Item>
<Item num="395">Patientrecord.PatientAnneeNaissance.Record.CLS</Item>
<Item num="396">Patientrecord.PatientComplexeRecord.Batch.CLS</Item>
<Item num="397">Patientrecord.PatientComplexeRecord.CLS</Item>
<Item num="398">Patientrecord.PatientEnvoyePar.CLS</Item>
<Item num="399">Patientrecord.PatientEnvoyePar.Record.CLS</Item>
<Item num="400">Patientrecord.PatientId.CLS</Item>
<Item num="401">Patientrecord.PatientId.Record.CLS</Item>
<Item num="402">Patientrecord.PatientIdPrecedent.CLS</Item>
<Item num="403">Patientrecord.PatientIdPrecedent.Record.CLS</Item>
<Item num="404">Patientrecord.PatientNiveauEtudes.CLS</Item>
<Item num="405">Patientrecord.PatientNiveauEtudes.Record.CLS</Item>
<Item num="406">Patientrecord.PatientProfession.CLS</Item>
<Item num="407">Patientrecord.PatientProfession.Record.CLS</Item>
<Item num="408">Patientrecord.PatientSexe.CLS</Item>
<Item num="409">Patientrecord.PatientSexe.Record.CLS</Item>
<Item num="410">Patientrecord.PatientSituationGeo.CLS</Item>
<Item num="411">Patientrecord.PatientSituationGeo.Record.CLS</Item>
<Item num="412">Patientrecord.RetourMail.CLS</Item>
<Item num="413">Patientrecord.RetourMail.Record.CLS</Item>
<Item num="414">Settings:EnsLib.RecordMap.Service.ComplexBatchFileService.PTD</Item>
<Item num="415">user.ListesItems.CLS</Item>
<Item num="416">user.patientlist.CLS</Item>
</Contents>
<ProductionClassInExport>BNATESTPKG.FoundationProduction</ProductionClassInExport>
</Deployment>

]]></ProjectTextDocument>
</Document>

<Document name="Settings:EnsLib.RecordMap.Service.ComplexBatchFileService.PTD"><ProjectTextDocument name="Settings:EnsLib.RecordMap.Service.ComplexBatchFileService" description="Settings for EnsLib.RecordMap.Service.ComplexBatchFileService in Production BNATESTPKG.FoundationProduction">
<![CDATA[<Item Name="EnsLib.RecordMap.Service.ComplexBatchFileService" Category="" ClassName="EnsLib.RecordMap.Service.ComplexBatchFileService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule=""><Setting Target="Host" Name="TargetConfigNames">BPLBNA.ajoutdanssql</Setting><Setting Target="Adapter" Name="FilePath">/dur/wafik/input/</Setting><Setting Target="Adapter" Name="FileSpec">*.txt</Setting><Setting Target="Host" Name="ComplexMap">Patientrecord.PatientComplexeRecord</Setting></Item>
]]></ProjectTextDocument>
</Document></Export>
